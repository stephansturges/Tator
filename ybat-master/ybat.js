(() => {
    "use strict";

    // -----------------------------------------
    // NEW CODE: Add a global dictionary for pending bboxes, and a UUID generator.
    // -----------------------------------------
    let pendingApiBboxes = {};

    const IMAGE_EXTENSIONS = new Set(["jpg", "jpeg", "png", "webp", "bmp", "tif", "tiff"]);
    const LABEL_EXTENSIONS = new Set(["txt"]);
    let directoryFallbackWarned = false;

    function generateUUID() {
        // Modern browsers: use crypto.randomUUID().
        // Fallback if unavailable.
        if (window.crypto && window.crypto.randomUUID) {
            return crypto.randomUUID();
        }
        // Fallback: timestamp + random
        return (
            Date.now().toString(36) +
            Math.random().toString(36).substring(2, 12)
        );
    }

    // 1) Define a palette of 100 colors spread around the hue wheel
    //    (First ~20 are roughly 0°, 18°, 36°, ..., 342°, then continuing).
    const colorPalette = [];
    for (let i = 0; i < 100; i++) {
        const baseHue = i * 20; 
        const randomOffset = Math.random() * 0.3;
        const hue = (baseHue + randomOffset) % 360;
        colorPalette.push(`hsla(${hue}, 100%, 45%, 1)`);
    }

    function getColorFromClass(className) {
        const index = classes[className] % 100; 
        return colorPalette[index];
    }

    function withAlpha(color, alpha) {
        return color.replace(/(\d?\.?\d+)\)$/, `${alpha})`);
    }

    function dedupeStringList(list) {
        const out = [];
        const seen = new Set();
        for (const raw of Array.isArray(list) ? list : []) {
            const val = String(raw || "").trim();
            if (!val || seen.has(val)) {
                continue;
            }
            seen.add(val);
            out.push(val);
        }
        return out;
    }

    function fallbackWarningLabel(code) {
        const key = String(code || "").trim();
        if (!key) {
            return "";
        }
        const label = key
            .replace(/[^a-z0-9]+/gi, " ")
            .trim()
            .replace(/\s+/g, " ")
            .replace(/\bclip\b/gi, "CLIP")
            .replace(/\bsam3\b/gi, "SAM3")
            .replace(/\bfps?\b/gi, "FP");
        if (!label) {
            return key;
        }
        return `${label.slice(0, 1).toUpperCase()}${label.slice(1)}`;
    }

    function formatAgentWarningsForUi(warnList) {
        const messagesByCode = {
            no_results: "No detections found.",
            class_override_used: "Output class override was applied.",
            clip_unavailable: "CLIP filter couldn’t run (model unavailable), so detections weren’t CLIP-filtered.",
            clip_embedding_empty: "CLIP embeddings were empty, so CLIP filtering was skipped.",
            clip_missing_exemplars: "This recipe has no exemplar crops, so exemplar-based CLIP filtering was skipped.",
            missing_crop_exemplar: "Some exemplar crops referenced by the recipe are missing.",
            missing_crop_negative: "Some negative exemplar crops referenced by the recipe are missing.",
            clip_fp_filtered: "CLIP filtering removed some detections (reduced false positives).",
            clip_filtered_all: "CLIP filtering removed all detections.",
            clip_head_class_missing: "The recipe’s CLIP head doesn’t contain this output class name, so head-based filtering was skipped.",
            clip_head_override_ignored: "Extra CLIP head thresholds were ignored because this recipe has no embedded CLIP head.",
            clip_head_unavailable: "CLIP head scoring wasn’t available, so dedupe used SAM score instead.",
            clip_head_no_scores: "CLIP head scoring produced no scores, so dedupe used SAM score instead.",
            detections_pruned: "Some detections were dropped to fit the result limit.",
            masks_pruned: "Some masks were dropped to fit the result limit.",
            negatives_empty: "No negative exemplars were available.",
            clip_selection_fallback_random: "CLIP exemplar selection failed, so random exemplars were used instead.",
            extra_clip_missing_class: "Extra CLIP filtering couldn’t run because the output class name is missing.",
            extra_clip_classifier_unavailable: "Extra CLIP model couldn’t be loaded, so extra filtering was skipped.",
            extra_clip_class_missing: "Extra CLIP model doesn’t contain this output class name, so extra filtering was skipped.",
            extra_clip_unavailable: "Extra CLIP filtering couldn’t run, so extra filtering was skipped.",
            extra_clip_filtered: "Extra CLIP filtering removed some detections.",
            extra_clip_filtered_all: "Extra CLIP filtering removed all detections.",
        };
        const codes = dedupeStringList(warnList);
        const messages = codes.map((code) => messagesByCode[code] || fallbackWarningLabel(code) || String(code));
        return {
            codes,
            message: messages.filter(Boolean).join(" • "),
        };
    }

    let clipProgressFill = null;
    let clipProgressTimer = null;
    let clipProgressToken = 0;

    function ensureClipProgressElement() {
        if (!clipProgressFill) {
            clipProgressFill = document.getElementById("clipProgressFill");
        }
        return clipProgressFill;
    }

    function beginClipProgress() {
        const fill = ensureClipProgressElement();
        const token = ++clipProgressToken;
        if (!fill) {
            return token;
        }
        if (clipProgressTimer) {
            clearInterval(clipProgressTimer);
            clipProgressTimer = null;
        }
        fill.style.transition = "width 0.15s ease-out";
        fill.style.width = "10%";
        let progress = 10;
        clipProgressTimer = setInterval(() => {
            if (clipProgressToken !== token) {
                clearInterval(clipProgressTimer);
                clipProgressTimer = null;
                return;
            }
            progress = Math.min(progress + (Math.random() * 18 + 4), 85);
            fill.style.width = `${progress}%`;
        }, 200);
        return token;
    }

    function endClipProgress(token) {
        if (clipProgressToken !== token) {
            return;
        }
        const fill = ensureClipProgressElement();
        if (!fill) {
            clipProgressToken++;
            return;
        }
        if (clipProgressTimer) {
            clearInterval(clipProgressTimer);
            clipProgressTimer = null;
        }
        fill.style.transition = "width 0.12s ease-out";
        fill.style.width = "100%";
        const currentToken = token;
        setTimeout(() => {
            if (clipProgressToken !== currentToken) {
                return;
            }
            fill.style.transition = "width 0.2s ease-in";
            fill.style.width = "0%";
            clipProgressToken++;
        }, 160);
    }

    let autoMode = false;
    let samMode = false;
    let pointMode = false;
    let multiPointMode = false;
    let samAutoMode = false;
    let samPointAutoMode = false;
    let samMultiPointAutoMode = false;

    let multiPointPending = false;
    let multiPointPendingToken = null;
    let multiPointPoints = [];
    let multiPointPendingBboxInfo = null;
    const multiPointQueue = [];
    let multiPointWaitingForPreload = false;

    let samVariant = "sam3";
    let autoModeCheckbox = null;
    let autoClassMarginEnabledCheckbox = null;
    let autoClassMarginValueInput = null;
    let autoClassMarginWarnCheckbox = null;
    let regionDetectorSelect = null;
    let yoloRegionConfInput = null;
    let yoloRegionIouInput = null;
    let yoloRegionMaxDetInput = null;
    let detectorRunModeSelect = null;
    let detectorSliceSizeInput = null;
    let detectorSliceOverlapInput = null;
    let detectorMergeIouInput = null;
    let detectorWindowOptions = null;
    let detectorRunButton = null;
    let detectorBatchCountInput = null;
    let detectorBatchIncludeCurrentToggle = null;
    let detectorBatchRunButton = null;
    let detectorBatchStopButton = null;
    let detectorBatchAllButton = null;
    let detectorBatchActive = false;
    let detectorBatchCancel = false;
    let samModeCheckbox = null;
    let pointModeCheckbox = null;
    let multiPointModeCheckbox = null;
    let samVariantSelect = null;
    let samPreloadCheckbox = null;
    let samPreloadEnabled = false;
    let samPreloadToken = 0;
    let samPreloadAbortController = null;
    let samPreloadLastKey = null;
    let samPreloadCurrentImageName = null;
    let samStatusProgressEl = null;
    const samTokenCache = new Map();
    let samPreloadTimer = null;
    const SAM_PRELOAD_DEBOUNCE_MS = 250;
    const SAM_PRELOAD_IMAGE_SWITCH_DELAY_MS = 320;
    let samPreloadGeneration = 0;
    let samPreloadCurrentVariant = null;
    const SAM_PRELOAD_WAIT_TIMEOUT_MS = 8000;
    const samPreloadWatchers = new Map();
    const slotPreloadControllers = { next: null, previous: null };
    const slotPreloadPromises = new Map();
    const slotLoadingIndicators = new Map();
    let samPreloadQueuedKey = null;
    let latestSlotStatuses = [];
    let samSlotStatusTimer = null;
    let samSlotStatusPending = false;
    let samSlotStatusNeedsRefresh = false;
    const SAM_SLOT_STATUS_DEBOUNCE_MS = 600;
    let samSlotsEnabled = false;
    let samSlotsSupportChecked = false;
    let samPredictorBudget = 3;
    let predictorTabInitialized = false;
    let predictorRefreshTimer = null;
    let predictorRefreshInFlight = false;
    const PREDICTOR_REFRESH_INTERVAL_MS = 5000;
    let predictorSettings = {
        maxPredictors: 3,
        minPredictors: 1,
        maxSupportedPredictors: 3,
        activePredictors: 3,
        loadedPredictors: 0,
        processRamMb: 0,
        totalRamMb: 0,
        availableRamMb: 0,
        imageRamMb: 0,
    };

    let imagesSelectButton = null;
    let classesSelectButton = null;
    let bboxesSelectButton = null;
    let bboxesFolderSelectButton = null;

    let samStatusEl = null;
    let samStatusTimer = null;
    let samStatusMessageToken = 0;
    let samJobSequence = 0;
    let samCancelVersion = 0;
    const samActiveJobs = new Map();
    let imageListSelectionLock = 0;
    let imageLoadInProgress = false;
    let imageLoadPromise = null;
    const tweakPreserveSet = new Set();
    let magicTweakRunning = false;

    const multiPointColors = {
        positive: { stroke: "#2ecc71", fill: "rgba(46, 204, 113, 0.35)" },
        negative: { stroke: "#e74c3c", fill: "rgba(231, 76, 60, 0.35)" },
    };

    const DEFAULT_API_ROOT = "http://localhost:8000";
    const API_STORAGE_KEY = "tator.apiRoot";
    let API_ROOT = loadStoredApiRoot();
    const TAB_LABELING = "labeling";
    const TAB_TRAINING = "training";
    const TAB_QWEN_TRAIN = "qwen-train";
    const TAB_SAM3_TRAIN = "sam3-train";
    const TAB_YOLO_TRAIN = "yolo-train";
    const TAB_RFDETR_TRAIN = "rfdetr-train";
    const TAB_AGENT_MINING = "agent-mining";
    const TAB_PROMPT_HELPER = "prompt-helper";
    const TAB_DATASETS = "datasets";
    const TAB_SAM3_PROMPT_MODELS = "sam3-prompt-models";
    const TAB_DETECTORS = "detectors";
    const TAB_ACTIVE = "active";
    const TAB_QWEN = "qwen";
    const TAB_PREDICTORS = "predictors";
    const TAB_SETTINGS = "settings";

    function formatBytesLabel(bytes) {
        const mb = bytes / (1024 * 1024);
        const gb = mb / 1024;
        if (!Number.isFinite(bytes) || bytes < 0) return "n/a";
        return gb >= 1 ? `${gb.toFixed(1)} GB` : `${mb.toFixed(1)} MB`;
    }

    function syncRegionDetectorInputs() {
        if (regionDetectorSelect && yoloRegionIouInput) {
            const mode = (regionDetectorSelect.value || "yolo").toLowerCase();
            yoloRegionIouInput.disabled = mode !== "yolo";
        }
    }

    function syncDetectorRunModeInputs() {
        if (!detectorRunModeSelect || !detectorWindowOptions) {
            return;
        }
        const mode = (detectorRunModeSelect.value || "full").toLowerCase();
        detectorWindowOptions.style.display = mode === "windowed" ? "" : "none";
    }

    async function fetchDetectorDefault() {
        try {
            const resp = await fetch(`${API_ROOT}/detectors/default`);
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            const mode = String(data?.mode || "").toLowerCase();
            if (mode === "yolo" || mode === "rfdetr") {
                detectorState.mode = mode;
            }
            return detectorState.mode;
        } catch (err) {
            console.warn("Detector default fetch failed", err);
            return detectorState.mode;
        }
    }

    function renderDetectorStatus() {
        if (!detectorElements.status) return;
        const yoloName = detectorState.yoloActive?.run_name || detectorState.yoloActive?.run_id;
        const rfdetrName = detectorState.rfdetrActive?.run_name || detectorState.rfdetrActive?.run_id;
        const yoloLabel = yoloName ? `YOLO active: ${yoloName}` : "YOLO active: none";
        const rfdetrLabel = rfdetrName ? `RF-DETR active: ${rfdetrName}` : "RF-DETR active: none";
        detectorElements.status.textContent = `${yoloLabel} • ${rfdetrLabel}`;
    }

    async function refreshDetectorStatus() {
        try {
            const [yoloResp, rfdetrResp] = await Promise.all([
                fetch(`${API_ROOT}/yolo/active`),
                fetch(`${API_ROOT}/rfdetr/active`),
            ]);
            detectorState.yoloActive = yoloResp.ok ? await yoloResp.json() : null;
            detectorState.rfdetrActive = rfdetrResp.ok ? await rfdetrResp.json() : null;
        } catch (err) {
            console.warn("Detector status fetch failed", err);
            detectorState.yoloActive = null;
            detectorState.rfdetrActive = null;
        }
        renderDetectorStatus();
    }

    async function fetchDetectorRuns(mode) {
        const endpoint = mode === "yolo" ? "yolo" : "rfdetr";
        const resp = await fetch(`${API_ROOT}/${endpoint}/runs`);
        if (!resp.ok) throw new Error(await resp.text());
        const data = await resp.json();
        return Array.isArray(data) ? data : [];
    }

    async function maybeAutoSelectDetectorRun() {
        const mode = detectorState.mode;
        const active = mode === "yolo" ? detectorState.yoloActive : detectorState.rfdetrActive;
        const hasActive = active && (active.best_path || active.run_id || active.run_name);
        if (hasActive) return;
        if (detectorState.prompted[mode]) return;
        detectorState.prompted[mode] = true;
        if (detectorElements.message) {
            detectorElements.message.textContent = `${mode.toUpperCase()} default has no active run.`;
        }
        let runs = [];
        try {
            runs = await fetchDetectorRuns(mode);
        } catch (err) {
            console.warn("Detector runs fetch failed", err);
            return;
        }
        if (!runs.length) {
            if (detectorElements.message) {
                detectorElements.message.textContent = `${mode.toUpperCase()} default has no saved runs. Train one first.`;
            }
            return;
        }
        const candidate = runs[0];
        const name = candidate.run_name || candidate.run_id || "latest run";
        const ok = confirm(`${mode.toUpperCase()} default has no active run. Activate "${name}" now?`);
        if (!ok) return;
        const endpoint = mode === "yolo" ? "yolo" : "rfdetr";
        try {
            const resp = await fetch(`${API_ROOT}/${endpoint}/active`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ run_id: candidate.run_id }),
            });
            if (!resp.ok) throw new Error(await resp.text());
            await refreshDetectorStatus();
            if (detectorElements.message) {
                detectorElements.message.textContent = `Activated ${mode.toUpperCase()} run "${name}".`;
            }
        } catch (err) {
            console.warn("Detector activation failed", err);
            if (detectorElements.message) {
                detectorElements.message.textContent = `Failed to activate ${mode.toUpperCase()} run: ${err.message || err}`;
            }
        }
    }

    function applyDetectorDefault(mode) {
        const normalized = String(mode || "").toLowerCase();
        if (normalized !== "yolo" && normalized !== "rfdetr") return;
        detectorState.mode = normalized;
        if (detectorElements.defaultSelect) {
            detectorElements.defaultSelect.value = normalized;
        }
        if (regionDetectorSelect) {
            regionDetectorSelect.value = normalized;
            syncRegionDetectorInputs();
        }
    }

    async function saveDetectorDefault() {
        if (!detectorElements.defaultSelect) return;
        const mode = detectorElements.defaultSelect.value || "rfdetr";
        if (detectorElements.message) {
            detectorElements.message.textContent = "Saving default detector…";
        }
        try {
            const resp = await fetch(`${API_ROOT}/detectors/default`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ mode }),
            });
            if (!resp.ok) throw new Error(await resp.text());
            applyDetectorDefault(mode);
            if (detectorElements.message) {
                detectorElements.message.textContent = `Default detector set to ${mode.toUpperCase()}.`;
            }
            await refreshDetectorStatus();
            await maybeAutoSelectDetectorRun();
        } catch (err) {
            console.warn("Default detector save failed", err);
            if (detectorElements.message) {
                detectorElements.message.textContent = `Failed to set default detector: ${err.message || err}`;
            }
        }
    }

    async function initDetectorPanel() {
        detectorElements.defaultSelect = document.getElementById("detectorDefaultSelect");
        detectorElements.defaultSave = document.getElementById("detectorDefaultSave");
        detectorElements.defaultRefresh = document.getElementById("detectorDefaultRefresh");
        detectorElements.status = document.getElementById("detectorActiveStatus");
        detectorElements.message = document.getElementById("detectorDefaultMessage");
        detectorElements.yoloSelect = document.getElementById("detectorYoloRunSelect");
        detectorElements.yoloRefresh = document.getElementById("detectorYoloRunRefresh");
        detectorElements.yoloActivate = document.getElementById("detectorYoloRunActivate");
        detectorElements.yoloDownload = document.getElementById("detectorYoloRunDownload");
        detectorElements.yoloDelete = document.getElementById("detectorYoloRunDelete");
        detectorElements.yoloSummary = document.getElementById("detectorYoloRunSummary");
        detectorElements.yoloMetrics = document.getElementById("detectorYoloRunMetrics");
        detectorElements.yoloLabelmap = document.getElementById("detectorYoloRunLabelmap");
        detectorElements.yoloMessage = document.getElementById("detectorYoloRunMessage");
        detectorElements.rfdetrSelect = document.getElementById("detectorRfDetrRunSelect");
        detectorElements.rfdetrRefresh = document.getElementById("detectorRfDetrRunRefresh");
        detectorElements.rfdetrActivate = document.getElementById("detectorRfDetrRunActivate");
        detectorElements.rfdetrDownload = document.getElementById("detectorRfDetrRunDownload");
        detectorElements.rfdetrDelete = document.getElementById("detectorRfDetrRunDelete");
        detectorElements.rfdetrSummary = document.getElementById("detectorRfDetrRunSummary");
        detectorElements.rfdetrMetrics = document.getElementById("detectorRfDetrRunMetrics");
        detectorElements.rfdetrLabelmap = document.getElementById("detectorRfDetrRunLabelmap");
        detectorElements.rfdetrMessage = document.getElementById("detectorRfDetrRunMessage");
        if (detectorElements.defaultSave) {
            detectorElements.defaultSave.addEventListener("click", () => {
                saveDetectorDefault().catch((err) => console.warn("Detector default save failed", err));
            });
        }
        if (detectorElements.defaultRefresh) {
            detectorElements.defaultRefresh.addEventListener("click", () => {
                refreshDetectorStatus().catch((err) => console.warn("Detector status refresh failed", err));
                fetchDetectorDefault()
                    .then((mode) => applyDetectorDefault(mode))
                    .catch((err) => console.warn("Detector default refresh failed", err));
            });
        }
        const mode = await fetchDetectorDefault();
        applyDetectorDefault(mode);
        await refreshDetectorStatus();
        await maybeAutoSelectDetectorRun();
        if (detectorElements.yoloRefresh) {
            detectorElements.yoloRefresh.addEventListener("click", () => {
                loadYoloRunList(true).catch((err) => console.warn("Detector YOLO refresh failed", err));
            });
        }
        if (detectorElements.rfdetrRefresh) {
            detectorElements.rfdetrRefresh.addEventListener("click", () => {
                loadRfDetrRunList(true).catch((err) => console.warn("Detector RF-DETR refresh failed", err));
            });
        }
        if (detectorElements.yoloSelect) {
            detectorElements.yoloSelect.addEventListener("change", () => {
                yoloRunState.selectedId = detectorElements.yoloSelect.value || null;
                updateDetectorRunSummary("yolo").catch((err) => console.warn("Detector YOLO summary failed", err));
            });
        }
        if (detectorElements.rfdetrSelect) {
            detectorElements.rfdetrSelect.addEventListener("change", () => {
                rfdetrRunState.selectedId = detectorElements.rfdetrSelect.value || null;
                updateDetectorRunSummary("rfdetr").catch((err) => console.warn("Detector RF-DETR summary failed", err));
            });
        }
        if (detectorElements.yoloActivate) {
            detectorElements.yoloActivate.addEventListener("click", () => {
                setActiveDetectorRun("yolo").catch((err) => console.warn("Detector YOLO activate failed", err));
            });
        }
        if (detectorElements.rfdetrActivate) {
            detectorElements.rfdetrActivate.addEventListener("click", () => {
                setActiveDetectorRun("rfdetr").catch((err) => console.warn("Detector RF-DETR activate failed", err));
            });
        }
        if (detectorElements.yoloDownload) {
            detectorElements.yoloDownload.addEventListener("click", () => {
                downloadDetectorRun("yolo").catch((err) => console.warn("Detector YOLO download failed", err));
            });
        }
        if (detectorElements.rfdetrDownload) {
            detectorElements.rfdetrDownload.addEventListener("click", () => {
                downloadDetectorRun("rfdetr").catch((err) => console.warn("Detector RF-DETR download failed", err));
            });
        }
        if (detectorElements.yoloDelete) {
            detectorElements.yoloDelete.addEventListener("click", () => {
                deleteDetectorRun("yolo").catch((err) => console.warn("Detector YOLO delete failed", err));
            });
        }
        if (detectorElements.rfdetrDelete) {
            detectorElements.rfdetrDelete.addEventListener("click", () => {
                deleteDetectorRun("rfdetr").catch((err) => console.warn("Detector RF-DETR delete failed", err));
            });
        }
        await loadYoloRunList(false);
        await loadRfDetrRunList(false);
    }

    function initHelpTooltips() {
        document.querySelectorAll(".help-icon[title]").forEach((el) => {
            const title = el.getAttribute("title");
            if (!title) return;
            el.dataset.tooltip = title;
            el.removeAttribute("title");
        });
    }

    function loadStoredApiRoot() {
        try {
            const saved = localStorage.getItem(API_STORAGE_KEY);
            const normalized = normalizeApiRoot(saved);
            return normalized || DEFAULT_API_ROOT;
        } catch (error) {
            console.debug("Failed to read stored API root", error);
            return DEFAULT_API_ROOT;
        }
    }

    async function refreshAgentCacheSize() {
        if (!agentElements.cacheSize) return;
        try {
            const resp = await fetch(`${API_ROOT}/agent_mining/cache_size`);
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            const bytes = Number(data?.bytes) || 0;
            agentElements.cacheSize.textContent = `Cache: ${formatBytesLabel(bytes)}`;
        } catch (err) {
            console.warn("Cache size check failed", err);
            agentElements.cacheSize.textContent = "Cache: n/a";
        }
    }

    async function purgeAgentCache() {
        if (!confirm("Purge agent mining detection cache? This frees disk space but will rerun detections next time.")) return;
        try {
            const resp = await fetch(`${API_ROOT}/agent_mining/cache/purge`, { method: "POST" });
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            const freedMb = ((Number(data?.deleted_bytes) || 0) / (1024 * 1024)).toFixed(1);
            setAgentStatus(`Cache purged (${freedMb} MB freed).`, "success");
            refreshAgentCacheSize();
        } catch (err) {
            console.error("Agent cache purge failed", err);
            setAgentStatus(`Cache purge failed: ${err.message || err}`, "error");
        }
    }

    async function refreshQwenSplitCache() {
        if (!qwenTrainElements.cacheInfo) return;
        try {
            const resp = await fetch(`${API_ROOT}/qwen/train/cache_size`);
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            const bytes = Number(data?.bytes) || 0;
            qwenTrainElements.cacheInfo.textContent = `Split cache: ${formatBytesLabel(bytes)}`;
        } catch (err) {
            console.warn("Qwen cache size check failed", err);
            qwenTrainElements.cacheInfo.textContent = "Split cache: n/a";
        }
    }

    async function purgeQwenSplitCache() {
        if (!confirm("Purge cached train/val splits for Qwen training?")) return;
        try {
            const resp = await fetch(`${API_ROOT}/qwen/train/cache/purge`, { method: "POST" });
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            const freedMb = formatBytesLabel(Number(data?.deleted_bytes) || 0);
            setQwenStatus(`Split cache purged (${freedMb}).`, "success");
            refreshQwenSplitCache();
        } catch (err) {
            console.error("Qwen cache purge failed", err);
            setQwenStatus(`Split cache purge failed: ${err.message || err}`, "error");
        }
    }

    async function refreshSam3SplitCache() {
        if (!sam3TrainElements.cacheInfo) return;
        try {
            const resp = await fetch(`${API_ROOT}/sam3/train/cache_size`);
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            const bytes = Number(data?.bytes) || 0;
            sam3TrainElements.cacheInfo.textContent = `Split cache: ${formatBytesLabel(bytes)}`;
        } catch (err) {
            console.warn("SAM3 cache size check failed", err);
            sam3TrainElements.cacheInfo.textContent = "Split cache: n/a";
        }
    }

    async function purgeSam3SplitCache() {
        if (!confirm("Purge cached train/val splits for SAM3 training?")) return;
        try {
            const resp = await fetch(`${API_ROOT}/sam3/train/cache/purge`, { method: "POST" });
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            const freed = formatBytesLabel(Number(data?.deleted_bytes) || 0);
            setSam3Status(`Split cache purged (${freed}).`, "success");
            refreshSam3SplitCache();
        } catch (err) {
            console.error("SAM3 cache purge failed", err);
            setSam3Status(`Split cache purge failed: ${err.message || err}`, "error");
        }
    }

    function normalizeApiRoot(value) {
        if (!value) {
            return null;
        }
        let trimmed = String(value).trim();
        if (!trimmed) {
            return null;
        }
        if (!/^https?:\/\//i.test(trimmed)) {
            trimmed = `http://${trimmed}`;
        }
        trimmed = trimmed.replace(/\/+$/, "");
        return trimmed;
    }

    let activeTab = TAB_LABELING;
    let trainingUiInitialized = false;
    let sam3TrainUiInitialized = false;
    let segBuilderUiInitialized = false;
    let activeUiInitialized = false;
    let loadedClassList = [];
    const INGEST_PHASE_LABELS = {
        images: "Loading images",
        bboxes: "Importing bboxes",
    };

    function ensureIngestElements() {
        if (!ingestProgressState.element) {
            ingestProgressState.element = document.getElementById("ingestProgress");
            ingestProgressState.labelEl = document.getElementById("ingestProgressLabel");
            ingestProgressState.detailEl = document.getElementById("ingestProgressDetail");
        }
    }

    function startIngestProgress({ phase, total = 0, extraLabel = null }) {
        ensureIngestElements();
        if (!ingestProgressState.element) {
            return;
        }
        ingestProgressState.phase = phase;
        ingestProgressState.total = Math.max(0, Number(total) || 0);
        ingestProgressState.completed = 0;
        ingestProgressState.extraLabel = extraLabel;
        ingestProgressState.extraValue = 0;
        ingestProgressState.visible = true;
        renderIngestProgress();
    }

    function renderIngestProgress() {
        ensureIngestElements();
        if (!ingestProgressState.element) {
            return;
        }
        if (!ingestProgressState.visible) {
            ingestProgressState.element.classList.remove("visible");
            return;
        }
        const label = INGEST_PHASE_LABELS[ingestProgressState.phase] || "Loading";
        const total = ingestProgressState.total;
        const completed = total ? Math.min(ingestProgressState.completed, total) : ingestProgressState.completed;
        let detail = total ? `${completed}/${total}` : `${completed}`;
        if (ingestProgressState.extraLabel) {
            detail += ` • ${ingestProgressState.extraLabel}: ${ingestProgressState.extraValue}`;
        }
        ingestProgressState.labelEl.textContent = label;
        ingestProgressState.detailEl.textContent = detail;
        ingestProgressState.element.classList.add("visible");
    }

    function incrementIngestProgress(delta = 1) {
        if (!ingestProgressState.visible) {
            return;
        }
        ingestProgressState.completed = Math.max(0, ingestProgressState.completed + delta);
        renderIngestProgress();
    }

    function adjustIngestTotal(delta) {
        if (!ingestProgressState.visible || !delta) {
            return;
        }
        ingestProgressState.total = Math.max(0, ingestProgressState.total + delta);
        renderIngestProgress();
    }

    function incrementIngestExtra(delta = 1) {
        if (!ingestProgressState.visible || !ingestProgressState.extraLabel) {
            return;
        }
        ingestProgressState.extraValue = Math.max(0, ingestProgressState.extraValue + delta);
        renderIngestProgress();
    }

    function stopIngestProgress() {
        ensureIngestElements();
        if (!ingestProgressState.element) {
            return;
        }
        ingestProgressState.visible = false;
        ingestProgressState.phase = null;
        ingestProgressState.total = 0;
        ingestProgressState.completed = 0;
        ingestProgressState.extraValue = 0;
        ingestProgressState.element.classList.remove("visible");
    }

    function noteImportedBbox(count = 1) {
        if (!bboxImportCounterActive) {
            return;
        }
        incrementIngestExtra(count);
    }

    function ensureBackgroundLoadElements() {
        if (backgroundLoadModal.element) {
            return;
        }
        backgroundLoadModal.element = document.getElementById("backgroundLoadModal");
        backgroundLoadModal.dismissBtn = document.getElementById("backgroundLoadDismiss");
        if (backgroundLoadModal.dismissBtn) {
            backgroundLoadModal.dismissBtn.addEventListener("click", () => hideBackgroundLoadModal());
        }
        const backdrop = backgroundLoadModal.element?.querySelector(".modal__backdrop");
        if (backdrop) {
            backdrop.addEventListener("click", () => hideBackgroundLoadModal());
        }
    }

    function showBackgroundLoadModal(message = null) {
        ensureBackgroundLoadElements();
        if (!backgroundLoadModal.element) {
            return;
        }
        const msgEl = document.getElementById("backgroundLoadMessage");
        if (msgEl && message) {
            msgEl.textContent = message;
        }
        backgroundLoadModal.visible = true;
        backgroundLoadModal.element.classList.add("visible");
        backgroundLoadModal.element.setAttribute("aria-hidden", "false");
    }

    function hideBackgroundLoadModal() {
        if (!backgroundLoadModal.element) {
            return;
        }
        backgroundLoadModal.visible = false;
        backgroundLoadModal.element.classList.remove("visible");
        backgroundLoadModal.element.setAttribute("aria-hidden", "true");
    }

    function ensureTrainingPackagingElements() {
        if (trainingPackagingModal.element) {
            return;
        }
        trainingPackagingModal.element = document.getElementById("trainingPackagingModal");
        trainingPackagingModal.summaryEl = document.getElementById("trainingPackagingStats");
        trainingPackagingModal.etaEl = document.getElementById("trainingPackagingEta");
        trainingPackagingModal.elapsedEl = document.getElementById("trainingPackagingElapsed");
        trainingPackagingModal.hintEl = document.getElementById("trainingPackagingHint");
        trainingPackagingModal.progressLabel = document.getElementById("trainingPackagingProgressText");
        trainingPackagingModal.progressFill = document.getElementById("trainingPackagingProgressFill");
        trainingPackagingModal.dismissBtn = document.getElementById("trainingPackagingDismiss");
        if (trainingPackagingModal.dismissBtn) {
            trainingPackagingModal.dismissBtn.addEventListener("click", () => hideTrainingPackagingModal());
        }
        const backdrop = trainingPackagingModal.element?.querySelector(".modal__backdrop");
        if (backdrop) {
            backdrop.addEventListener("click", () => hideTrainingPackagingModal());
        }
    }

    function showTrainingPackagingModal(stats, options = {}) {
        ensureTrainingPackagingElements();
        if (!trainingPackagingModal.element) {
            return;
        }
        if (trainingPackagingModal.timerId) {
            clearInterval(trainingPackagingModal.timerId);
            trainingPackagingModal.timerId = null;
        }
        const {
            hintText = null,
            progressText = "Preparing files…",
            indeterminate = true,
        summaryText = null,
        } = options;
        const imageSummary = stats
            ? `${stats.imageCount} image${stats.imageCount === 1 ? "" : "s"} (${formatBytes(stats.imageBytes)})`
            : "";
        const labelSummary = stats
            ? `${stats.labelCount} label file${stats.labelCount === 1 ? "" : "s"} (${formatBytes(stats.labelBytes)})`
            : "";
        const totalSummary = stats ? `${stats.totalFiles} files ≈ ${formatBytes(stats.totalBytes)}` : null;
        if (trainingPackagingModal.summaryEl) {
            if (summaryText) {
                trainingPackagingModal.summaryEl.textContent = summaryText;
            } else if (stats) {
                trainingPackagingModal.summaryEl.textContent = `${imageSummary} + ${labelSummary} (${totalSummary})`;
            } else {
                trainingPackagingModal.summaryEl.textContent = "Packaging dataset…";
            }
        }
        if (trainingPackagingModal.etaEl) {
            if (stats && Number.isFinite(stats.estimatedSeconds) && stats.estimatedSeconds > 0) {
                trainingPackagingModal.etaEl.textContent = `Estimated upload: ${formatDurationPrecise(stats.estimatedSeconds)} (${describeDurationRange(stats.estimatedSeconds)})`;
            } else {
                trainingPackagingModal.etaEl.textContent = "Estimating upload time…";
            }
        }
        if (trainingPackagingModal.progressLabel) {
            trainingPackagingModal.progressLabel.textContent = progressText;
        }
        if (trainingPackagingModal.progressFill) {
            trainingPackagingModal.progressFill.style.width = indeterminate ? "200%" : "0%";
            trainingPackagingModal.progressFill.classList.toggle("is-indeterminate", indeterminate);
        }
        trainingPackagingModal.indeterminate = indeterminate;
        if (trainingPackagingModal.elapsedEl) {
            trainingPackagingModal.elapsedEl.textContent = "Elapsed: 0s";
        }
        if (trainingPackagingModal.hintEl && hintText) {
            trainingPackagingModal.hintEl.textContent = hintText;
        } else if (trainingPackagingModal.hintEl && !hintText) {
            trainingPackagingModal.hintEl.textContent = "Keep this tab open while we stage files and upload them to the server. Larger datasets can take a few minutes.";
        }
        trainingPackagingModal.startedAt = performance.now();
        trainingPackagingModal.visible = true;
        trainingPackagingModal.element.classList.add("visible");
        trainingPackagingModal.element.setAttribute("aria-hidden", "false");
        trainingPackagingModal.timerId = window.setInterval(() => {
            updateTrainingPackagingElapsed();
        }, 500);
    }

    function updateTrainingPackagingElapsed() {
        if (!trainingPackagingModal.visible || !trainingPackagingModal.elapsedEl) {
            return;
        }
        const elapsedSeconds = Math.max(0, (performance.now() - trainingPackagingModal.startedAt) / 1000);
        trainingPackagingModal.elapsedEl.textContent = `Elapsed: ${formatDurationPrecise(elapsedSeconds)}`;
    }

    function updateTrainingPackagingProgress(percent, text) {
        ensureTrainingPackagingElements();
        if (!trainingPackagingModal.visible) {
            return;
        }
        if (typeof percent === "number" && trainingPackagingModal.progressFill) {
            const clamped = Math.max(0, Math.min(100, percent));
            trainingPackagingModal.progressFill.classList.remove("is-indeterminate");
            trainingPackagingModal.progressFill.style.width = `${clamped}%`;
            trainingPackagingModal.indeterminate = false;
        }
        if (text && trainingPackagingModal.progressLabel) {
            trainingPackagingModal.progressLabel.textContent = text;
        }
    }

    function hideTrainingPackagingModal() {
        if (!trainingPackagingModal.element) {
            return;
        }
        trainingPackagingModal.visible = false;
        trainingPackagingModal.element.classList.remove("visible");
        trainingPackagingModal.element.setAttribute("aria-hidden", "true");
        if (trainingPackagingModal.timerId) {
            clearInterval(trainingPackagingModal.timerId);
            trainingPackagingModal.timerId = null;
        }
        if (trainingPackagingModal.progressFill) {
            trainingPackagingModal.progressFill.classList.add("is-indeterminate");
            trainingPackagingModal.progressFill.style.width = "200%";
        }
        if (trainingPackagingModal.progressLabel) {
            trainingPackagingModal.progressLabel.textContent = "Preparing…";
        }
    }

    function ensureTaskQueueElement() {
        if (!taskQueueState.element) {
            taskQueueState.element = document.getElementById("taskQueue");
        }
        if (taskQueueState.element && taskQueueState.element.parentElement?.id !== "right") {
            const host = document.getElementById("right");
            if (host) {
                host.appendChild(taskQueueState.element);
            }
        }
        return taskQueueState.element;
    }

    function ensureClassScrollIndicatorElement() {
        if (!classScrollIndicatorState.element) {
            classScrollIndicatorState.element = document.getElementById("classScrollIndicator");
        }
        return classScrollIndicatorState.element;
    }

    function hideClassScrollIndicator() {
        const el = ensureClassScrollIndicatorElement();
        if (!el) {
            return;
        }
        if (classScrollIndicatorState.timerId) {
            clearTimeout(classScrollIndicatorState.timerId);
            classScrollIndicatorState.timerId = null;
        }
        el.classList.remove("visible");
    }

    function showClassScrollIndicator({ previousClass, currentClassName, nextClass }, { duration = 900 } = {}) {
        const el = ensureClassScrollIndicatorElement();
        if (!el) {
            return;
        }
        const currentLabel = String(currentClassName || "").trim();
        if (!currentLabel) {
            return;
        }
        const prevLabel = String(previousClass || currentLabel).trim() || currentLabel;
        const nextLabel = String(nextClass || currentLabel).trim() || currentLabel;
        el.innerHTML = [
            `<div class="class-scroll-indicator__bubble class-scroll-indicator__bubble--adjacent" title="Previous class">${escapeHtml(prevLabel)}</div>`,
            `<div class="class-scroll-indicator__bubble class-scroll-indicator__bubble--current" title="Current class">${escapeHtml(currentLabel)}</div>`,
            `<div class="class-scroll-indicator__bubble class-scroll-indicator__bubble--adjacent" title="Next class">${escapeHtml(nextLabel)}</div>`,
        ].join("");
        el.classList.add("visible");
        if (classScrollIndicatorState.timerId) {
            clearTimeout(classScrollIndicatorState.timerId);
        }
        const timeoutMs = typeof duration === "number" && Number.isFinite(duration) ? duration : 900;
        classScrollIndicatorState.timerId = window.setTimeout(() => {
            classScrollIndicatorState.timerId = null;
            hideClassScrollIndicator();
        }, Math.max(250, timeoutMs));
    }

    function getClassListOptionName(option) {
        if (!option) {
            return null;
        }
        return option.text || option.textContent || option.innerHTML || null;
    }

    function showClassScrollIndicatorForList(classListEl, currentIndex) {
        if (!classListEl || !classListEl.options || !classListEl.options.length) {
            return;
        }
        const total = classListEl.options.length;
        const idx = typeof currentIndex === "number" && Number.isFinite(currentIndex) ? currentIndex : classListEl.selectedIndex;
        const safeIndex = Math.min(Math.max(0, idx), total - 1);
        const currentName = getClassListOptionName(classListEl.options[safeIndex]);
        if (!currentName) {
            return;
        }
        if (total === 1) {
            showClassScrollIndicator({ previousClass: currentName, currentClassName: currentName, nextClass: currentName });
            return;
        }
        const prevIndex = (safeIndex - 1 + total) % total;
        const nextIndex = (safeIndex + 1) % total;
        const prevName = getClassListOptionName(classListEl.options[prevIndex]) || currentName;
        const nextName = getClassListOptionName(classListEl.options[nextIndex]) || currentName;
        showClassScrollIndicator({ previousClass: prevName, currentClassName: currentName, nextClass: nextName });
    }

    function enqueueTask({ kind, imageName, detail }) {
        const container = ensureTaskQueueElement();
        if (!container) {
            return null;
        }
        const group = TASK_GROUP_MAP[kind] || kind || "misc";
        const entry = {
            id: ++taskQueueState.counter,
            kind: kind || "sam",
            group,
            imageName: imageName || null,
            detail: detail || null,
            timestamp: Date.now(),
        };
        taskQueueState.items.push(entry);
        renderTaskQueue();
        return entry.id;
    }

    function enqueueTaskNotice(message, { durationMs = 3500 } = {}) {
        const container = ensureTaskQueueElement();
        if (!container) {
            return null;
        }
        const lingerMs = Math.max(1500, Number(durationMs) || 3500) * 2;
        const entry = {
            id: ++taskQueueState.counter,
            message: String(message || "").trim() || "Notice",
            expiresAt: Date.now() + lingerMs,
        };
        taskQueueState.notices.push(entry);
        renderTaskQueue();
        window.setTimeout(() => {
            const idx = taskQueueState.notices.findIndex((item) => item.id === entry.id);
            if (idx !== -1) {
                taskQueueState.notices.splice(idx, 1);
                renderTaskQueue();
            }
        }, lingerMs);
        return entry.id;
    }

    function completeTask(taskId) {
        if (!taskId) {
            return;
        }
        const idx = taskQueueState.items.findIndex((item) => item.id === taskId);
        if (idx !== -1) {
            taskQueueState.items.splice(idx, 1);
            renderTaskQueue();
        }
    }

    function clearTaskQueue(predicate, { statusMessage = null } = {}) {
        if (!taskQueueState.items.length) {
            return;
        }
        if (typeof predicate !== "function") {
            taskQueueState.items = [];
        } else {
            taskQueueState.items = taskQueueState.items.filter((item) => !predicate(item));
        }
        if (statusMessage) {
            setSamStatus(statusMessage, { variant: "warn", duration: 4000 });
        }
        renderTaskQueue();
    }

	    function renderTaskQueue() {
	        const container = ensureTaskQueueElement();
	        if (!container) {
	            return;
	        }
	        const now = Date.now();
	        if (taskQueueState.notices.length) {
	            taskQueueState.notices = taskQueueState.notices.filter((item) => item.expiresAt > now);
	        }
	        const hasItems = taskQueueState.items.length > 0;
	        const hasNotices = taskQueueState.notices.length > 0;
	        if (!hasItems && !hasNotices) {
	            container.innerHTML = "";
	            container.classList.remove("visible");
	            return;
	        }
	        const fragments = [];
	        if (hasNotices) {
	            taskQueueState.notices.forEach((notice) => {
	                fragments.push(
	                    `<div class="task-queue__entry task-queue__entry--notice"><span class="task-queue__label">${escapeHtml(notice.message)}</span></div>`
	                );
	            });
	        }
	        const summary = new Map();
	        taskQueueState.items.forEach((item) => {
	            const group = item.group || item.kind || "misc";
	            const meta = summary.get(group) || { count: 0, recipeSteps: 0 };
	            meta.count += 1;
	            if (group === "recipe-cascade") {
	                let steps = 0;
	                const raw = item.detail;
	                if (typeof raw === "number" && Number.isFinite(raw)) {
	                    steps = Math.trunc(raw);
	                } else if (typeof raw === "string" && raw.trim()) {
	                    const parsed = parseInt(raw, 10);
	                    steps = Number.isFinite(parsed) ? parsed : 0;
	                } else if (raw && typeof raw === "object") {
	                    const parsed = parseInt(raw.steps ?? raw.step_count ?? raw.stepCount ?? "0", 10);
	                    steps = Number.isFinite(parsed) ? parsed : 0;
	                }
	                if (steps > 0) {
	                    meta.recipeSteps += steps;
	                }
	            }
	            summary.set(group, meta);
	        });
	        const taskFragments = Array.from(summary.entries()).map(([group, meta]) => {
	            const label = (TASK_GROUP_LABELS[group] || group).toLowerCase();
	            const noun = meta.count === 1 ? "task" : "tasks";
	            const extra =
	                group === "recipe-cascade" && meta.recipeSteps
	                    ? ` • ${meta.recipeSteps} recipe step${meta.recipeSteps === 1 ? "" : "s"}`
	                    : "";
	            return `<div class="task-queue__entry"><span class="task-queue__label">${meta.count} ${label} ${noun} pending${extra}</span></div>`;
	        });
	        container.innerHTML = fragments.concat(taskFragments).join("");
	        container.classList.add("visible");
	    }

    function shortenName(name) {
        if (!name) {
            return "—";
        }
        return name.length > 10 ? `${name.slice(0, 10)}…` : name;
    }

    function ensureBatchTweakElements() {
        if (!batchTweakElements.modal) {
            batchTweakElements.modal = document.getElementById("batchTweakModal");
            batchTweakElements.backdrop = batchTweakElements.modal?.querySelector(".modal__backdrop");
            batchTweakElements.confirm = document.getElementById("batchTweakConfirm");
            batchTweakElements.cancel = document.getElementById("batchTweakCancel");
            batchTweakElements.classLabel = document.getElementById("batchTweakClass");
            if (batchTweakElements.confirm) {
                batchTweakElements.confirm.addEventListener("click", () => {
                    closeBatchTweakModal();
                    runBatchTweakForCurrentCategory().catch((err) => {
                        console.error("Batch tweak failed", err);
                        setSamStatus(`Batch tweak failed: ${err.message || err}`, { variant: "error", duration: 5000 });
                    });
                });
            }
            if (batchTweakElements.cancel) {
                batchTweakElements.cancel.addEventListener("click", () => {
                    closeBatchTweakModal();
                });
            }
            if (batchTweakElements.backdrop) {
                batchTweakElements.backdrop.addEventListener("click", () => closeBatchTweakModal());
            }
            document.addEventListener("keydown", (event) => {
                if (event.key === "Escape" && batchTweakElements.modal?.classList.contains("visible")) {
                    closeBatchTweakModal();
                }
            });
        }
    }

    function openBatchTweakModal() {
        ensureBatchTweakElements();
        if (!batchTweakElements.modal) {
            return;
        }
        if (!currentClass) {
            setSamStatus("Select a class in the list before batch tweaking", { variant: "warn", duration: 3000 });
            return;
        }
        if (batchTweakRunning) {
            setSamStatus("Batch tweak already running", { variant: "info", duration: 2500 });
            return;
        }
        if (!currentImage || !currentImage.name || !currentClass) {
            setSamStatus("Choose an image and class before batch tweaking", { variant: "warn", duration: 3000 });
            return;
        }
        const bucket = bboxes[currentImage.name]?.[currentClass] || [];
        if (!bucket.length) {
            setSamStatus("No bboxes available for this class", { variant: "warn", duration: 3000 });
            return;
        }
        if (!samMode) {
            setSamStatus("Enable SAM mode to batch tweak", { variant: "warn", duration: 3000 });
            return;
        }
        if (batchTweakElements.classLabel) {
            batchTweakElements.classLabel.textContent = `${currentClass} (${bucket.length})`;
        }
        batchTweakElements.modal.classList.add("visible");
        batchTweakElements.modal.setAttribute("aria-hidden", "false");
    }

    function closeBatchTweakModal() {
        if (!batchTweakElements.modal) {
            return;
        }
        batchTweakElements.modal.classList.remove("visible");
        batchTweakElements.modal.setAttribute("aria-hidden", "true");
    }

    function requestBatchTweakModal() {
        if (!currentClass) {
            setSamStatus("Select a class in the list before batch tweaking", { variant: "warn", duration: 3000 });
            return;
        }
        openBatchTweakModal();
    }

    function handleXHotkeyPress() {
        if (xHotkeyTimeoutId) {
            clearTimeout(xHotkeyTimeoutId);
            xHotkeyTimeoutId = null;
            requestBatchTweakModal();
            return;
        }
        xHotkeyTimeoutId = window.setTimeout(() => {
            xHotkeyTimeoutId = null;
            handleMagicTweakHotkey().catch((err) => {
                console.debug("Magic tweak hotkey failed", err);
            });
        }, DOUBLE_TAP_WINDOW_MS);
    }

    const ingestProgressState = {
        element: null,
        labelEl: null,
        detailEl: null,
        phase: null,
        total: 0,
        completed: 0,
        extraLabel: null,
        extraValue: 0,
        visible: false,
    };
    let bboxImportCounterActive = false;
    const DOUBLE_TAP_WINDOW_MS = 260;
    let xHotkeyTimeoutId = null;
    let batchTweakRunning = false;
    const batchTweakElements = {
        modal: null,
        backdrop: null,
        confirm: null,
        cancel: null,
        classLabel: null,
    };
    const backgroundLoadModal = {
        element: null,
        dismissBtn: null,
        visible: false,
        decimalsTotal: 0,
        decimalsDone: 0,
    };
    const trainingPackagingModal = {
        element: null,
        summaryEl: null,
        etaEl: null,
        elapsedEl: null,
        hintEl: null,
        progressLabel: null,
        progressFill: null,
        dismissBtn: null,
        visible: false,
        startedAt: 0,
        timerId: null,
        indeterminate: true,
    };
    const taskQueueState = {
        element: null,
        items: [],
        notices: [],
        counter: 0,
    };
    const classScrollIndicatorState = {
        element: null,
        timerId: null,
    };
    const TASK_GROUP_MAP = {
        "sam-bbox": "bbox",
        "sam-bbox-auto": "bbox",
        "sam-point": "bbox",
        "sam-point-auto": "bbox",
        "sam-multipoint": "bbox",
        "sam-multipoint-auto": "bbox",
        "sam-batch": "bbox",
        "sam-preload": "preload",
        "sam-activate": "preload",
        sam: "bbox",
        "sam-similarity": "sam3",
        "sam3-batch": "sam3",
        "sam3-cascade": "sam3",
        "clip-auto": "clip",
        "recipe-apply": "recipe",
        "recipe-cascade": "recipe-cascade",
    };

    const TASK_GROUP_LABELS = {
        preload: "SAM preloads",
        bbox: "bbox adjustments",
        sam3: "SAM3 tasks",
        clip: "CLIP tasks",
        recipe: "recipe",
        "recipe-cascade": "recipe cascade",
    };

    const tabElements = {
        labelingButton: null,
        trainingButton: null,
        qwenTrainButton: null,
        sam3TrainButton: null,
        yoloTrainButton: null,
        rfdetrTrainButton: null,
        agentMiningButton: null,
        promptHelperButton: null,
        sam3PromptModelsButton: null,
        detectorsButton: null,
        datasetsButton: null,
        activeButton: null,
        qwenButton: null,
        predictorsButton: null,
        settingsButton: null,
        labelingPanel: null,
        trainingPanel: null,
        qwenTrainPanel: null,
        sam3TrainPanel: null,
        yoloTrainPanel: null,
        rfdetrTrainPanel: null,
        agentMiningPanel: null,
        promptHelperPanel: null,
        sam3PromptModelsPanel: null,
        detectorsPanel: null,
        datasetsPanel: null,
        activePanel: null,
        qwenPanel: null,
        predictorsPanel: null,
        settingsPanel: null,
    };

    const detectorElements = {
        defaultSelect: null,
        defaultSave: null,
        defaultRefresh: null,
        status: null,
        message: null,
        yoloSelect: null,
        yoloRefresh: null,
        yoloActivate: null,
        yoloDownload: null,
        yoloDelete: null,
        yoloSummary: null,
        yoloMetrics: null,
        yoloLabelmap: null,
        yoloMessage: null,
        rfdetrSelect: null,
        rfdetrRefresh: null,
        rfdetrActivate: null,
        rfdetrDownload: null,
        rfdetrDelete: null,
        rfdetrSummary: null,
        rfdetrMetrics: null,
        rfdetrLabelmap: null,
        rfdetrMessage: null,
    };
    const detectorState = {
        mode: "rfdetr",
        yoloActive: null,
        rfdetrActive: null,
        prompted: {
            yolo: false,
            rfdetr: false,
        },
    };
    const detectorRunSummaryCache = {
        yolo: new Map(),
        rfdetr: new Map(),
    };


    const predictorElements = {
        countInput: null,
        applyButton: null,
        message: null,
        activeCount: null,
        loadedCount: null,
        processRam: null,
        imageRam: null,
        systemFreeRam: null,
    };

    const settingsElements = {
        apiInput: null,
        applyButton: null,
        testButton: null,
        status: null,
    };

    const qwenSettingsElements = {
        trustRemoteCode: null,
        applyButton: null,
        status: null,
    };

    const qwenElements = {
        statusLabel: null,
        itemsInput: null,
        manualPrompt: null,
        imageTypeInput: null,
        extraContextInput: null,
        advancedToggle: null,
        advancedPanel: null,
        promptType: null,
        classSelect: null,
        maxResults: null,
        runButton: null,
        captionHint: null,
        captionPreset: null,
        captionPresetApply: null,
        captionPresetRandom: null,
        captionStyleList: null,
        captionStyleInspiration: null,
        captionVaryOpening: null,
        captionModel: null,
        captionVariant: null,
        captionMaxTokens: null,
        captionMaxBoxes: null,
        captionIncludeCounts: null,
        captionIncludeCoords: null,
        captionFinalOnly: null,
        captionTwoStage: null,
        captionHighVram: null,
        captionSaveText: null,
        captionRunButton: null,
        captionOutput: null,
        captionCopyButton: null,
        captionMeta: null,
        captionStatus: null,
        captionBatchCount: null,
        captionBatchIncludeCurrent: null,
        captionBatchOverwrite: null,
        captionBatchRun: null,
        captionBatchRunAll: null,
        captionBatchCancel: null,
        captionDownloadJsonl: null,
        unloadOthers: null,
    };
    const sam3TextElements = {
        panel: null,
        promptInput: null,
        thresholdInput: null,
        maskThresholdInput: null,
        maxResultsInput: null,
        runButton: null,
        cascadeToggleButton: null,
        cascadePanel: null,
        cascadeSteps: null,
        cascadeAddButton: null,
        cascadeRunButton: null,
        cascadeStopButton: null,
        cascadeClearButton: null,
        batchCountInput: null,
        batchIncludeCurrentToggle: null,
        batchRunButton: null,
        batchStopButton: null,
        similarityButton: null,
        similarityRow: null,
        similarityThresholdInput: null,
        status: null,
        classSelect: null,
        minSizeInput: null,
        maxPointsInput: null,
        epsilonInput: null,
    };
    const sam3RecipeElements = {
        fileInput: null,
        status: null,
        recipeRefreshButton: null,
        cascadeSteps: null,
        cascadeAddStepButton: null,
        perClassIouInput: null,
        crossDedupeToggle: null,
        crossScopeSelect: null,
        crossIouInput: null,
        confidenceSelect: null,
        clipHeadSourceSelect: null,
        cascadePresetSelect: null,
        cascadePresetNameInput: null,
        cascadePresetRefreshButton: null,
        cascadePresetSaveButton: null,
        cascadePresetLoadButton: null,
        cascadePresetDeleteButton: null,
        cascadePresetExportButton: null,
        cascadeFileInput: null,
        cascadeApplyButton: null,
    };
    const sam3RecipeState = {
        recipe: null,
    };
    const sam3CascadeState = {
        steps: [],
        recipePresets: [],
        cascadePresets: [],
        clipClassifiers: [],
    };
    const DEFAULT_QWEN_METADATA = {
        id: "default",
        label: "Base Qwen 3",
        dataset_context: "",
        classes: [],
        system_prompt: "",
    };

    const qwenModelElements = {
        status: null,
        list: null,
        details: null,
        refreshButton: null,
    };
    let qwenAvailable = false;
    let qwenRequestActive = false;
    let qwenCaptionActive = false;
    let sam3TextRequestActive = false;
    let sam3SimilarityRequestActive = false;
    let sam3TextBatchActive = false;
    let sam3TextBatchCancel = false;
    let sam3TextCascadeActive = false;
    let sam3TextCascadeCancel = false;
    let sam3TextCascadeEnabled = false;
    let qwenClassOverride = false;
    let qwenAdvancedVisible = false;
    const qwenModelState = {
        models: [],
        activeId: "default",
        activeMetadata: DEFAULT_QWEN_METADATA,
    };
    const CAPTION_PRESETS = [
        { id: "concise", label: "Concise scene caption", text: "Write a short caption (1-2 sentences) describing the scene and main objects." },
        { id: "context", label: "Context + setting", text: "Describe the scene, setting, and activity in one concise paragraph." },
        { id: "objects", label: "Objects only", text: "List the key objects and their relationships in one sentence." },
        { id: "aerial", label: "Aerial / drone view", text: "Caption the image as aerial/drone footage, noting roads, vehicles, and structures." },
        { id: "safety", label: "Safety / inspection", text: "Write a safety/inspection style caption focusing on equipment and hazards." },
        { id: "custom", label: "Custom (hint only)", text: "" },
    ];
    const DEFAULT_CAPTION_STYLE_LINES = [
        "A close-up photograph",
        "A wide establishing shot",
        "An overhead view",
        "A street-level documentary shot",
        "A candid scene",
    ];
    const DEFAULT_CAPTION_OPENERS = [
        "The scene shows",
        "The image shows",
        "In this scene",
        "From a high angle",
        "Looking down",
        "A top-down view shows",
        "A wide shot shows",
    ];
    const DEFAULT_CAPTION_WINDOW_SIZE = 672;
    const DEFAULT_CAPTION_WINDOW_OVERLAP = 0.2;
    let sam3TextUiInitialized = false;
    let textLabels = {};
    let textLabelRecords = [];
    let qwenCaptionBatchActive = false;
    let qwenCaptionBatchCancel = false;

    let settingsUiInitialized = false;
    const backendFuzzerElements = {
        runButton: null,
        status: null,
        log: null,
        includeQwen: null,
        includeSam3: null,
        includeClip: null,
        includeAgent: null,
    };

    const trainingElements = {
        encoderTypeSelect: null,
        clipBackboneSelect: null,
        dinov3BackboneSelect: null,
        clipBackboneRow: null,
        dinov3BackboneRow: null,
        solverSelect: null,
        classifierTypeSelect: null,
        imagesInput: null,
        imagesBtn: null,
        imagesSummary: null,
        labelsInput: null,
        labelsBtn: null,
        labelsSummary: null,
        labelmapInput: null,
        labelmapSummary: null,
        outputDirBtn: null,
        outputDirSummary: null,
        modelFilenameInput: null,
        labelmapFilenameInput: null,
        testSizeInput: null,
        randomSeedInput: null,
        batchSizeInput: null,
        maxIterInput: null,
        minPerClassInput: null,
        regCInput: null,
        mlpHiddenSizesInput: null,
        mlpHiddenSizesAutoBtn: null,
        mlpDropoutInput: null,
        mlpEpochsInput: null,
        mlpLrInput: null,
        mlpWeightDecayInput: null,
        mlpLabelSmoothingInput: null,
        mlpLossTypeSelect: null,
        mlpActivationSelect: null,
        mlpFocalGammaInput: null,
        mlpFocalAlphaInput: null,
        mlpSamplerSelect: null,
        mlpMixupAlphaInput: null,
        mlpNormalizeEmbeddingsCheckbox: null,
        mlpPatienceInput: null,
        mlpLayerNormCheckbox: null,
        mlpHardMiningEpochsInput: null,
        classWeightSelect: null,
        effectiveBetaInput: null,
        logitAdjustmentToggle: null,
        deviceOverrideInput: null,
        calibrationModeSelect: null,
        embeddingCenterCheckbox: null,
        embeddingStandardizeCheckbox: null,
        bgClassCountInput: null,
        startButton: null,
        cancelButton: null,
        progressFill: null,
        statusText: null,
        message: null,
        summary: null,
        log: null,
        metricCanvas: null,
        chartStatus: null,
        historyContainer: null,
        reuseEmbeddingsCheckbox: null,
        hardMiningCheckbox: null,
        uploadCurrentDatasetBtn: null,
        openDatasetManagerBtn: null,
    };

	const qwenTrainElements = {
	        runNameInput: null,
	        modelSizeSelect: null,
	        modelVariantSelect: null,
        modelIdPreview: null,
        vramEstimate: null,
        vramBreakdown: null,
		systemPromptInput: null,
        trainModeRadios: null,
        batchSizeInput: null,
        epochsInput: null,
        lrInput: null,
        accumulateInput: null,
        loraRankInput: null,
        loraAlphaInput: null,
        loraDropoutInput: null,
        loraTargetsInput: null,
        logStepsInput: null,
        minPixelsInput: null,
        maxPixelsInput: null,
        maxLengthInput: null,
	        datasetSelect: null,
	        datasetRefresh: null,
	        datasetSummary: null,
	        sampleButton: null,
        sampleCanvas: null,
        samplePrompt: null,
        sampleExpected: null,
        sampleMessage: null,
        sampleMeta: null,
        startButton: null,
        cancelButton: null,
        progressFill: null,
        statusText: null,
        epochDetail: null,
        message: null,
        summary: null,
        log: null,
        historyContainer: null,
        lossCanvas: null,
        chartStatus: null,
        chartSmoothing: null,
        randomSplit: null,
        valPercent: null,
        splitSeed: null,
        cacheInfo: null,
        cachePurge: null,
    };

    const yoloTrainElements = {
        datasetSelect: null,
        datasetRefresh: null,
        datasetSummary: null,
        runNameInput: null,
        taskSelect: null,
        headTypeSelect: null,
        scaleSelect: null,
        variantResolved: null,
        variantHelp: null,
        fromScratchToggle: null,
        baseWeightsInput: null,
        epochsInput: null,
        imgSizeInput: null,
        batchInput: null,
        workersInput: null,
        devicesInput: null,
        seedInput: null,
        augFlipLR: null,
        augFlipUD: null,
        augHsvH: null,
        augHsvS: null,
        augHsvV: null,
        augMosaic: null,
        augMixup: null,
        augCopyPaste: null,
        augScale: null,
        augTranslate: null,
        augDegrees: null,
        acceptTos: null,
        startButton: null,
        cancelButton: null,
        refreshButton: null,
        progressFill: null,
        statusText: null,
        message: null,
        metricCanvas: null,
        chartStatus: null,
        log: null,
        history: null,
        runSelect: null,
        runRefresh: null,
        runActivate: null,
        runDownload: null,
        runDelete: null,
        runSummary: null,
    };

    const rfdetrTrainElements = {
        datasetSelect: null,
        datasetRefresh: null,
        datasetSummary: null,
        runNameInput: null,
        taskSelect: null,
        variantSelect: null,
        variantHelp: null,
        resolutionInput: null,
        multiScaleToggle: null,
        expandedScalesToggle: null,
        fromScratchToggle: null,
        pretrainInput: null,
        useEmaToggle: null,
        earlyStopToggle: null,
        earlyStopPatienceInput: null,
        epochsInput: null,
        batchInput: null,
        gradAccumInput: null,
        workersInput: null,
        devicesInput: null,
        seedInput: null,
        augHsvH: null,
        augHsvS: null,
        augHsvV: null,
        augBlurProb: null,
        augBlurKernel: null,
        augGrayProb: null,
        acceptTos: null,
        startButton: null,
        cancelButton: null,
        refreshButton: null,
        progressFill: null,
        statusText: null,
        message: null,
        metricCanvas: null,
        chartStatus: null,
        log: null,
        history: null,
        runSelect: null,
        runRefresh: null,
        runActivate: null,
        runDownload: null,
        runDelete: null,
        runSummary: null,
    };

    const activeElements = {
        message: null,
        info: null,
        clipSelect: null,
        classifierPath: null,
        classifierUpload: null,
        classifierBrowse: null,
        classifierSelect: null,
        classifierRefresh: null,
        classifierUse: null,
        classifierDownload: null,
        classifierDelete: null,
        labelmapPath: null,
        labelmapUpload: null,
        labelmapBrowse: null,
        labelmapSelect: null,
        labelmapRefresh: null,
        labelmapUse: null,
        labelmapDownload: null,
        labelmapDelete: null,
        activateLatestButton: null,
        applyButton: null,
        refreshButton: null,
    };

    const activeState = {
        classifiers: [],
        labelmaps: [],
    };

    const trainingState = {
        activeJobId: null,
        pollHandle: null,
        jobs: new Map(),
        latestArtifacts: null,
        lastRefreshJobId: null,
        outputDirPath: ".",
        imagesFolderName: null,
        labelsFolderName: null,
        imageEntries: [],
        labelEntries: [],
        imageTotalCount: 0,
        labelTotalCount: 0,
        nativeImagesPath: null,
        nativeLabelsPath: null,
        nativeLabelmapPath: null,
    };
    const clipDatasetState = { items: [] };

const qwenTrainState = {
    activeJobId: null,
    pollHandle: null,
    chartSmoothing: 15,
    lastJobSnapshot: null,
    gpuTotalMb: null,
    trainModeTouched: false,
};

const YOLO_TOS_STORAGE_KEY = "yoloTrainingTosAccepted";
const RFDETR_TOS_STORAGE_KEY = "rfdetrTrainingTosAccepted";

    const yoloTrainState = {
        activeJobId: null,
        pollHandle: null,
        lastJobSnapshot: null,
        variants: [],
        lastHeadType: "standard",
        autoScratchForced: false,
    };

    const rfdetrTrainState = {
        activeJobId: null,
        pollHandle: null,
        lastJobSnapshot: null,
        variants: [],
    };

    const qwenDatasetState = {
        items: [],
        selectedId: null,
    };

    const yoloDatasetState = {
        items: [],
        selectedId: null,
    };

    const rfdetrDatasetState = {
        items: [],
        selectedId: null,
    };

    const yoloRunState = {
        items: [],
        selectedId: null,
        activeId: null,
    };

    const rfdetrRunState = {
        items: [],
        selectedId: null,
        activeId: null,
    };

    const sam3TrainElements = {
        datasetSelect: null,
        datasetSummary: null,
        datasetRefresh: null,
        datasetConvert: null,
        runName: null,
        trainBatch: null,
        valBatch: null,
        trainWorkers: null,
        valWorkers: null,
        epochs: null,
        resolution: null,
        lrScale: null,
        gradAccum: null,
        valFreq: null,
        targetEpochSize: null,
        warmupSteps: null,
        schedulerTimescale: null,
        balanceStrategy: null,
        balancePower: null,
        balanceClip: null,
        balanceBeta: null,
        balanceGamma: null,
        freezeLanguage: null,
        languageLr: null,
        promptVariants: null,
        promptRandomize: null,
        logAll: null,
        valScoreThresh: null,
        valMaxDets: null,
        segHead: null,
        segTrain: null,
        startButton: null,
        cancelButton: null,
        statusText: null,
        progressFill: null,
        message: null,
        summary: null,
        balanceDescription: null,
        log: null,
        history: null,
        activateButton: null,
        randomSplit: null,
        valPercent: null,
        splitSeed: null,
        cacheInfo: null,
        cachePurge: null,
    };

const sam3TrainState = {
    datasets: [],
    selectedId: null,
    activeJobId: null,
    pollHandle: null,
    lastJobSnapshot: null,
    latestCheckpoint: null,
    trendAlpha: 0.05,
    valMetrics: [],
};

    const sam3StorageElements = {
        list: null,
        refresh: null,
    };

    const sam3StorageState = {
        items: [],
    };

    const promptHelperElements = {
        datasetSelect: null,
        datasetRefresh: null,
        datasetSummary: null,
        sampleSize: null,
        maxSynonyms: null,
        scoreThresh: null,
        maxDets: null,
        iouThresh: null,
        seed: null,
        useQwen: null,
        generateButton: null,
        evaluateButton: null,
        presetName: null,
        presetSaveBtn: null,
        presetSelect: null,
        presetLoadBtn: null,
        status: null,
        summary: null,
        prompts: null,
        results: null,
        logs: null,
        message: null,
        applyButton: null,
    };

    const promptHelperState = {
        datasets: [],
        selectedId: null,
        activeJobId: null,
        pollHandle: null,
        lastJob: null,
        suggestions: [],
        promptsByClass: {},
        presets: [],
    };

    const promptSearchElements = {
        sampleSize: null,
        negatives: null,
        precisionFloor: null,
        scoreThresh: null,
        maxDets: null,
        iouThresh: null,
        seed: null,
        runButton: null,
        status: null,
        logs: null,
        results: null,
        message: null,
        classSelect: null,
    };

    const promptSearchState = {
        activeJobId: null,
        pollHandle: null,
        lastJob: null,
    };

    const promptRecipeElements = {
        classSelect: null,
        sampleSize: null,
        negatives: null,
        thresholds: null,
        maxDets: null,
        iouThresh: null,
        seed: null,
        expandCount: null,
        expandButton: null,
        runButton: null,
        status: null,
        logs: null,
        results: null,
        message: null,
    };
				    const agentElements = {
				        datasetSelect: null,
				        datasetRefresh: null,
				        datasetSummary: null,
			        evalImageCount: null,
			        splitSeed: null,
		        reuseCache: null,
			        workersPerGpu: null,
				        maxWorkers: null,
				        searchMode: null,
				        stepsOptions: null,
				        howItWorksDetails: null,
				        stepsAdvancedDetails: null,
				        stepsMaxSteps: null,
				        stepsMaxSeedsPerStep: null,
		    stepsGlobalPreset: null,
	        stepsBudgetBadge: null,
	        stepsBudgetText: null,
	        stepsBudgetFill: null,
	        stepsEarlyStop: null,
	        stepsEarlyStopMode: null,
	        stepsPromptPrefilter: null,
	        stepsPromptPrefilterMode: null,
	        stepsPromptBgDrop: null,
	        stepsPromptBgDropMode: null,
	        stepsGlobalEvalCap1: null,
	        stepsGlobalEvalCap2: null,
	        stepsGlobalEvalCap3: null,
		        stepsGlobalMaxTrials: null,
			        stepsGlobalKeepRatio: null,
			        stepsGlobalRounds: null,
			        stepsGlobalMutationsPerRound: null,
			        stepsGlobalMaxStepsMutated: null,
			        stepsGlobalEnableOrdering: null,
			        stepsGlobalEnableMaxResults: null,
		        stepsTier1Optimize: null,
		        stepsTier1EvalCap: null,
		        stepsTier1MaxTrials: null,
	        stepsTier2Optimize: null,
	        stepsTier2EvalCap: null,
	        stepsTier2MaxTrials: null,
	        stepsRefinePromptSubset: null,
	        stepsRefineMaxIters: null,
	        stepsRefineTopK: null,
		        stepsSeedEvalFloor: null,
		        stepsSeedEvalMaxResults: null,
			        iouThreshold: null,
		        seedThreshold: null,
		        expandThreshold: null,
	        seedDedupeIou: null,
	        dedupeIou: null,
	        maskThreshold: null,
	        maxResults: null,
	        minSize: null,
	        simplifyEps: null,
	        clipHeadSelect: null,
        clipHeadRefresh: null,
        clipHeadMeta: null,
	        clipHeadMinProb: null,
	        clipHeadMargin: null,
	        clipHeadAutoTune: null,
	        clipHeadTuneMargin: null,
	        clipHeadTargetPrecision: null,
        clipHeadTargetPrecisionValue: null,
        clipHeadAllowLowPrecision: null,
        clipHeadBgGuard: null,
        clipHeadBgMargin: null,
        clipHeadBgApply: null,
        clipHeadBgPenalty: null,
        clipHeadBgAutoTune: null,
        stepsHardNegExport: null,
        stepsHardNegMaxCrops: null,
        stepsHardNegMinProb: null,
        classesInput: null,
        extraPrompts: null,
        extraPromptsStatus: null,
        qwenMaxPrompts: null,
        promptReasoning: null,
        promptMaxTokens: null,
        runButton: null,
        refreshButton: null,
        cancelButton: null,
	        status: null,
	        results: null,
	        recipeSelect: null,
	        recipeRefresh: null,
	        recipeDownload: null,
	        recipeDelete: null,
	        recipeImport: null,
	        recipeFile: null,
	        logs: null,
	        cacheSize: null,
	        purgeCacheBtn: null,
	        progressFill: null,
	        progressText: null,
	    };

    const promptRecipeState = {
        activeJobId: null,
        pollHandle: null,
        lastJob: null,
    };
			    const agentState = {
			        lastJob: null,
			        datasetsById: {},
			        clipHeads: [],
			        pollTimer: null,
			        pollInFlight: false,
			        lastRenderedLogKey: null,
			    };
	
			    let agentStepsGlobalPresetLock = false;

    let promptHelperInitialized = false;

    const segBuilderElements = {
        datasetSelect: null,
        datasetSummary: null,
        outputName: null,
        samVariant: null,
        startButton: null,
        refreshButton: null,
        jobsRefresh: null,
        jobsContainer: null,
        message: null,
        log: null,
    };

    const segBuilderState = {
        datasets: [],
        selectedId: null,
        jobs: [],
        lastSeenJob: {},
        activeJobId: null,
        pollTimer: null,
        pollInFlight: false,
    };

    const datasetManagerElements = {
        uploadFile: null,
        uploadName: null,
        uploadType: null,
        uploadBtn: null,
        uploadMessage: null,
        uploadCurrentBtn: null,
        uploadCurrentName: null,
        uploadCurrentContext: null,
        uploadCurrentSummary: null,
        refreshBtn: null,
        list: null,
        deleteButtons: new Map(),
    };

    const datasetManagerState = {
        datasets: [],
        uploading: false,
    };

    function setDatasetUploadMessage(text, tone) {
        if (!datasetManagerElements.uploadMessage) return;
        datasetManagerElements.uploadMessage.textContent = text || "";
        datasetManagerElements.uploadMessage.className = `training-message ${tone || ""}`;
    }

	    function renderDatasetList(list) {
	        datasetManagerState.datasets = Array.isArray(list) ? list : [];
	        const container = datasetManagerElements.list;
	        if (container) {
	            container.innerHTML = "";
            if (!datasetManagerState.datasets.length) {
                const empty = document.createElement("div");
                empty.className = "training-history-item";
                empty.textContent = "No datasets yet. Upload one to get started.";
                container.appendChild(empty);
            } else {
	                datasetManagerState.datasets.forEach((entry) => {
	                    const item = document.createElement("div");
	                    item.className = "training-history-item";
	                    const header = document.createElement("div");
	                    header.className = "training-history-row";
	                    const title = document.createElement("div");
	                    title.className = "training-history-title";
	                    title.textContent = entry.label || entry.id;
	                    const badgeWrap = document.createElement("div");
	                    badgeWrap.style.display = "flex";
	                    badgeWrap.style.gap = "6px";
	                    badgeWrap.style.flexWrap = "wrap";
	                    const typeBadge = document.createElement("span");
	                    typeBadge.className = "badge";
	                    typeBadge.textContent = (entry.type || "bbox").toUpperCase();
	                    typeBadge.title = (entry.type || "bbox") === "seg"
	                        ? "Polygon / YOLO-seg geometry"
	                        : "Bounding box / YOLO geometry";
	                    badgeWrap.appendChild(typeBadge);
	                    if (entry.yolo_ready) {
	                        const yoloBadge = document.createElement("span");
	                        yoloBadge.className = "badge";
	                        yoloBadge.textContent = entry.yolo_seg_ready ? "YOLO-SEG" : "YOLO";
	                        yoloBadge.title = entry.yolo_seg_ready
	                            ? "YOLO polygon labels detected (segmentation-ready)."
	                            : "YOLO images/labels + labelmap.txt detected.";
	                        badgeWrap.appendChild(yoloBadge);
	                    }
	                    if (entry.coco_seg_ready) {
	                        const cocoSegBadge = document.createElement("span");
	                        cocoSegBadge.className = "badge";
	                        cocoSegBadge.textContent = "COCO-SEG";
	                        cocoSegBadge.title = "COCO polygon annotations present (segmentation-ready).";
	                        badgeWrap.appendChild(cocoSegBadge);
	                    } else if (entry.coco_ready) {
	                        const cocoBadge = document.createElement("span");
	                        cocoBadge.className = "badge";
	                        cocoBadge.textContent = "COCO";
	                        cocoBadge.title = "COCO annotations present (used by SAM3 training + recipe mining).";
	                        badgeWrap.appendChild(cocoBadge);
	                    }
                    if (entry.qwen_ready) {
                        const qwenBadge = document.createElement("span");
                        qwenBadge.className = "badge";
                        qwenBadge.textContent = "QWEN";
                        qwenBadge.title = "Qwen JSONL annotations present (used by Qwen training).";
                        badgeWrap.appendChild(qwenBadge);
                    }
                    if (entry.caption_count || entry.caption_dir) {
                        const captionBadge = document.createElement("span");
                        captionBadge.className = "badge";
                        const percent = typeof entry.caption_percent === "number"
                            ? Math.round(entry.caption_percent)
                            : null;
                        if (percent !== null && Number.isFinite(percent)) {
                            captionBadge.textContent = `CAPTIONS ${percent}%`;
                            captionBadge.title = `Captions for ${entry.caption_count || 0} of ${entry.caption_total || 0} images.`;
                        } else {
                            captionBadge.textContent = entry.caption_count ? "CAPTIONS" : "CAPTIONS none";
                            captionBadge.title = entry.caption_count
                                ? `Captions detected (${entry.caption_count}).`
                                : "No caption labels detected.";
                        }
                        badgeWrap.appendChild(captionBadge);
                    }
	                    header.appendChild(title);
	                    header.appendChild(badgeWrap);
	                    const actions = document.createElement("div");
	                    actions.className = "training-history-actions";
	                    const downloadBtn = document.createElement("button");
	                    downloadBtn.type = "button";
                    downloadBtn.className = "button button-outline";
                    downloadBtn.textContent = "Download";
                    downloadBtn.title = "Download this dataset as a zip.";
                    downloadBtn.addEventListener("click", () => handleDatasetDownload(entry));
                    actions.appendChild(downloadBtn);
                    const convertBtn = document.createElement("button");
                    convertBtn.type = "button";
                    convertBtn.className = "button button-outline";
                    const isSeg = entry.type === "seg";
                    const cocoReady = isSeg ? !!entry.coco_seg_ready : !!entry.coco_ready;
                    if (isSeg) {
                        convertBtn.textContent = cocoReady ? "COCO-SEG ready" : "Convert to COCO-SEG";
                    } else {
                        convertBtn.textContent = cocoReady ? "COCO ready" : "Convert to COCO";
                    }
                    convertBtn.disabled = cocoReady;
                    convertBtn.title = cocoReady
                        ? "COCO annotations are already present."
                        : "Generate COCO annotations for SAM3 training, prompt helper, and recipe mining.";
	                    convertBtn.addEventListener("click", () => handleDatasetConvert(entry));
	                    actions.appendChild(convertBtn);
                    const qwenBtn = document.createElement("button");
                    qwenBtn.type = "button";
                    qwenBtn.className = "button button-outline";
                    const qwenEligible = !!entry.yolo_ready;
                    qwenBtn.textContent = entry.qwen_ready ? "Qwen3 ready" : "Build Qwen3";
                    qwenBtn.disabled = !!entry.qwen_ready || !qwenEligible;
                    qwenBtn.title = entry.qwen_ready
                        ? "Qwen JSONL annotations are already present."
                        : !qwenEligible
                            ? "Requires a YOLO dataset (labelmap.txt + labels/)."
                            : "Generate Qwen JSONL annotations for Qwen training (uses your labelmap order + optional dataset context).";
                    qwenBtn.addEventListener("click", () => handleDatasetBuildQwen(entry));
                    actions.appendChild(qwenBtn);
	                    const delBtn = document.createElement("button");
	                    delBtn.type = "button";
	                    delBtn.className = "button button-outline";
	                    delBtn.textContent = "Delete";
                    delBtn.addEventListener("click", () => handleDatasetDelete(entry));
                    actions.appendChild(delBtn);
                    header.appendChild(actions);
	                    const meta = document.createElement("div");
	                    meta.className = "training-help";
	                    const parts = [];
	                    if (entry.source) parts.push(entry.source);
	                    if (entry.format) parts.push(entry.format.toUpperCase());
	                    if (isSeg) {
	                        parts.push(entry.coco_seg_ready ? "COCO-SEG ready" : "COCO-SEG missing");
	                    } else {
	                        parts.push(entry.coco_ready ? "COCO ready" : "COCO missing");
	                    }
	                    if (entry.qwen_ready) {
	                        const qwenTrain = Number.isFinite(entry.qwen_train_count) ? entry.qwen_train_count : null;
	                        const qwenVal = Number.isFinite(entry.qwen_val_count) ? entry.qwen_val_count : null;
	                        if (qwenTrain !== null && qwenVal !== null) {
	                            parts.push(`Qwen3 ready (train ${qwenTrain} / val ${qwenVal})`);
	                        } else {
	                            parts.push("Qwen3 ready");
	                        }
	                    } else {
	                        parts.push("Qwen3 missing");
	                    }
	                    const counts = [];
	                    if (entry.image_count) counts.push(`${entry.image_count} img`);
	                    if (entry.train_count) counts.push(`train ${entry.train_count}`);
	                    if (entry.val_count) counts.push(`val ${entry.val_count}`);
	                    if (counts.length) parts.push(counts.join(" / "));
	                    meta.textContent = parts.join(" • ") || "Dataset ready";
	                    item.appendChild(header);
	                    item.appendChild(meta);
	                    container.appendChild(item);
	                });
            }
        }
        renderSegBuilderDatasets(datasetManagerState.datasets);
    }

	    async function handleDatasetDelete(entry) {
	        if (!entry || !entry.id) return;
	        const ok = window.confirm(`Delete dataset "${entry.label || entry.id}"? This cannot be undone.`);
	        if (!ok) return;
        setDatasetUploadMessage(`Deleting ${entry.label || entry.id}…`, "info");
        try {
            const resp = await fetch(`${API_ROOT}/datasets/${encodeURIComponent(entry.id)}`, { method: "DELETE" });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            setDatasetUploadMessage(`Deleted ${entry.label || entry.id}.`, "success");
            await refreshDatasetList();
        } catch (err) {
            console.error("Failed to delete dataset", err);
            setDatasetUploadMessage(err.message || "Failed to delete dataset", "error");
	        }
	    }

		    async function handleDatasetConvert(entry) {
		        if (!entry || !entry.id) return;
		        setDatasetUploadMessage(`Converting ${entry.label || entry.id} to COCO…`, "info");
		        try {
	            const resp = await fetch(`${API_ROOT}/sam3/datasets/${encodeURIComponent(entry.id)}/convert`, { method: "POST" });
	            if (!resp.ok) {
	                const detail = await resp.text();
	                throw new Error(detail || `HTTP ${resp.status}`);
	            }
	            setDatasetUploadMessage(`Converted ${entry.label || entry.id}.`, "success");
	            await refreshDatasetList();
	        } catch (err) {
	            console.error("Failed to convert dataset", err);
	            setDatasetUploadMessage(err.message || "Failed to convert dataset", "error");
		        }
		    }

		    async function handleDatasetBuildQwen(entry) {
		        if (!entry || !entry.id) return;
		        setDatasetUploadMessage(`Building Qwen annotations for ${entry.label || entry.id}…`, "info");
		        try {
		            const resp = await fetch(`${API_ROOT}/datasets/${encodeURIComponent(entry.id)}/build/qwen`, {
		                method: "POST",
		                headers: { "Content-Type": "application/json" },
		                body: JSON.stringify({ force: false }),
		            });
		            if (!resp.ok) {
		                const detail = await resp.text();
		                throw new Error(detail || `HTTP ${resp.status}`);
		            }
		            setDatasetUploadMessage(`Built Qwen annotations for ${entry.label || entry.id}.`, "success");
		            await refreshDatasetList();
		        } catch (err) {
		            console.error("Failed to build Qwen dataset", err);
		            setDatasetUploadMessage(err.message || "Failed to build Qwen dataset", "error");
		        }
		    }

		    function handleDatasetDownload(entry) {
		        if (!entry || !entry.id) return;
		        const url = `${API_ROOT}/datasets/${encodeURIComponent(entry.id)}/download`;
		        const link = document.createElement("a");
	        link.href = url;
	        link.rel = "noopener";
	        document.body.appendChild(link);
	        link.click();
	        link.remove();
	    }

	    async function refreshDatasetList() {
	        try {
	            const resp = await fetch(`${API_ROOT}/datasets`);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            renderDatasetList(data);
            // Keep the segmentation builder dropdown in sync.
            renderSegBuilderDatasets(data);
        } catch (err) {
            console.error("Failed to refresh datasets", err);
            setDatasetUploadMessage(`Failed to load datasets: ${err.message || err}`, "error");
        }
    }

    async function uploadDatasetZip() {
        if (!datasetManagerElements.uploadFile || !datasetManagerElements.uploadFile.files.length) {
            setDatasetUploadMessage("Choose a zip file first.", "warn");
            return;
        }
        const formData = new FormData();
        formData.append("file", datasetManagerElements.uploadFile.files[0]);
        if (datasetManagerElements.uploadName && datasetManagerElements.uploadName.value.trim()) {
            formData.append("dataset_id", datasetManagerElements.uploadName.value.trim());
        }
        if (datasetManagerElements.uploadType && datasetManagerElements.uploadType.value) {
            formData.append("dataset_type", datasetManagerElements.uploadType.value);
        }
        datasetManagerState.uploading = true;
        setDatasetUploadMessage("Uploading dataset…", "info");
        try {
            const resp = await fetch(`${API_ROOT}/datasets/upload`, { method: "POST", body: formData });
            const detail = await resp.text();
            if (!resp.ok) {
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            const data = detail ? JSON.parse(detail) : {};
            setDatasetUploadMessage(`Uploaded ${data.label || data.id || "dataset"}.`, "success");
            if (datasetManagerElements.uploadFile) {
                datasetManagerElements.uploadFile.value = "";
            }
            await refreshDatasetList();
        } catch (err) {
            console.error("Dataset upload failed", err);
            setDatasetUploadMessage(err.message || "Dataset upload failed", "error");
	        } finally {
	            datasetManagerState.uploading = false;
	        }
	    }

		    async function uploadCurrentDatasetToCache() {
		        try {
		            const validation = validateGeometryForSave();
		            if (!validation.ok) {
		                setDatasetUploadMessage(validation.message || "Dataset geometry invalid.", "warn");
		                return;
		            }
		            const imageKeys = Object.keys(images || {});
		            if (!imageKeys.length) {
		                setDatasetUploadMessage("Load images in the labeling tab first.", "warn");
		                return;
		            }
		            const classNames = Object.keys(classes || {});
		            if (!classNames.length) {
		                setDatasetUploadMessage("Load a labelmap in the labeling tab first.", "warn");
		                return;
		            }
		            setDatasetUploadMessage("Packaging current dataset as YOLO zip…", "info");
		            const runNameRaw = datasetManagerElements.uploadCurrentName?.value?.trim() || "";
		            const contextText = datasetManagerElements.uploadCurrentContext?.value?.trim() || "";
		            const runName = runNameRaw || "labeling_session";
		            const zip = new JSZip();
		            const folderName = sanitizeDatasetFilename(runName) || "labeling_session";
		            const root = zip.folder(folderName);
		            const labelmapEntries = Object.keys(classes || {}).map((name) => ({
		                name,
		                idx: Number(classes[name]),
		            })).filter((entry) => Number.isFinite(entry.idx));
		            labelmapEntries.sort((a, b) => a.idx - b.idx);
		            if (!labelmapEntries.length) {
		                throw new Error("Labelmap is empty.");
		            }
		            const maxIdx = labelmapEntries[labelmapEntries.length - 1].idx;
		            if (labelmapEntries[0].idx !== 0 || maxIdx !== labelmapEntries.length - 1) {
		                throw new Error("Labelmap indices must be contiguous starting at 0.");
		            }
		            root.file("labelmap.txt", labelmapEntries.map((entry) => entry.name).join("\n"));
		            const usedNames = new Map();
		            for (const imageKey of imageKeys) {
		                const imageRecord = images[imageKey];
		                if (!imageRecord || !imageRecord.meta) {
		                    throw new Error(`Missing original file for ${imageKey}. Re-import the images and try again.`);
		                }
		                await ensureImageDimensions(imageRecord);
		                const baseName = imageRecord.meta.name || imageKey;
		                const safeName = makeUniqueFilename(baseName, usedNames);
		                root.file(`train/images/${safeName}`, imageRecord.meta);
		                const labelNameParts = safeName.split(".");
		                if (labelNameParts.length > 1) {
		                    labelNameParts[labelNameParts.length - 1] = "txt";
		                } else {
		                    labelNameParts.push("txt");
		                }
		                const labelRel = labelNameParts.join(".");
		                const result = [];
		                const buckets = bboxes[imageKey] || {};
		                for (const className of Object.keys(buckets)) {
		                    const bucket = buckets[className] || [];
		                    const classIdx = classes[className];
		                    bucket.forEach((bbox) => {
		                        if (!bbox) return;
		                        if (datasetType === "seg" && Array.isArray(bbox.points) && bbox.points.length >= 3) {
		                            const coords = bbox.points
		                                .map((pt) => {
		                                    const nx = pt.x / imageRecord.width;
		                                    const ny = pt.y / imageRecord.height;
		                                    return `${nx} ${ny}`;
		                                })
		                                .join(" ");
		                            result.push(`${classIdx} ${coords}`);
		                        } else {
		                            const x = (bbox.x + bbox.width / 2) / imageRecord.width;
		                            const y = (bbox.y + bbox.height / 2) / imageRecord.height;
		                            const w = bbox.width / imageRecord.width;
		                            const h = bbox.height / imageRecord.height;
		                            result.push(`${classIdx} ${x} ${y} ${w} ${h}`);
		                        }
		                    });
		                }
		                root.file(`train/labels/${labelRel}`, result.join("\n"));
		            }
		            const blob = await zip.generateAsync({ type: "blob" });
		            const formData = new FormData();
		            formData.append("file", blob, `${folderName}.zip`);
		            formData.append("dataset_id", runName);
		            formData.append("dataset_type", datasetType === "seg" ? "seg" : "bbox");
		            if (contextText) {
		                formData.append("context", contextText);
		            }
		            const resp = await fetch(`${API_ROOT}/datasets/upload`, { method: "POST", body: formData });
		            const detail = await resp.text();
		            if (!resp.ok) {
		                throw new Error(detail || `HTTP ${resp.status}`);
		            }
		            const data = detail ? JSON.parse(detail) : {};
		            const label = data?.label || data?.id || runName;
		            setDatasetUploadMessage(`Uploaded ${label} from the labeling tab.`, "success");
		            if (datasetManagerElements.uploadCurrentSummary) {
		                datasetManagerElements.uploadCurrentSummary.textContent = `Saved as ${label}`;
		            }
		            await refreshDatasetList();
		            return data;
	        } catch (err) {
	            console.error("Upload current dataset failed", err);
	            setDatasetUploadMessage(err.message || "Failed to upload current dataset", "error");
	            return null;
	        }
	    }

    async function initDatasetManagerTab() {
        if (datasetManagerElements.uploadBtn) {
            return;
        }
        datasetManagerElements.uploadFile = document.getElementById("datasetUploadFile");
        datasetManagerElements.uploadName = document.getElementById("datasetUploadName");
        datasetManagerElements.uploadType = document.getElementById("datasetUploadType");
	        datasetManagerElements.uploadBtn = document.getElementById("datasetUploadBtn");
	        datasetManagerElements.uploadMessage = document.getElementById("datasetUploadMessage");
	        datasetManagerElements.uploadCurrentBtn = document.getElementById("datasetUploadCurrentBtn");
	        datasetManagerElements.uploadCurrentName = document.getElementById("datasetUploadCurrentName");
	        datasetManagerElements.uploadCurrentContext = document.getElementById("datasetUploadCurrentContext");
	        datasetManagerElements.uploadCurrentSummary = document.getElementById("datasetUploadCurrentSummary");
	        datasetManagerElements.refreshBtn = document.getElementById("datasetListRefresh");
	        datasetManagerElements.refreshBtnTop = document.getElementById("datasetListRefreshTop");
	        datasetManagerElements.list = document.getElementById("datasetList");
        if (datasetManagerElements.uploadBtn) {
            datasetManagerElements.uploadBtn.addEventListener("click", () => uploadDatasetZip());
        }
        if (datasetManagerElements.uploadCurrentBtn) {
            datasetManagerElements.uploadCurrentBtn.addEventListener("click", () => uploadCurrentDatasetToCache());
        }
        if (datasetManagerElements.refreshBtn) {
            datasetManagerElements.refreshBtn.addEventListener("click", () => refreshDatasetList());
        }
        if (datasetManagerElements.refreshBtnTop) {
            datasetManagerElements.refreshBtnTop.addEventListener("click", () => refreshDatasetList());
        }
        initSegBuilderUi();
        await refreshDatasetList();
        await refreshSegBuilderJobs();
    }

    const sam3PromptElements = {
        select: null,
        refresh: null,
        summary: null,
        activeLabel: null,
        message: null,
        activate: null,
    };

    const sam3PromptState = {
        models: [],
        selected: null,
    };

    function initSam3PromptModelsUi() {
        sam3PromptElements.select = document.getElementById("sam3PromptModelSelect");
        sam3PromptElements.refresh = document.getElementById("sam3PromptRefresh");
        sam3PromptElements.summary = document.getElementById("sam3PromptModelSummary");
        sam3PromptElements.activeLabel = document.getElementById("sam3PromptActiveLabel");
        sam3PromptElements.message = document.getElementById("sam3PromptMessage");
        sam3PromptElements.activate = document.getElementById("sam3PromptActivate");
        if (sam3PromptElements.select) {
            sam3PromptElements.select.addEventListener("change", () => updateSam3PromptSummary());
        }
        if (sam3PromptElements.refresh) {
            sam3PromptElements.refresh.addEventListener("click", () => refreshSam3PromptModels());
        }
        if (sam3PromptElements.activate) {
            sam3PromptElements.activate.addEventListener("click", () => activateSam3PromptModel());
        }
        refreshSam3PromptModels();
    }

    async function refreshSam3PromptModels() {
        if (!sam3PromptElements.select) return;
        try {
            const resp = await fetch(`${API_ROOT}/sam3/models/available?variant=all&promoted_only=true`);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            sam3PromptState.models = Array.isArray(data) ? data : [];
            sam3PromptState.models.sort((a, b) => {
                const pa = a.promoted ? 0 : 1;
                const pb = b.promoted ? 0 : 1;
                if (pa !== pb) return pa - pb;
                const va = a.variant || "";
                const vb = b.variant || "";
                if (va !== vb) return va.localeCompare(vb);
                return (a.id || "").localeCompare(b.id || "");
            });
            sam3PromptElements.select.innerHTML = "";
            sam3PromptState.models.forEach((m, idx) => {
                const opt = document.createElement("option");
                opt.value = m.key || m.path || m.id || `model-${idx}`;
            const sizeText = Number.isFinite(m.size_bytes) ? ` – ${formatBytes(m.size_bytes)}` : "";
            const activeText = m.active ? " (active)" : "";
            opt.textContent = `${m.id || `run ${idx + 1}`} [${m.variant || "sam3"}]${m.promoted ? " (promoted)" : ""}${activeText}${sizeText}`;
            sam3PromptElements.select.appendChild(opt);
        });
            if (sam3PromptState.models.length) {
                const first = sam3PromptState.models[0];
                sam3PromptElements.select.value = first.key || first.path || first.id || sam3PromptElements.select.options[0].value;
                updateSam3PromptSummary();
            } else {
                updateSam3PromptSummary();
            }
        } catch (err) {
            console.error("Failed to load SAM3 prompt models", err);
            setSam3PromptMessage(`Load failed: ${err.message || err}`, "error");
        }
    }

    function updateSam3PromptSummary() {
        if (!sam3PromptElements.summary) return;
        const path = sam3PromptElements.select ? sam3PromptElements.select.value : null;
        const entry = sam3PromptState.models.find((m) => (m.key || m.path || m.id) === path);
        const activeEntry = sam3PromptState.models.find((m) => m.active);
        if (sam3PromptElements.activeLabel) {
            sam3PromptElements.activeLabel.textContent = activeEntry
                ? `Active model: ${activeEntry.id || "unknown"} [${activeEntry.variant || "sam3"}]`
                : "Active model: none";
        }
        if (!entry) {
            sam3PromptElements.summary.textContent = "No model selected.";
            return;
        }
        const parts = [];
        if (entry.promoted) parts.push("promoted");
        if (entry.active) parts.push("active");
        if (Number.isFinite(entry.size_bytes)) parts.push(formatBytes(entry.size_bytes));
        if (entry.run_path) parts.push(`run: ${entry.run_path}`);
        sam3PromptElements.summary.textContent = parts.length ? parts.join(" • ") : "";
    }

    function setSam3PromptMessage(text, tone = "info") {
        if (!sam3PromptElements.message) return;
        sam3PromptElements.message.textContent = text || "";
        sam3PromptElements.message.className = `training-message ${tone}`;
    }

    async function activateSam3PromptModel() {
        if (!sam3PromptElements.select) return;
        const path = sam3PromptElements.select.value;
        const entry = sam3PromptState.models.find((m) => (m.key || m.path || m.id) === path);
        if (!entry) {
            setSam3PromptMessage("Select a model first.", "warn");
            return;
        }
        const payload = {
            checkpoint_path: entry.path || null,
            enable_segmentation: false,
            label: `prompt:${(entry.id || entry.path || "sam3").toString().split("/").pop()}`,
        };
        try {
            const resp = await fetch(`${API_ROOT}/sam3/models/activate`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            setSam3PromptMessage("SAM3 prompt model activated.", "success");
        } catch (err) {
            console.error("Activate SAM3 prompt model failed", err);
            setSam3PromptMessage(`Activate failed: ${err.message || err}`, "error");
        }
    }

    function escapeHtml(value) {
        return String(value ?? "")
            .replace(/&/g, "&amp;")
            .replace(/</g, "&lt;")
            .replace(/>/g, "&gt;")
            .replace(/"/g, "&quot;")
            .replace(/'/g, "&#39;");
    }

    function formatTimestamp(seconds) {
        if (typeof seconds !== "number" || Number.isNaN(seconds)) {
            return "";
        }
        const date = new Date(seconds * 1000);
        if (Number.isNaN(date.getTime())) {
            return "";
        }
        return date.toLocaleTimeString([], { hour12: false });
    }

    function formatNumber(value, digits = 4) {
        if (value === null || value === undefined || Number.isNaN(value)) {
            return "—";
        }
        return Number(value).toFixed(digits);
    }

    function updateBalanceParamVisibility(strategy) {
        const chosen = strategy || (sam3TrainElements.balanceStrategy && sam3TrainElements.balanceStrategy.value) || "none";
        const rows = document.querySelectorAll(".sam3-balance-param");
        rows.forEach((row) => {
            const param = row.dataset ? row.dataset.param : null;
            let show = false;
            if (param === "power") {
                show = ["inv_sqrt", "clipped_inv"].includes(chosen);
            } else if (param === "clip") {
                show = chosen === "clipped_inv";
            } else if (param === "beta") {
                show = chosen === "effective_num";
            } else if (param === "gamma") {
                show = chosen === "focal";
            }
            row.style.display = show ? "" : "none";
        });
        if (sam3TrainElements.balanceDescription) {
            let desc = "";
            if (chosen === "inv_sqrt") {
                desc = "Weights = sum(1 / freq^power). Power < 1 gives mild up-weighting of rare classes (default power 0.5).";
            } else if (chosen === "clipped_inv") {
                desc = "Inverse-frequency with a cap: weight ∝ 1/freq^power, then clipped so max/min ≤ clip ratio.";
            } else if (chosen === "effective_num") {
                desc = "Effective number of samples: weight ∝ (1-β)/(1-β^n). Higher β (e.g., 0.99–0.999) boosts rare classes smoothly.";
            } else if (chosen === "focal") {
                desc = "Focal-style sampling: weight ∝ (freq / max_freq)^(-γ). Higher γ boosts rare/low-freq classes.";
            } else {
                desc = "Uniform sampling (no class rebalance).";
            }
            sam3TrainElements.balanceDescription.textContent = desc;
        }
    }

	    function getSelectedQwenDataset() {
	        const id = qwenDatasetState.selectedId;
	        if (!id) {
	            return null;
        }
        return qwenDatasetState.items.find((entry) => entry.id === id) || null;
    }

    function selectQwenDatasetById(datasetId) {
        if (!datasetId) {
            return;
        }
        qwenDatasetState.selectedId = datasetId;
        if (qwenTrainElements.datasetSelect) {
            qwenTrainElements.datasetSelect.value = datasetId;
        }
        updateQwenDatasetSummary();
    }

	    function updateQwenDatasetSummary() {
	        const summaryEl = qwenTrainElements.datasetSummary;
	        if (!summaryEl) {
	            return;
	        }
	        const entry = getSelectedQwenDataset();
	        if (entry) {
	            const context = entry.context ? ` Context: ${entry.context}` : "";
	            const qwenTrain = Number.isFinite(entry.qwen_train_count) ? entry.qwen_train_count : null;
	            const qwenVal = Number.isFinite(entry.qwen_val_count) ? entry.qwen_val_count : null;
	            const qwenCounts = (qwenTrain !== null && qwenVal !== null) ? `Qwen3: train ${qwenTrain} / val ${qwenVal}` : (entry.qwen_ready ? "Qwen3 ready" : "Qwen3 missing");
	            summaryEl.textContent = `Dataset "${entry.label}" (${entry.image_count || 0} images, train ${entry.train_count || 0} / val ${entry.val_count || 0}) • ${qwenCounts}.${context}`;
	            return;
	        }
	        summaryEl.textContent = "No dataset selected. Create and manage datasets in the Dataset Management tab, then refresh.";
	    }

	    function setQwenDatasetModeState() {
	        if (qwenTrainElements.datasetSelect) {
	            qwenTrainElements.datasetSelect.disabled = !qwenDatasetState.items.length;
	        }
	        if (qwenTrainElements.datasetRefresh) {
	            qwenTrainElements.datasetRefresh.disabled = false;
	        }
	        updateQwenDatasetSummary();
	    }

	    function populateQwenDatasetSelect() {
	        const select = qwenTrainElements.datasetSelect;
	        if (!select) {
	            return;
        }
        select.innerHTML = "";
        if (!qwenDatasetState.items.length) {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "No cached datasets";
            select.appendChild(option);
            select.disabled = true;
		        } else {
		            qwenDatasetState.items.forEach((entry) => {
		                const option = document.createElement("option");
		                option.value = entry.id;
		                const status = entry.qwen_ready ? "Qwen3 ready" : "needs Qwen3 build";
	                option.textContent = `${entry.label || entry.id} (${entry.image_count || 0} images, ${status})`;
	                select.appendChild(option);
	            });
	            if (!qwenDatasetState.selectedId || !qwenDatasetState.items.some((entry) => entry.id === qwenDatasetState.selectedId)) {
	                qwenDatasetState.selectedId = qwenDatasetState.items[0].id;
	            }
	            select.disabled = false;
	            select.value = qwenDatasetState.selectedId;
	        }
	        if (qwenTrainElements.datasetRefresh) {
	            qwenTrainElements.datasetRefresh.disabled = false;
	        }
	        updateQwenDatasetSummary();
	    }

	    async function loadQwenDatasetList(force = false) {
	        if (!force && qwenDatasetState.items.length) {
	            populateQwenDatasetSelect();
	            return qwenDatasetState.items;
	        }
	        try {
	            const resp = await fetch(`${API_ROOT}/datasets`);
	            if (!resp.ok) {
	                throw new Error(`HTTP ${resp.status}`);
	            }
	            const data = await resp.json();
	            qwenDatasetState.items = Array.isArray(data)
	                ? data.filter((d) => d && (d.yolo_ready || d.qwen_ready))
	                : [];
	            populateQwenDatasetSelect();
	            return qwenDatasetState.items;
	        } catch (error) {
	            console.error("Failed to load cached Qwen datasets", error);
	            if (qwenTrainElements.datasetSummary) {
	                qwenTrainElements.datasetSummary.textContent = `Unable to load datasets: ${error.message || error}`;
	            }
	            return [];
	        }
	    }

    function getSelectedYoloDataset() {
        const id = yoloDatasetState.selectedId;
        if (!id) {
            return null;
        }
        return yoloDatasetState.items.find((entry) => entry.id === id) || null;
    }

    function updateYoloDatasetSummary() {
        const summaryEl = yoloTrainElements.datasetSummary;
        if (!summaryEl) {
            return;
        }
        const entry = getSelectedYoloDataset();
        if (entry) {
            const formatLabel = entry.format ? `format: ${entry.format}` : "format: unknown";
            const yoloStatus = entry.yolo_ready ? "YOLO ready" : "needs YOLO conversion";
            summaryEl.textContent = `Dataset "${entry.label || entry.id}" (${entry.image_count || 0} images, train ${entry.train_count || 0} / val ${entry.val_count || 0}) • ${formatLabel} • ${yoloStatus}`;
            return;
        }
        summaryEl.textContent = "No dataset selected. Create and manage datasets in the Dataset Management tab, then refresh.";
    }

    function populateYoloDatasetSelect() {
        const select = yoloTrainElements.datasetSelect;
        if (!select) {
            return;
        }
        select.innerHTML = "";
        if (!yoloDatasetState.items.length) {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "No datasets available";
            select.appendChild(option);
            select.disabled = true;
        } else {
            yoloDatasetState.items.forEach((entry) => {
                const option = document.createElement("option");
                option.value = entry.id;
                const status = entry.yolo_ready ? "YOLO ready" : "needs YOLO";
                option.textContent = `${entry.label || entry.id} (${entry.image_count || 0} images, ${status})`;
                select.appendChild(option);
            });
            if (!yoloDatasetState.selectedId || !yoloDatasetState.items.some((entry) => entry.id === yoloDatasetState.selectedId)) {
                yoloDatasetState.selectedId = yoloDatasetState.items[0].id;
            }
            select.disabled = false;
            select.value = yoloDatasetState.selectedId;
        }
        updateYoloDatasetSummary();
    }

    async function loadYoloDatasetList(force = false) {
        if (!force && yoloDatasetState.items.length) {
            populateYoloDatasetSelect();
            return yoloDatasetState.items;
        }
        try {
            const resp = await fetch(`${API_ROOT}/datasets`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const data = await resp.json();
            yoloDatasetState.items = Array.isArray(data) ? data : [];
            populateYoloDatasetSelect();
            return yoloDatasetState.items;
        } catch (error) {
            if (yoloTrainElements.datasetSummary) {
                yoloTrainElements.datasetSummary.textContent = `Unable to load datasets: ${error.message || error}`;
            }
            return [];
        }
    }

    function getSelectedRfDetrDataset() {
        const id = rfdetrDatasetState.selectedId;
        if (!id) {
            return null;
        }
        return rfdetrDatasetState.items.find((entry) => entry.id === id) || null;
    }

    function updateRfDetrDatasetSummary() {
        const summaryEl = rfdetrTrainElements.datasetSummary;
        if (!summaryEl) {
            return;
        }
        const entry = getSelectedRfDetrDataset();
        if (entry) {
            const formatLabel = entry.format ? `format: ${entry.format}` : "format: unknown";
            const isSeg = entry.type === "seg";
            const cocoStatus = isSeg
                ? (entry.coco_seg_ready ? "COCO-SEG ready" : "COCO-SEG will be generated")
                : (entry.coco_ready ? "COCO ready" : "COCO will be generated");
            summaryEl.textContent = `Dataset "${entry.label || entry.id}" (${entry.image_count || 0} images, train ${entry.train_count || 0} / val ${entry.val_count || 0}) • ${formatLabel} • ${cocoStatus}`;
            return;
        }
        summaryEl.textContent = "No dataset selected. Create and manage datasets in the Dataset Management tab, then refresh.";
    }

    function populateRfDetrDatasetSelect() {
        const select = rfdetrTrainElements.datasetSelect;
        if (!select) {
            return;
        }
        select.innerHTML = "";
        if (!rfdetrDatasetState.items.length) {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "No datasets available";
            select.appendChild(option);
            select.disabled = true;
        } else {
            rfdetrDatasetState.items.forEach((entry) => {
                const option = document.createElement("option");
                option.value = entry.id;
                const isSeg = entry.type === "seg";
                const status = isSeg
                    ? (entry.coco_seg_ready ? "COCO-SEG ready" : "needs COCO-SEG")
                    : (entry.coco_ready ? "COCO ready" : "needs COCO");
                option.textContent = `${entry.label || entry.id} (${entry.image_count || 0} images, ${status})`;
                select.appendChild(option);
            });
            if (!rfdetrDatasetState.selectedId || !rfdetrDatasetState.items.some((entry) => entry.id === rfdetrDatasetState.selectedId)) {
                rfdetrDatasetState.selectedId = rfdetrDatasetState.items[0].id;
            }
            select.disabled = false;
            select.value = rfdetrDatasetState.selectedId;
        }
        updateRfDetrDatasetSummary();
    }

    async function loadRfDetrDatasetList(force = false) {
        if (!force && rfdetrDatasetState.items.length) {
            populateRfDetrDatasetSelect();
            return rfdetrDatasetState.items;
        }
        try {
            const resp = await fetch(`${API_ROOT}/datasets`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const data = await resp.json();
            rfdetrDatasetState.items = Array.isArray(data) ? data : [];
            populateRfDetrDatasetSelect();
            return rfdetrDatasetState.items;
        } catch (error) {
            if (rfdetrTrainElements.datasetSummary) {
                rfdetrTrainElements.datasetSummary.textContent = `Unable to load datasets: ${error.message || error}`;
            }
            return [];
        }
    }

    function getSelectedYoloRun() {
        const id = yoloRunState.selectedId;
        if (!id) {
            return null;
        }
        return yoloRunState.items.find((entry) => entry.run_id === id) || null;
    }

    function updateYoloRunSummary() {
        if (!yoloTrainElements.runSummary) {
            return;
        }
        const entry = getSelectedYoloRun();
        if (!entry) {
            yoloTrainElements.runSummary.textContent = "No runs yet.";
            return;
        }
        const datasetLabel = entry.dataset_label ? `dataset: ${entry.dataset_label}` : "dataset: unknown";
        const created = entry.created_at ? new Date(entry.created_at * 1000).toLocaleString() : "unknown";
        const activeTag = entry.is_active ? " • active" : "";
        const artifacts = entry.artifacts || {};
        const bits = [];
        if (artifacts.best_pt) bits.push("best.pt");
        if (artifacts.metrics_json) bits.push("metrics.json");
        if (artifacts.metrics_series) bits.push("metrics_series.json");
        if (artifacts.results_csv) bits.push("results.csv");
        if (artifacts.args_yaml) bits.push("args.yaml");
        if (artifacts.labelmap) bits.push("labelmap.txt");
        const artifactText = bits.length ? bits.join(", ") : "no artifacts";
        yoloTrainElements.runSummary.textContent = `${datasetLabel} • created ${created}${activeTag} • ${artifactText}`;
    }

    function populateYoloRunSelect() {
        const select = yoloTrainElements.runSelect;
        if (!select) {
            return;
        }
        select.innerHTML = "";
        if (!yoloRunState.items.length) {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "No runs available";
            select.appendChild(option);
            select.disabled = true;
        } else {
            yoloRunState.items.forEach((entry) => {
                const option = document.createElement("option");
                option.value = entry.run_id || "";
                const label = entry.run_name || entry.run_id;
                const activeTag = entry.is_active ? " (active)" : "";
                const status = entry.status ? ` • ${entry.status}` : "";
                option.textContent = `${label}${activeTag}${status}`;
                select.appendChild(option);
            });
            const activeRun = yoloRunState.items.find((entry) => entry.is_active);
            if (activeRun) {
                yoloRunState.selectedId = activeRun.run_id;
                yoloRunState.activeId = activeRun.run_id;
            } else if (!yoloRunState.selectedId || !yoloRunState.items.some((entry) => entry.run_id === yoloRunState.selectedId)) {
                yoloRunState.selectedId = yoloRunState.items[0].run_id;
            }
            select.disabled = false;
            select.value = yoloRunState.selectedId;
        }
        updateYoloRunSummary();
    }

    function getSelectedRfDetrRun() {
        const id = rfdetrRunState.selectedId;
        if (!id) {
            return null;
        }
        return rfdetrRunState.items.find((entry) => entry.run_id === id) || null;
    }

    function updateRfDetrRunSummary() {
        if (!rfdetrTrainElements.runSummary) {
            return;
        }
        const entry = getSelectedRfDetrRun();
        if (!entry) {
            rfdetrTrainElements.runSummary.textContent = "No runs yet.";
            return;
        }
        const datasetLabel = entry.dataset_label ? `dataset: ${entry.dataset_label}` : "dataset: unknown";
        const created = entry.created_at ? new Date(entry.created_at * 1000).toLocaleString() : "unknown";
        const activeTag = entry.is_active ? " • active" : "";
        const artifacts = entry.artifacts || {};
        const bits = [];
        if (artifacts.best_total) bits.push("checkpoint_best_total.pth");
        if (artifacts.best_ema) bits.push("checkpoint_best_ema.pth");
        if (artifacts.best_regular) bits.push("checkpoint_best_regular.pth");
        if (artifacts.results_json) bits.push("results.json");
        if (artifacts.metrics_series) bits.push("metrics_series.json");
        if (artifacts.log_txt) bits.push("log.txt");
        if (artifacts.labelmap) bits.push("labelmap.txt");
        const artifactText = bits.length ? bits.join(", ") : "no artifacts";
        rfdetrTrainElements.runSummary.textContent = `${datasetLabel} • created ${created}${activeTag} • ${artifactText}`;
    }

    async function fetchDetectorRunSummary(mode, runId) {
        const cache = detectorRunSummaryCache[mode];
        if (!runId || !cache) {
            return null;
        }
        if (cache.has(runId)) {
            return cache.get(runId);
        }
        const endpoint = mode === "yolo" ? "yolo" : "rfdetr";
        try {
            const resp = await fetch(`${API_ROOT}/${endpoint}/runs/${encodeURIComponent(runId)}/summary`);
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            cache.set(runId, data);
            return data;
        } catch (err) {
            console.warn("Detector summary fetch failed", err);
            return null;
        }
    }

    function formatMetricValue(value) {
        if (typeof value !== "number" || !Number.isFinite(value)) {
            return "n/a";
        }
        return value.toFixed(3);
    }

    function formatLabelmapPreview(labelmap) {
        if (!Array.isArray(labelmap) || !labelmap.length) {
            return "Labelmap: missing";
        }
        const preview = labelmap.slice(0, 8).join(", ");
        const extra = labelmap.length > 8 ? ` +${labelmap.length - 8} more` : "";
        return `Labelmap (${labelmap.length}): ${preview}${extra}`;
    }

    async function updateDetectorRunSummary(mode) {
        const isYolo = mode === "yolo";
        const entry = isYolo ? getSelectedYoloRun() : getSelectedRfDetrRun();
        const summaryEl = isYolo ? detectorElements.yoloSummary : detectorElements.rfdetrSummary;
        const metricsEl = isYolo ? detectorElements.yoloMetrics : detectorElements.rfdetrMetrics;
        const labelmapEl = isYolo ? detectorElements.yoloLabelmap : detectorElements.rfdetrLabelmap;
        if (!summaryEl || !metricsEl || !labelmapEl) {
            return;
        }
        if (!entry) {
            summaryEl.textContent = "No runs available.";
            metricsEl.textContent = "";
            labelmapEl.textContent = "";
            return;
        }
        const datasetLabel = entry.dataset_label ? `dataset: ${entry.dataset_label}` : "dataset: unknown";
        const created = entry.created_at ? new Date(entry.created_at * 1000).toLocaleString() : "unknown";
        const activeTag = entry.is_active ? " • active" : "";
        summaryEl.textContent = `${datasetLabel} • created ${created}${activeTag}`;
        metricsEl.textContent = "Metrics: loading…";
        labelmapEl.textContent = "Labelmap: loading…";
        const summary = await fetchDetectorRunSummary(mode, entry.run_id);
        if (summary && summary.metrics && typeof summary.metrics === "object") {
            const metrics = summary.metrics || {};
            const parts = [];
            if (metrics.map50_95 !== undefined) parts.push(`mAP50-95 ${formatMetricValue(metrics.map50_95)}`);
            if (metrics.map50 !== undefined) parts.push(`mAP50 ${formatMetricValue(metrics.map50)}`);
            if (metrics.map !== undefined) parts.push(`mAP ${formatMetricValue(metrics.map)}`);
            if (metrics.map75 !== undefined) parts.push(`mAP75 ${formatMetricValue(metrics.map75)}`);
            if (metrics.precision !== undefined) parts.push(`P ${formatMetricValue(metrics.precision)}`);
            if (metrics.recall !== undefined) parts.push(`R ${formatMetricValue(metrics.recall)}`);
            metricsEl.textContent = parts.length ? `Metrics: ${parts.join(" • ")}` : "Metrics: unavailable";
        } else {
            metricsEl.textContent = "Metrics: unavailable";
        }
        labelmapEl.textContent = formatLabelmapPreview(summary?.labelmap);
    }

    function populateDetectorRunSelect(mode) {
        const isYolo = mode === "yolo";
        const select = isYolo ? detectorElements.yoloSelect : detectorElements.rfdetrSelect;
        const state = isYolo ? yoloRunState : rfdetrRunState;
        if (!select) {
            return;
        }
        select.innerHTML = "";
        if (!state.items.length) {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "No runs available";
            select.appendChild(option);
            select.disabled = true;
        } else {
            state.items.forEach((entry) => {
                const option = document.createElement("option");
                option.value = entry.run_id || "";
                const label = entry.run_name || entry.run_id;
                const datasetTag = entry.dataset_label ? ` • ${entry.dataset_label}` : "";
                const activeTag = entry.is_active ? " (active)" : "";
                option.textContent = `${label}${datasetTag}${activeTag}`;
                select.appendChild(option);
            });
            const activeRun = state.items.find((entry) => entry.is_active);
            if (activeRun) {
                state.selectedId = activeRun.run_id;
                state.activeId = activeRun.run_id;
            } else if (!state.selectedId || !state.items.some((entry) => entry.run_id === state.selectedId)) {
                state.selectedId = state.items[0].run_id;
            }
            select.disabled = false;
            select.value = state.selectedId || "";
        }
        updateDetectorRunSummary(mode).catch((err) => console.warn("Detector summary update failed", err));
    }

    function populateRfDetrRunSelect() {
        const select = rfdetrTrainElements.runSelect;
        if (!select) {
            return;
        }
        select.innerHTML = "";
        if (!rfdetrRunState.items.length) {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "No runs available";
            select.appendChild(option);
            select.disabled = true;
        } else {
            rfdetrRunState.items.forEach((entry) => {
                const option = document.createElement("option");
                option.value = entry.run_id || "";
                const label = entry.run_name || entry.run_id;
                const activeTag = entry.is_active ? " (active)" : "";
                const status = entry.status ? ` • ${entry.status}` : "";
                option.textContent = `${label}${activeTag}${status}`;
                select.appendChild(option);
            });
            const activeRun = rfdetrRunState.items.find((entry) => entry.is_active);
            if (activeRun) {
                rfdetrRunState.selectedId = activeRun.run_id;
                rfdetrRunState.activeId = activeRun.run_id;
            } else if (!rfdetrRunState.selectedId || !rfdetrRunState.items.some((entry) => entry.run_id === rfdetrRunState.selectedId)) {
                rfdetrRunState.selectedId = rfdetrRunState.items[0].run_id;
            }
            select.disabled = false;
            select.value = rfdetrRunState.selectedId;
        }
        updateRfDetrRunSummary();
    }

    async function loadRfDetrRunList(force = false) {
        if (!force && rfdetrRunState.items.length) {
            populateRfDetrRunSelect();
            populateDetectorRunSelect("rfdetr");
            return rfdetrRunState.items;
        }
        if (force) {
            detectorRunSummaryCache.rfdetr.clear();
        }
        try {
            const resp = await fetch(`${API_ROOT}/rfdetr/runs`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const data = await resp.json();
            rfdetrRunState.items = Array.isArray(data) ? data : [];
            populateRfDetrRunSelect();
            populateDetectorRunSelect("rfdetr");
            return rfdetrRunState.items;
        } catch (error) {
            if (rfdetrTrainElements.runSummary) {
                rfdetrTrainElements.runSummary.textContent = `Unable to load runs: ${error.message || error}`;
            }
            return [];
        }
    }

    async function loadYoloRunList(force = false) {
        if (!force && yoloRunState.items.length) {
            populateYoloRunSelect();
            populateDetectorRunSelect("yolo");
            return yoloRunState.items;
        }
        if (force) {
            detectorRunSummaryCache.yolo.clear();
        }
        try {
            const resp = await fetch(`${API_ROOT}/yolo/runs`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const data = await resp.json();
            yoloRunState.items = Array.isArray(data) ? data : [];
            populateYoloRunSelect();
            populateDetectorRunSelect("yolo");
            return yoloRunState.items;
        } catch (error) {
            if (yoloTrainElements.runSummary) {
                yoloTrainElements.runSummary.textContent = `Unable to load runs: ${error.message || error}`;
            }
            return [];
        }
    }

    async function downloadYoloRun() {
        const entry = getSelectedYoloRun();
        if (!entry) {
            setYoloTrainMessage("Select a run to download.", "warn");
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/yolo/runs/${encodeURIComponent(entry.run_id)}/download`);
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            const blob = await resp.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${entry.run_name || entry.run_id}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (error) {
            console.error("YOLO run download failed", error);
            setYoloTrainMessage(error.message || "Failed to download run", "error");
        }
    }

    async function setActiveYoloRun() {
        const entry = getSelectedYoloRun();
        if (!entry) {
            setYoloTrainMessage("Select a run to activate.", "warn");
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/yolo/active`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ run_id: entry.run_id }),
            });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            setYoloTrainMessage("Active YOLO run updated.", "success");
            await loadYoloRunList(true);
        } catch (error) {
            console.error("YOLO run activate failed", error);
            setYoloTrainMessage(error.message || "Failed to activate run", "error");
        }
    }

    async function deleteYoloRun() {
        const entry = getSelectedYoloRun();
        if (!entry) {
            setYoloTrainMessage("Select a run to delete.", "warn");
            return;
        }
        if (!window.confirm(`Delete YOLO run "${entry.run_name || entry.run_id}"? This cannot be undone.`)) {
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/yolo/runs/${encodeURIComponent(entry.run_id)}`, { method: "DELETE" });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            setYoloTrainMessage("Run deleted.", "success");
            yoloRunState.selectedId = null;
            await loadYoloRunList(true);
        } catch (error) {
            console.error("YOLO run delete failed", error);
            setYoloTrainMessage(error.message || "Failed to delete run", "error");
        }
    }

    async function downloadRfDetrRun() {
        const entry = getSelectedRfDetrRun();
        if (!entry) {
            setRfDetrTrainMessage("Select a run to download.", "warn");
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/rfdetr/runs/${encodeURIComponent(entry.run_id)}/download`);
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            const blob = await resp.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${entry.run_name || entry.run_id}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (error) {
            console.error("RF-DETR run download failed", error);
            setRfDetrTrainMessage(error.message || "Failed to download run", "error");
        }
    }

    async function setActiveRfDetrRun() {
        const entry = getSelectedRfDetrRun();
        if (!entry) {
            setRfDetrTrainMessage("Select a run to activate.", "warn");
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/rfdetr/active`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ run_id: entry.run_id }),
            });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            setRfDetrTrainMessage("Active RF-DETR run updated.", "success");
            await loadRfDetrRunList(true);
        } catch (error) {
            console.error("RF-DETR run activate failed", error);
            setRfDetrTrainMessage(error.message || "Failed to activate run", "error");
        }
    }

    async function deleteRfDetrRun() {
        const entry = getSelectedRfDetrRun();
        if (!entry) {
            setRfDetrTrainMessage("Select a run to delete.", "warn");
            return;
        }
        if (!window.confirm(`Delete RF-DETR run "${entry.run_name || entry.run_id}"? This cannot be undone.`)) {
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/rfdetr/runs/${encodeURIComponent(entry.run_id)}`, { method: "DELETE" });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            setRfDetrTrainMessage("Run deleted.", "success");
            rfdetrRunState.selectedId = null;
            await loadRfDetrRunList(true);
        } catch (error) {
            console.error("RF-DETR run delete failed", error);
            setRfDetrTrainMessage(error.message || "Failed to delete run", "error");
        }
    }

    function setDetectorRunMessage(mode, text, variant = null) {
        const target = mode === "yolo" ? detectorElements.yoloMessage : detectorElements.rfdetrMessage;
        if (!target) {
            return;
        }
        target.textContent = text || "";
        target.classList.remove("error", "warn", "success");
        if (variant) {
            target.classList.add(variant);
        }
    }

    async function setActiveDetectorRun(mode) {
        const entry = mode === "yolo" ? getSelectedYoloRun() : getSelectedRfDetrRun();
        if (!entry) {
            setDetectorRunMessage(mode, "Select a run to activate.", "warn");
            return;
        }
        const endpoint = mode === "yolo" ? "yolo" : "rfdetr";
        try {
            const resp = await fetch(`${API_ROOT}/${endpoint}/active`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ run_id: entry.run_id }),
            });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            setDetectorRunMessage(mode, "Active run updated.", "success");
            await refreshDetectorStatus();
            await (mode === "yolo" ? loadYoloRunList(true) : loadRfDetrRunList(true));
        } catch (error) {
            console.error("Detector run activate failed", error);
            setDetectorRunMessage(mode, error.message || "Failed to activate run", "error");
        }
    }

    async function downloadDetectorRun(mode) {
        const entry = mode === "yolo" ? getSelectedYoloRun() : getSelectedRfDetrRun();
        if (!entry) {
            setDetectorRunMessage(mode, "Select a run to download.", "warn");
            return;
        }
        const endpoint = mode === "yolo" ? "yolo" : "rfdetr";
        try {
            const resp = await fetch(`${API_ROOT}/${endpoint}/runs/${encodeURIComponent(entry.run_id)}/download`);
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            const blob = await resp.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${entry.run_name || entry.run_id}.zip`;
            document.body.appendChild(a);
            a.click();
            document.body.removeChild(a);
            URL.revokeObjectURL(url);
        } catch (error) {
            console.error("Detector run download failed", error);
            setDetectorRunMessage(mode, error.message || "Failed to download run", "error");
        }
    }

    async function deleteDetectorRun(mode) {
        const entry = mode === "yolo" ? getSelectedYoloRun() : getSelectedRfDetrRun();
        if (!entry) {
            setDetectorRunMessage(mode, "Select a run to delete.", "warn");
            return;
        }
        const label = entry.run_name || entry.run_id;
        if (!window.confirm(`Delete ${mode.toUpperCase()} run "${label}"? This cannot be undone.`)) {
            return;
        }
        const endpoint = mode === "yolo" ? "yolo" : "rfdetr";
        try {
            const resp = await fetch(`${API_ROOT}/${endpoint}/runs/${encodeURIComponent(entry.run_id)}`, { method: "DELETE" });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            setDetectorRunMessage(mode, "Run deleted.", "success");
            if (mode === "yolo") {
                yoloRunState.selectedId = null;
                await loadYoloRunList(true);
            } else {
                rfdetrRunState.selectedId = null;
                await loadRfDetrRunList(true);
            }
        } catch (error) {
            console.error("Detector run delete failed", error);
            setDetectorRunMessage(mode, error.message || "Failed to delete run", "error");
        }
    }

    function setYoloTrainMessage(text, variant = null) {
        if (!yoloTrainElements.message) {
            return;
        }
        yoloTrainElements.message.textContent = text || "";
        yoloTrainElements.message.classList.remove("error", "warn", "success");
        if (variant) {
            yoloTrainElements.message.classList.add(variant);
        }
    }

    function setRfDetrTrainMessage(text, variant = null) {
        if (!rfdetrTrainElements.message) {
            return;
        }
        rfdetrTrainElements.message.textContent = text || "";
        rfdetrTrainElements.message.classList.remove("error", "warn", "success");
        if (variant) {
            rfdetrTrainElements.message.classList.add(variant);
        }
    }

    function parseYoloNumber(value, { integer = false } = {}) {
        if (value === null || value === undefined || value === "") {
            return null;
        }
        const parsed = integer ? parseInt(value, 10) : parseFloat(value);
        return Number.isFinite(parsed) ? parsed : null;
    }

    function parseYoloDevices(raw) {
        if (!raw) {
            return null;
        }
        const tokens = String(raw)
            .split(/[,\\s]+/)
            .map((part) => part.trim())
            .filter(Boolean);
        const devices = tokens
            .map((token) => parseInt(token, 10))
            .filter((val) => Number.isFinite(val));
        return devices.length ? devices : null;
    }

    function buildYoloAugmentations() {
        const mapping = {
            flip_lr: yoloTrainElements.augFlipLR,
            flip_ud: yoloTrainElements.augFlipUD,
            hsv_h: yoloTrainElements.augHsvH,
            hsv_s: yoloTrainElements.augHsvS,
            hsv_v: yoloTrainElements.augHsvV,
            mosaic: yoloTrainElements.augMosaic,
            mixup: yoloTrainElements.augMixup,
            copy_paste: yoloTrainElements.augCopyPaste,
            scale: yoloTrainElements.augScale,
            translate: yoloTrainElements.augTranslate,
            degrees: yoloTrainElements.augDegrees,
        };
        const payload = {};
        Object.entries(mapping).forEach(([key, input]) => {
            if (!input) {
                return;
            }
            const value = parseYoloNumber(input.value);
            if (value === null) {
                return;
            }
            payload[key] = value;
        });
        return Object.keys(payload).length ? payload : null;
    }

    function resolveYoloVariantId() {
        const task = yoloTrainElements.taskSelect?.value || "detect";
        const scale = (yoloTrainElements.scaleSelect?.value || "n").trim().toLowerCase();
        const headType = yoloTrainElements.headTypeSelect?.value || "standard";
        let model = `yolov8${scale}`;
        if (task === "segment") {
            return `${model}-seg`;
        }
        if (headType === "p2") {
            return `${model}-p2`;
        }
        return model;
    }

    function updateYoloVariantSummary() {
        const task = yoloTrainElements.taskSelect?.value || "detect";
        const headTypeSelect = yoloTrainElements.headTypeSelect;
        const baseWeightsInput = yoloTrainElements.baseWeightsInput;
        const fromScratchToggle = yoloTrainElements.fromScratchToggle;
        if (headTypeSelect) {
            if (task === "segment") {
                yoloTrainState.lastHeadType = headTypeSelect.value || yoloTrainState.lastHeadType;
                headTypeSelect.value = "standard";
                headTypeSelect.disabled = true;
            } else {
                headTypeSelect.disabled = false;
                if (headTypeSelect.value !== yoloTrainState.lastHeadType) {
                    headTypeSelect.value = yoloTrainState.lastHeadType || "standard";
                }
            }
        }
        const variant = resolveYoloVariantId();
        if (yoloTrainElements.variantResolved) {
            yoloTrainElements.variantResolved.value = variant;
        }
        if (yoloTrainElements.variantHelp) {
            const headType = headTypeSelect?.value || "standard";
            if (task === "segment") {
                yoloTrainElements.variantHelp.textContent = "Segmentation uses the YOLOv8 -seg weights for the selected scale.";
            } else if (headType === "p2") {
                yoloTrainElements.variantHelp.textContent = "P2 uses a custom head for small objects and no official pretrained weights. Supply base weights or it will train from scratch.";
            } else {
                yoloTrainElements.variantHelp.textContent = "Standard YOLOv8 weights are available for common scales (n/s/m/l/x).";
            }
        }
        if (baseWeightsInput && fromScratchToggle) {
            const headType = headTypeSelect?.value || "standard";
            const hasBaseWeights = !!baseWeightsInput.value.trim();
            if (headType === "p2" && !hasBaseWeights) {
                if (!fromScratchToggle.checked) {
                    fromScratchToggle.checked = true;
                }
                fromScratchToggle.disabled = true;
                yoloTrainState.autoScratchForced = true;
            } else {
                if (yoloTrainState.autoScratchForced && fromScratchToggle.checked && hasBaseWeights) {
                    fromScratchToggle.checked = false;
                }
                fromScratchToggle.disabled = false;
                yoloTrainState.autoScratchForced = false;
            }
            const disableBaseWeights = fromScratchToggle.checked && headType !== "p2";
            baseWeightsInput.disabled = disableBaseWeights;
            if (disableBaseWeights) {
                baseWeightsInput.value = "";
            }
        }
    }

    function buildYoloTrainingPayload() {
        const datasetId = yoloDatasetState.selectedId;
        if (!datasetId) {
            return { error: "Select a dataset first." };
        }
        const fromScratch = !!yoloTrainElements.fromScratchToggle?.checked;
        const baseWeightsRaw = yoloTrainElements.baseWeightsInput?.value?.trim() || "";
        const payload = {
            dataset_id: datasetId,
            run_name: yoloTrainElements.runNameInput?.value?.trim() || null,
            task: yoloTrainElements.taskSelect?.value || "detect",
            variant: resolveYoloVariantId(),
            from_scratch: fromScratch,
            base_weights: fromScratch ? null : baseWeightsRaw || null,
            epochs: parseYoloNumber(yoloTrainElements.epochsInput?.value, { integer: true }),
            img_size: parseYoloNumber(yoloTrainElements.imgSizeInput?.value, { integer: true }),
            batch: parseYoloNumber(yoloTrainElements.batchInput?.value, { integer: true }),
            workers: parseYoloNumber(yoloTrainElements.workersInput?.value, { integer: true }),
            devices: parseYoloDevices(yoloTrainElements.devicesInput?.value),
            seed: parseYoloNumber(yoloTrainElements.seedInput?.value, { integer: true }),
            augmentations: buildYoloAugmentations(),
            accept_tos: !!yoloTrainElements.acceptTos?.checked,
        };
        return payload;
    }

    function populateRfDetrVariantSelect() {
        const select = rfdetrTrainElements.variantSelect;
        if (!select) {
            return;
        }
        select.innerHTML = "";
        const task = rfdetrTrainElements.taskSelect?.value || "detect";
        const variants = rfdetrTrainState.variants.filter((entry) => entry.task === task);
        if (!variants.length) {
            const option = document.createElement("option");
            option.value = "";
            option.textContent = "No variants available";
            select.appendChild(option);
            select.disabled = true;
        } else {
            variants.forEach((entry) => {
                const option = document.createElement("option");
                option.value = entry.id;
                option.textContent = entry.label || entry.id;
                select.appendChild(option);
            });
            if (!select.value || !variants.some((entry) => entry.id === select.value)) {
                select.value = variants[0].id;
            }
            select.disabled = false;
        }
        if (rfdetrTrainElements.variantHelp) {
            rfdetrTrainElements.variantHelp.textContent = task === "segment"
                ? "Segmentation uses the RF-DETR seg-preview variant."
                : "Choose a model size. Larger variants are slower and need more VRAM.";
        }
    }

    async function loadRfDetrVariants(force = false) {
        if (!force && rfdetrTrainState.variants.length) {
            populateRfDetrVariantSelect();
            return rfdetrTrainState.variants;
        }
        try {
            const resp = await fetch(`${API_ROOT}/rfdetr/variants`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const data = await resp.json();
            rfdetrTrainState.variants = Array.isArray(data) ? data : [];
            populateRfDetrVariantSelect();
            return rfdetrTrainState.variants;
        } catch (error) {
            console.error("Failed to load RF-DETR variants", error);
            if (rfdetrTrainElements.variantHelp) {
                rfdetrTrainElements.variantHelp.textContent = `Unable to load variants: ${error.message || error}`;
            }
            return [];
        }
    }

    function updateRfDetrScaleToggles() {
        if (!rfdetrTrainElements.expandedScalesToggle) {
            return;
        }
        const enabled = !!rfdetrTrainElements.multiScaleToggle?.checked;
        rfdetrTrainElements.expandedScalesToggle.disabled = !enabled;
        if (!enabled) {
            rfdetrTrainElements.expandedScalesToggle.checked = false;
        }
    }

    function buildRfDetrTrainingPayload() {
        const datasetId = rfdetrDatasetState.selectedId;
        if (!datasetId) {
            return { error: "Select a dataset first." };
        }
        const fromScratch = !!rfdetrTrainElements.fromScratchToggle?.checked;
        const pretrainRaw = rfdetrTrainElements.pretrainInput?.value?.trim() || "";
        const augmentations = {
            hsv_h: parseYoloNumber(rfdetrTrainElements.augHsvH?.value),
            hsv_s: parseYoloNumber(rfdetrTrainElements.augHsvS?.value),
            hsv_v: parseYoloNumber(rfdetrTrainElements.augHsvV?.value),
            blur_prob: parseYoloNumber(rfdetrTrainElements.augBlurProb?.value),
            blur_kernel: parseYoloNumber(rfdetrTrainElements.augBlurKernel?.value, { integer: true }),
            gray_prob: parseYoloNumber(rfdetrTrainElements.augGrayProb?.value),
        };
        const payload = {
            dataset_id: datasetId,
            run_name: rfdetrTrainElements.runNameInput?.value?.trim() || null,
            task: rfdetrTrainElements.taskSelect?.value || "detect",
            variant: rfdetrTrainElements.variantSelect?.value || null,
            epochs: parseYoloNumber(rfdetrTrainElements.epochsInput?.value, { integer: true }),
            batch: parseYoloNumber(rfdetrTrainElements.batchInput?.value, { integer: true }),
            grad_accum: parseYoloNumber(rfdetrTrainElements.gradAccumInput?.value, { integer: true }),
            workers: parseYoloNumber(rfdetrTrainElements.workersInput?.value, { integer: true }),
            devices: parseYoloDevices(rfdetrTrainElements.devicesInput?.value),
            seed: parseYoloNumber(rfdetrTrainElements.seedInput?.value, { integer: true }),
            resolution: parseYoloNumber(rfdetrTrainElements.resolutionInput?.value, { integer: true }),
            from_scratch: fromScratch,
            pretrain_weights: fromScratch ? null : pretrainRaw || null,
            augmentations,
            multi_scale: rfdetrTrainElements.multiScaleToggle ? !!rfdetrTrainElements.multiScaleToggle.checked : null,
            expanded_scales: rfdetrTrainElements.expandedScalesToggle ? !!rfdetrTrainElements.expandedScalesToggle.checked : null,
            use_ema: !!rfdetrTrainElements.useEmaToggle?.checked,
            early_stopping: !!rfdetrTrainElements.earlyStopToggle?.checked,
            early_stopping_patience: parseYoloNumber(rfdetrTrainElements.earlyStopPatienceInput?.value, { integer: true }),
            accept_tos: !!rfdetrTrainElements.acceptTos?.checked,
        };
        return payload;
    }

    async function handleQwenDatasetDelete() {
        const entry = getSelectedQwenDataset();
        if (!entry) {
            setQwenTrainMessage("Select a cached dataset to delete.", "warn");
            return;
        }
        if (!window.confirm(`Delete cached dataset "${entry.label}"? This cannot be undone.`)) {
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/qwen/datasets/${encodeURIComponent(entry.id)}`, {
                method: "DELETE",
            });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            setQwenTrainMessage(`Deleted cached dataset "${entry.label}".`, "success");
            qwenDatasetState.selectedId = null;
            await loadQwenDatasetList(true);
        } catch (error) {
            console.error("Failed to delete Qwen dataset", error);
            setQwenTrainMessage(error.message || "Failed to delete dataset", "error");
        }
    }

    function formatBytes(bytes, digits = 1) {
        if (!Number.isFinite(bytes) || bytes <= 0) {
            return "0 B";
        }
        const units = ["B", "KB", "MB", "GB", "TB"];
        let value = bytes;
        let unitIndex = 0;
        while (value >= 1024 && unitIndex < units.length - 1) {
            value /= 1024;
            unitIndex += 1;
        }
        const precision = value >= 100 ? 0 : digits;
        return `${value.toFixed(precision)} ${units[unitIndex]}`;
    }

    function formatDurationPrecise(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) {
            return "0s";
        }
        const totalSeconds = Math.floor(seconds);
        const mins = Math.floor(totalSeconds / 60);
        const hrs = Math.floor(mins / 60);
        const secs = totalSeconds % 60;
        const minutesPart = mins % 60;
        const parts = [];
        if (hrs > 0) {
            parts.push(`${hrs}h`);
        }
        if (minutesPart > 0 || hrs > 0) {
            parts.push(`${minutesPart}m`);
        }
        parts.push(`${secs}s`);
        return parts.join(" ");
    }

    function describeDurationRange(seconds) {
        if (!Number.isFinite(seconds) || seconds <= 0) {
            return "under a minute";
        }
        if (seconds < 60) {
            return "under a minute";
        }
        if (seconds < 180) {
            return "a few minutes";
        }
        if (seconds < 3600) {
            const mins = Math.round(seconds / 60);
            return `${mins} minute${mins === 1 ? "" : "s"}`;
        }
        const hours = seconds / 3600;
        if (hours < 10) {
            return `${hours.toFixed(1)} hours`;
        }
        return `${Math.round(hours)} hours`;
    }

    function renderConvergenceTable(trace) {
        if (!Array.isArray(trace) || !trace.length) {
            return "";
        }
        const slice = trace.slice(-200);
        const header = `
            <tr>
                <th>Iter</th>
                <th>Train Loss</th>
                <th>Train Acc</th>
                <th>Val Loss</th>
                <th>Val Acc</th>
                <th>|Δw|</th>
            </tr>`;
        const rows = slice.map((entry) => {
            const iterRaw = entry.iteration ?? entry.iter ?? "";
            const iter = escapeHtml(String(iterRaw));
            const trainLoss = escapeHtml(formatNumber(entry.train_loss));
            const trainAcc = escapeHtml(formatNumber(entry.train_accuracy, 3));
            const valLoss = escapeHtml(formatNumber(entry.val_loss));
            const valAcc = escapeHtml(formatNumber(entry.val_accuracy, 3));
            const coefDelta = escapeHtml(formatNumber(entry.coef_delta));
            return `<tr>
                <td>${iter}</td>
                <td>${trainLoss}</td>
                <td>${trainAcc}</td>
                <td>${valLoss}</td>
                <td>${valAcc}</td>
                <td>${coefDelta}</td>
            </tr>`;
        }).join("");
        const note = slice.length < trace.length ? `<div class="training-convergence-note">Showing last ${slice.length} of ${trace.length} iterations.</div>` : "";
        return `<div class="training-convergence"><h4>Solver Progress</h4>${note}<table>${header}${rows}</table></div>`;
    }

    function renderPerClassMetrics(metrics) {
        if (!Array.isArray(metrics) || !metrics.length) {
            return "";
        }
        const rows = metrics.map((entry) => {
            const label = escapeHtml(String(entry.label ?? "class"));
            const precision = Number.isFinite(entry.precision) ? entry.precision * 100 : null;
            const recall = Number.isFinite(entry.recall) ? entry.recall * 100 : null;
            const f1 = Number.isFinite(entry.f1) ? entry.f1 * 100 : null;
            const support = Number.isFinite(entry.support) ? parseInt(entry.support, 10) : null;

            const precisionBar = precision !== null
                ? `<div class="metric-bar-track"><div class="metric-bar-fill precision" style="width:${Math.max(0, Math.min(100, precision)).toFixed(1)}%"></div></div><span class="metric-value">${precision.toFixed(1)}%</span>`
                : `<span class="metric-value">—</span>`;
            const recallBar = recall !== null
                ? `<div class="metric-bar-track"><div class="metric-bar-fill recall" style="width:${Math.max(0, Math.min(100, recall)).toFixed(1)}%"></div></div><span class="metric-value">${recall.toFixed(1)}%</span>`
                : `<span class="metric-value">—</span>`;
            const f1Bar = f1 !== null
                ? `<div class="metric-bar-track"><div class="metric-bar-fill f1" style="width:${Math.max(0, Math.min(100, f1)).toFixed(1)}%"></div></div><span class="metric-value">${f1.toFixed(1)}%</span>`
                : `<span class="metric-value">—</span>`;

            return `<div class="metric-row">
                <div class="metric-label">${label}</div>
                <div class="metric-measure">
                    <span class="metric-tag">P</span>
                    ${precisionBar}
                </div>
                <div class="metric-measure">
                    <span class="metric-tag">R</span>
                    ${recallBar}
                </div>
                <div class="metric-measure">
                    <span class="metric-tag">F1</span>
                    ${f1Bar}
                </div>
                <div class="metric-support">n=${support !== null ? escapeHtml(String(support)) : "—"}</div>
            </div>`;
        }).join("");

        const chart = renderPerClassMetricChart(metrics);
        const glossary = renderMetricGlossary();

        return `<div class="per-class-metrics"><h4>Per-class Metrics</h4><div class="metric-rows">${rows}</div>${chart}${glossary}</div>`;
    }

    function renderPerClassMetricChart(metrics) {
        if (!Array.isArray(metrics) || !metrics.length) {
            return "";
        }

        const columns = metrics.map((entry) => {
            const label = escapeHtml(String(entry.label ?? "class"));
            const precision = Number.isFinite(entry.precision) ? Math.max(0, Math.min(100, entry.precision * 100)) : null;
            const recall = Number.isFinite(entry.recall) ? Math.max(0, Math.min(100, entry.recall * 100)) : null;
            const f1 = Number.isFinite(entry.f1) ? Math.max(0, Math.min(100, entry.f1 * 100)) : null;

            const precisionBar = precision === null
                ? '<div class="metric-chart-bar precision empty"></div>'
                : `<div class="metric-chart-bar precision" style="height:${precision.toFixed(1)}%" title="Precision: ${precision.toFixed(1)}%"></div>`;
            const recallBar = recall === null
                ? '<div class="metric-chart-bar recall empty"></div>'
                : `<div class="metric-chart-bar recall" style="height:${recall.toFixed(1)}%" title="Recall: ${recall.toFixed(1)}%"></div>`;
            const f1Bar = f1 === null
                ? '<div class="metric-chart-bar f1 empty"></div>'
                : `<div class="metric-chart-bar f1" style="height:${f1.toFixed(1)}%" title="F1: ${f1.toFixed(1)}%"></div>`;

            return `<div class="metric-chart-column">
                <div class="metric-chart-bars">
                    ${precisionBar}
                    ${recallBar}
                    ${f1Bar}
                </div>
                <div class="metric-chart-class" title="${label}">${label}</div>
            </div>`;
        }).join("");

        return `<div class="metric-chart">
            <h4>Per-class Score Chart</h4>
            <div class="metric-chart-grid">${columns}</div>
            <div class="metric-chart-legend">
                <div class="metric-chart-legend-item"><span class="legend-swatch precision"></span>Precision</div>
                <div class="metric-chart-legend-item"><span class="legend-swatch recall"></span>Recall</div>
                <div class="metric-chart-legend-item"><span class="legend-swatch f1"></span>F1</div>
            </div>
        </div>`;
    }

    function renderMetricGlossary() {
        return `<div class="metric-glossary">
            <strong>Precision</strong> measures how many of the model's positive predictions were correct. 
            <strong>Recall</strong> captures how many true examples the model managed to find. 
            <strong>F1</strong> balances precision and recall in a single score.
        </div>`;
    }

    function setTrainingMessage(text, variant) {
        const el = trainingElements.message;
        if (!el) {
            return;
        }
        el.textContent = text || "";
        el.classList.remove("error", "success", "warn");
        if (variant) {
            el.classList.add(variant);
        }
    }

    function setActiveMessage(text, variant) {
        const el = activeElements.message;
        if (!el) {
            return;
        }
        el.textContent = text || "";
        el.classList.remove("error", "success", "warn");
        if (variant) {
            el.classList.add(variant);
        }
    }

    function getRootFolderName(fileOrPath) {
        if (!fileOrPath) {
            return "";
        }
        const rel = typeof fileOrPath === "string"
            ? fileOrPath
            : fileOrPath.webkitRelativePath || fileOrPath.relativePath || fileOrPath.name;
        if (rel) {
            const parts = rel.split(/[\\/]/).filter(Boolean);
            if (parts.length) {
                return parts[0];
            }
        }
        return typeof fileOrPath === "string" ? fileOrPath : fileOrPath.name;
    }

    function updateFileSummary(inputEl, summaryEl, options = {}) {
        if (!summaryEl) {
            return;
        }
        const entries = Array.isArray(options.entries) ? options.entries : null;
        const files = entries
            ? entries.map((entry) => entry.file || entry)
            : inputEl && inputEl.files
                ? Array.from(inputEl.files)
                : [];
        if (!files.length) {
            summaryEl.textContent = options.emptyText || "No files selected";
            if (summaryEl.textContent) {
                summaryEl.title = summaryEl.textContent;
            } else {
                summaryEl.removeAttribute("title");
            }
            return;
        }
        if (options.mode === "path") {
            const pathText = options.path || "";
            summaryEl.textContent = pathText || (options.emptyText || "No path selected");
            if (summaryEl.textContent) {
                summaryEl.title = summaryEl.textContent;
            } else {
                summaryEl.removeAttribute("title");
            }
            return;
        }
        if (options.mode === "folder") {
            const allowedExts = options.allowedExts;
            const totalCount = typeof options.totalCount === "number" && options.totalCount >= files.length
                ? options.totalCount
                : files.length;
            let validCount;
            if (entries) {
                validCount = entries.length;
            } else if (allowedExts) {
                validCount = files.filter((file) => allowedExts.has((file.name.split(".").pop() || "").toLowerCase())).length;
            } else {
                validCount = files.length;
            }
            const folderName = options.folderName
                || (entries && entries.length
                    ? getRootFolderName(entries[0].relativePath || entries[0].file?.name)
                    : getRootFolderName(files[0]));
            const descriptor = validCount === totalCount
                ? `${validCount} files`
                : `${validCount} of ${totalCount} files`;
            summaryEl.textContent = `${folderName} (${descriptor})`;
            summaryEl.title = summaryEl.textContent;
            return;
        }
        if (files.length === 1) {
            summaryEl.textContent = files[0].name;
            summaryEl.title = summaryEl.textContent;
            return;
        }
        summaryEl.textContent = `${files.length} files selected`;
        summaryEl.title = summaryEl.textContent;
    }

    function stopTrainingPoll() {
        if (trainingState.pollHandle !== null) {
            clearTimeout(trainingState.pollHandle);
            trainingState.pollHandle = null;
        }
    }

    const HAS_DIRECTORY_PICKER = typeof window !== "undefined" && typeof window.showDirectoryPicker === "function";

    function getFileExtension(name) {
        const lower = (name || "").toLowerCase();
        const parts = lower.split(".");
        if (parts.length <= 1) {
            return "";
        }
        return parts.pop() || "";
    }

    async function collectDirectoryEntries(handle, allowedExts) {
        const collected = [];
        let totalCount = 0;

        async function walk(dirHandle, prefix) {
            for await (const entry of dirHandle.values()) {
                if (entry.kind === "file") {
                    totalCount += 1;
                    const file = await entry.getFile();
                    const relativePath = prefix ? `${prefix}/${entry.name}` : entry.name;
                    if (!allowedExts || allowedExts.has(getFileExtension(entry.name))) {
                        collected.push({ file, relativePath });
                    }
                } else if (entry.kind === "directory") {
                    const nextPrefix = prefix ? `${prefix}/${entry.name}` : entry.name;
                    await walk(entry, nextPrefix);
                }
            }
        }

        await walk(handle, "");
        return { entries: collected, totalCount };
    }

    function getStoredEntries(kind) {
        if (kind === "images") {
            if (Array.isArray(trainingState.imageEntries) && trainingState.imageEntries.length) {
                return trainingState.imageEntries.slice();
            }
        } else if (Array.isArray(trainingState.labelEntries) && trainingState.labelEntries.length) {
            return trainingState.labelEntries.slice();
        }
        const input = kind === "images" ? trainingElements.imagesInput : trainingElements.labelsInput;
        const allowed = kind === "images" ? IMAGE_EXTENSIONS : LABEL_EXTENSIONS;
        if (!input || !input.files) {
            return [];
        }
        return Array.from(input.files)
            .filter((file) => allowed.has(getFileExtension(file.name)))
            .map((file) => ({
                file,
                relativePath: file.webkitRelativePath || file.relativePath || file.name,
            }));
    }

    async function handleNativeFolderFallback(kind) {
        // Legacy callers may still reach here; prefer the local hidden file input first.
        const input = kind === "images" ? trainingElements.imagesInput : trainingElements.labelsInput;
        if (input) {
            try {
                if (typeof input.showPicker === "function") {
                    await input.showPicker();
                    return;
                }
                input.click();
                return;
            } catch (err) {
                if (err && (err.name === "AbortError" || err.name === "NotAllowedError")) {
                    setTrainingMessage("Directory selection cancelled.", null);
                    return;
                }
                console.warn("Fallback directory picker failed", err);
            }
        }
        await promptForFolderPath(kind);
    }

    async function promptForFolderPath(kind, reason) {
        if (reason && reason !== 'prompt') {
            setTrainingMessage(`Directory picker unavailable (${reason.message || reason}).`, 'warn');
        }
        const previousPath = kind === "images" ? trainingState.nativeImagesPath : trainingState.nativeLabelsPath;
        const promptLabel = kind === "images" ? "Enter images folder path" : "Enter labels folder path";
        const entered = window.prompt(promptLabel, previousPath || "");
        if (entered === null) {
            setTrainingMessage("Directory selection cancelled.", null);
            return;
        }
        const trimmed = entered.trim();
        if (!trimmed) {
            setTrainingMessage("Folder path cannot be empty.", "error");
            return;
        }
        applyNativeFolderSelection(kind, trimmed);
    }

    function applyNativeFolderSelection(kind, absolutePath) {
        const folderName = getRootFolderName(absolutePath);
        let successText;
        if (kind === "images") {
            trainingState.nativeImagesPath = absolutePath;
            trainingState.imageEntries = [];
            trainingState.imageTotalCount = 0;
            trainingState.imagesFolderName = folderName;
            updateFileSummary(null, trainingElements.imagesSummary, { mode: "path", path: absolutePath, emptyText: "No folder selected" });
            if (trainingElements.imagesSummary) {
                trainingElements.imagesSummary.textContent = absolutePath;
                trainingElements.imagesSummary.title = absolutePath;
            }
            successText = `Using server-side images folder: ${absolutePath}`;
        } else {
            trainingState.nativeLabelsPath = absolutePath;
            trainingState.labelEntries = [];
            trainingState.labelTotalCount = 0;
            trainingState.labelsFolderName = folderName;
            updateFileSummary(null, trainingElements.labelsSummary, { mode: "path", path: absolutePath, emptyText: "No folder selected" });
            if (trainingElements.labelsSummary) {
                trainingElements.labelsSummary.textContent = absolutePath;
                trainingElements.labelsSummary.title = absolutePath;
            }
            successText = `Using server-side labels folder: ${absolutePath}`;
        }
        if (!HAS_DIRECTORY_PICKER && !directoryFallbackWarned) {
            directoryFallbackWarned = true;
            setTrainingMessage("Using the classic folder dialog (expected when opening ybat.html directly).", null);
        }
        if (successText) {
            setTrainingMessage(successText, "success");
        }
    }

    function summariseEntries(kind, entries, totalCount, folderName) {
        if (kind === "images") {
            trainingState.imageEntries = entries;
            trainingState.imageTotalCount = totalCount;
            trainingState.imagesFolderName = folderName;
            trainingState.nativeImagesPath = null;
            updateFileSummary(null, trainingElements.imagesSummary, {
                emptyText: "No folder selected",
                mode: "folder",
                allowedExts: IMAGE_EXTENSIONS,
                entries,
                totalCount,
                folderName,
            });
        } else {
            trainingState.labelEntries = entries;
            trainingState.labelTotalCount = totalCount;
            trainingState.labelsFolderName = folderName;
            trainingState.nativeLabelsPath = null;
            updateFileSummary(null, trainingElements.labelsSummary, {
                emptyText: "No folder selected",
                mode: "folder",
                allowedExts: LABEL_EXTENSIONS,
                entries,
                totalCount,
                folderName,
            });
        }
    }

    async function chooseTrainingFolder(kind) {
        const input = kind === "images" ? trainingElements.imagesInput : trainingElements.labelsInput;
        if (!input) {
            setTrainingMessage("Folder picker unavailable in this browser.", "error");
            return;
        }

        // Prefer the hidden file input with webkitdirectory; works on remote backends and insecure origins.
        try {
            if (typeof input.showPicker === "function") {
                await input.showPicker();
            } else {
                input.click();
            }
        } catch (err) {
            if (err && (err.name === "AbortError" || err.name === "NotAllowedError")) {
                setTrainingMessage("Directory selection cancelled.", null);
                return;
            }
            console.warn("Folder picker failed", err);
            setTrainingMessage("Folder picker blocked by the browser. Please allow file access.", "error");
        }
    }

    function handleImagesInputChange() {
        if (!trainingElements.imagesInput) {
            return;
        }
        const rawFiles = Array.from(trainingElements.imagesInput.files || []);
        if (!rawFiles.length) {
            summariseEntries("images", [], 0, null);
            trainingState.nativeImagesPath = null;
            return;
        }
        const entries = rawFiles
            .filter((file) => IMAGE_EXTENSIONS.has(getFileExtension(file.name)))
            .map((file) => ({
                file,
                relativePath: file.webkitRelativePath || file.relativePath || file.name,
            }));
        summariseEntries("images", entries, rawFiles.length, getRootFolderName(rawFiles[0]));
        trainingState.nativeImagesPath = null;
        if (trainingElements.reuseEmbeddingsCheckbox) {
            trainingElements.reuseEmbeddingsCheckbox.checked = false;
        }
        if (!entries.length) {
            setTrainingMessage("No supported image files found in folder.", "error");
        }
    }

    function handleLabelsInputChange() {
        if (!trainingElements.labelsInput) {
            return;
        }
        const rawFiles = Array.from(trainingElements.labelsInput.files || []);
        if (!rawFiles.length) {
            summariseEntries("labels", [], 0, null);
            trainingState.nativeLabelsPath = null;
            return;
        }
        const entries = rawFiles
            .filter((file) => LABEL_EXTENSIONS.has(getFileExtension(file.name)))
            .map((file) => ({
                file,
                relativePath: file.webkitRelativePath || file.relativePath || file.name,
            }));
        summariseEntries("labels", entries, rawFiles.length, getRootFolderName(rawFiles[0]));
        trainingState.nativeLabelsPath = null;
        if (trainingElements.reuseEmbeddingsCheckbox) {
            trainingElements.reuseEmbeddingsCheckbox.checked = false;
        }
        if (!entries.length) {
            setTrainingMessage("No YOLO label files found in folder.", "error");
        }
    }

    function startTrainingPoll(jobId, immediate = false) {
        stopTrainingPoll();
        trainingState.activeJobId = jobId;
        const poll = () => {
            pollTrainingJob(jobId).catch((err) => {
                console.error("Failed to poll training job", err);
                setTrainingMessage(`Failed to poll training job: ${err.message || err}`, "error");
            });
        };
        if (immediate) {
            poll();
        } else {
            trainingState.pollHandle = setTimeout(poll, 1500);
        }
    }

    function fillSelectOptions(selectEl, options, preferred) {
        if (!selectEl) {
            return;
        }
        const previous = selectEl.value;
        selectEl.innerHTML = "";
        const values = [];
        options.forEach((entry) => {
            const option = document.createElement("option");
            if (entry && typeof entry === "object") {
                option.value = entry.value;
                option.textContent = entry.label || entry.value;
                values.push(entry.value);
            } else {
                option.value = entry;
                option.textContent = entry;
                values.push(entry);
            }
            selectEl.appendChild(option);
        });
        const defaultValue = options.length
            ? (options[0] && typeof options[0] === "object" ? options[0].value : options[0])
            : "";
        const desired = preferred || previous || defaultValue;
        if (desired && values.includes(desired)) {
            selectEl.value = desired;
        }
    }

    const DINOV3_BACKBONES = [
        { value: "facebook/dinov3-vits16-pretrain-lvd1689m", label: "DINOv3 ViT-S/16 (LVD-1689M)" },
        { value: "facebook/dinov3-vits16plus-pretrain-lvd1689m", label: "DINOv3 ViT-S+/16 (LVD-1689M)" },
        { value: "facebook/dinov3-vitb16-pretrain-lvd1689m", label: "DINOv3 ViT-B/16 (LVD-1689M)" },
        { value: "facebook/dinov3-vitl16-pretrain-lvd1689m", label: "DINOv3 ViT-L/16 (LVD-1689M)" },
        { value: "facebook/dinov3-vith16plus-pretrain-lvd1689m", label: "DINOv3 ViT-H+/16 (LVD-1689M)" },
        { value: "facebook/dinov3-vit7b16-pretrain-lvd1689m", label: "DINOv3 ViT-7B/16 (LVD-1689M)" },
        { value: "facebook/dinov3-convnext-tiny-pretrain-lvd1689m", label: "DINOv3 ConvNeXt Tiny (LVD-1689M)" },
        { value: "facebook/dinov3-convnext-small-pretrain-lvd1689m", label: "DINOv3 ConvNeXt Small (LVD-1689M)" },
        { value: "facebook/dinov3-convnext-base-pretrain-lvd1689m", label: "DINOv3 ConvNeXt Base (LVD-1689M)" },
        { value: "facebook/dinov3-convnext-large-pretrain-lvd1689m", label: "DINOv3 ConvNeXt Large (LVD-1689M)" },
        { value: "facebook/dinov3-vitl16-pretrain-sat493m", label: "DINOv3 ViT-L/16 (SAT-493M)" },
        { value: "facebook/dinov3-vit7b16-pretrain-sat493m", label: "DINOv3 ViT-7B/16 (SAT-493M)" },
    ];

    function getTrainingEncoderType() {
        const raw = trainingElements.encoderTypeSelect ? trainingElements.encoderTypeSelect.value : "clip";
        return raw ? String(raw).toLowerCase().trim() : "clip";
    }

    function updateTrainingEncoderControls() {
        const encoderType = getTrainingEncoderType();
        const useClip = encoderType !== "dinov3";
        if (trainingElements.clipBackboneRow) trainingElements.clipBackboneRow.hidden = !useClip;
        if (trainingElements.dinov3BackboneRow) trainingElements.dinov3BackboneRow.hidden = useClip;
        if (trainingElements.clipBackboneSelect) trainingElements.clipBackboneSelect.disabled = !useClip;
        if (trainingElements.dinov3BackboneSelect) trainingElements.dinov3BackboneSelect.disabled = useClip;
    }

    function updateTrainingClassifierControls() {
        const raw = trainingElements.classifierTypeSelect ? trainingElements.classifierTypeSelect.value : "logreg";
        const classifierType = raw ? String(raw).toLowerCase().trim() : "logreg";
        const isMlp = classifierType === "mlp";
        const mlpOnlyFields = document.querySelectorAll(".mlp-only");
        const focalOnlyFields = document.querySelectorAll(".mlp-focal-only");
        const logregOnlyFields = document.querySelectorAll(".logreg-only");
        mlpOnlyFields.forEach((el) => {
            el.hidden = !isMlp;
        });
        const lossTypeRaw = trainingElements.mlpLossTypeSelect ? trainingElements.mlpLossTypeSelect.value : "ce";
        const lossType = lossTypeRaw ? String(lossTypeRaw).toLowerCase().trim() : "ce";
        const showFocal = isMlp && lossType === "focal";
        focalOnlyFields.forEach((el) => {
            el.hidden = !showFocal;
            const controls = el.querySelectorAll("input, select, textarea, button");
            controls.forEach((control) => {
                control.disabled = !showFocal;
            });
        });
        logregOnlyFields.forEach((el) => {
            el.hidden = isMlp;
            const controls = el.querySelectorAll("input, select, textarea, button");
            controls.forEach((control) => {
                control.disabled = isMlp;
            });
        });
        if (trainingElements.solverSelect) {
            trainingElements.solverSelect.disabled = isMlp;
        }
        if (trainingElements.regCInput) {
            trainingElements.regCInput.disabled = isMlp;
        }
        applyRecommendedMlpHiddenSizes(false);
    }

    function updateTrainingHardMiningControls() {
        const enabled = Boolean(trainingElements.hardMiningCheckbox && trainingElements.hardMiningCheckbox.checked);
        const hardFields = document.querySelectorAll(".hard-mining-only");
        hardFields.forEach((el) => {
            el.hidden = !enabled;
            const controls = el.querySelectorAll("input, select, textarea, button");
            controls.forEach((control) => {
                control.disabled = !enabled;
            });
        });
    }

    function updateTrainingClassWeightControls() {
        const mode = trainingElements.classWeightSelect ? trainingElements.classWeightSelect.value : "none";
        const showEffective = String(mode || "").toLowerCase().trim() === "effective";
        if (trainingElements.effectiveBetaInput) {
            const wrapper = trainingElements.effectiveBetaInput.closest("div");
            if (wrapper) {
                wrapper.hidden = !showEffective;
            }
            trainingElements.effectiveBetaInput.disabled = !showEffective;
        }
    }

    function updateEmbeddingStandardizeControls() {
        if (!trainingElements.embeddingStandardizeCheckbox || !trainingElements.embeddingCenterCheckbox) {
            return;
        }
        const standardize = trainingElements.embeddingStandardizeCheckbox.checked;
        if (standardize) {
            trainingElements.embeddingCenterCheckbox.checked = true;
            trainingElements.embeddingCenterCheckbox.disabled = true;
        } else {
            trainingElements.embeddingCenterCheckbox.disabled = false;
        }
    }

    let mlpHiddenSizesTouched = false;
    let mlpHiddenSizesAutoValue = null;

    function inferEmbeddingDimFromEncoder(encoderType, modelName) {
        if (!modelName) return null;
        const name = String(modelName);
        if (encoderType === "clip") {
            if (name.includes("ViT-L/14")) return 768;
            if (name.includes("ViT-B/16")) return 512;
            if (name.includes("ViT-B/32")) return 512;
            return null;
        }
        const lower = name.toLowerCase();
        const dimMap = [
            { key: "vits16plus", dim: 384 },
            { key: "vits16", dim: 384 },
            { key: "vitb16", dim: 768 },
            { key: "vitl16", dim: 1024 },
            { key: "vith16plus", dim: 1280 },
            { key: "vit7b16", dim: 2560 },
            { key: "convnext-tiny", dim: 768 },
            { key: "convnext-small", dim: 768 },
            { key: "convnext-base", dim: 1024 },
            { key: "convnext-large", dim: 1536 },
        ];
        for (const entry of dimMap) {
            if (lower.includes(entry.key)) return entry.dim;
        }
        return null;
    }

    function recommendedHiddenSizesForDim(dim) {
        if (!dim || dim <= 0) return null;
        if (dim <= 384) return "256";
        if (dim <= 512) return "256";
        if (dim <= 768) return "512";
        if (dim <= 1024) return "768,384";
        if (dim <= 1280) return "1024,512";
        if (dim <= 1536) return "1024,512";
        return "1536,768";
    }

    function getRecommendedMlpHiddenSizes() {
        const rawType = trainingElements.classifierTypeSelect ? trainingElements.classifierTypeSelect.value : "logreg";
        const classifierType = rawType ? String(rawType).toLowerCase().trim() : "logreg";
        if (classifierType !== "mlp") return null;
        const encoderType = getTrainingEncoderType();
        const modelName = encoderType === "dinov3"
            ? (trainingElements.dinov3BackboneSelect ? trainingElements.dinov3BackboneSelect.value : null)
            : (trainingElements.clipBackboneSelect ? trainingElements.clipBackboneSelect.value : null);
        const dim = inferEmbeddingDimFromEncoder(encoderType, modelName);
        return recommendedHiddenSizesForDim(dim);
    }

    function applyRecommendedMlpHiddenSizes(force) {
        if (!trainingElements.mlpHiddenSizesInput) return;
        const recommended = getRecommendedMlpHiddenSizes();
        if (!recommended) return;
        const current = String(trainingElements.mlpHiddenSizesInput.value || "").trim();
        if (!force) {
            if (mlpHiddenSizesTouched && current && current !== mlpHiddenSizesAutoValue) {
                return;
            }
        }
        trainingElements.mlpHiddenSizesInput.value = recommended;
        mlpHiddenSizesAutoValue = recommended;
        mlpHiddenSizesTouched = false;
    }

    function populateDinov3Backbones() {
        fillSelectOptions(trainingElements.dinov3BackboneSelect, DINOV3_BACKBONES, DINOV3_BACKBONES[0] || "");
        updateTrainingEncoderControls();
    }

    async function populateClipBackbones() {
        try {
            const resp = await fetch(`${API_ROOT}/clip/backbones`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const data = await resp.json();
            const list = Array.isArray(data.available) ? data.available : [];
            const active = data.active || (list.length ? list[0] : null);
            fillSelectOptions(trainingElements.clipBackboneSelect, list, active);
            fillSelectOptions(activeElements.clipSelect, list, active);
            updateTrainingEncoderControls();
            applyRecommendedMlpHiddenSizes(false);
        } catch (error) {
            console.warn("Failed to fetch clip backbones", error);
            setTrainingMessage(`Unable to load CLIP backbones: ${error.message || error}`, "error");
            setActiveMessage(`Unable to load CLIP backbones: ${error.message || error}`, "error");
        }
    }

    async function refreshActiveModelPanel() {
        try {
            const resp = await fetch(`${API_ROOT}/clip/active_model`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const data = await resp.json();
            const encoderTypeRaw = data.encoder_type || "clip";
            const encoderType = String(encoderTypeRaw).toLowerCase().trim();
            const clipModelName = data.clip_model || "(not loaded)";
            const encoderModelName = data.encoder_model || clipModelName || "(unknown)";
            const encoderLabel = encoderType === "clip" ? "CLIP" : encoderType.toUpperCase();
            const classifierPath = data.classifier_path || "(none)";
            const labelmapPath = data.labelmap_path || "(none)";
            if (activeElements.info) {
                activeElements.info.innerHTML = `Encoder: <strong>${escapeHtml(encoderLabel)}</strong> (${escapeHtml(encoderModelName)})<br/>Classifier: <strong>${escapeHtml(classifierPath)}</strong><br/>Labelmap: <strong>${escapeHtml(labelmapPath)}</strong>`;
            }
            if (activeElements.classifierPath) {
                activeElements.classifierPath.value = data.classifier_path || "";
            }
            if (activeElements.labelmapPath) {
                activeElements.labelmapPath.value = data.labelmap_path || "";
            }
            if (activeElements.clipSelect) {
                const clipReady = encoderType === "clip";
                activeElements.clipSelect.disabled = !clipReady;
                if (clipReady && data.clip_model) {
                    activeElements.clipSelect.value = data.clip_model;
                }
            }
            if (trainingElements.clipBackboneSelect && data.clip_model) {
                trainingElements.clipBackboneSelect.value = data.clip_model;
            }
            syncActiveApplyAvailability();
            const encoderReady = data.encoder_ready !== undefined ? !!data.encoder_ready : !!data.clip_ready;
            const encoderError = data.encoder_error || data.clip_error;
            if (encoderReady) {
                setActiveMessage(`${encoderLabel} classifier is ready for auto-labeling.`, "success");
            } else if (encoderError && String(encoderError).includes("numpy._core")) {
                setActiveMessage("Classifier failed to load: numpy version mismatch. Please retrain in this environment or re-export with the current NumPy.", "error");
            } else if (encoderError) {
                setActiveMessage(`${encoderLabel} classifier not ready: ${encoderError}`, "error");
            } else {
                setActiveMessage(`${encoderLabel} classifier is not ready. Load a model to enable auto-labeling.`, "error");
            }
        } catch (error) {
            console.warn("Failed to refresh active model", error);
            setActiveMessage(`Unable to read active model: ${error.message || error}`, "error");
        }
    }

    function syncActiveApplyAvailability() {
        if (!activeElements.applyButton || !activeElements.classifierPath) return;
        const hasPath = !!(activeElements.classifierPath.value || "").trim();
        activeElements.applyButton.disabled = !hasPath;
        activeElements.applyButton.title = hasPath
            ? "Apply active model configuration."
            : "Select or upload a classifier first.";
    }

    function getSelectedActiveClassifier() {
        if (!activeElements.classifierSelect) return null;
        const selectedPath = activeElements.classifierSelect.value || "";
        return activeState.classifiers.find((entry) => entry.path === selectedPath) || null;
    }

    function getSelectedActiveLabelmap() {
        if (!activeElements.labelmapSelect) return null;
        const selectedPath = activeElements.labelmapSelect.value || "";
        return activeState.labelmaps.find((entry) => entry.path === selectedPath) || null;
    }

    function applyActiveClassifierSelection() {
        const entry = getSelectedActiveClassifier();
        if (!entry || !activeElements.classifierPath) return;
        activeElements.classifierPath.value = entry.path || "";
        if (entry.labelmap_guess && activeElements.labelmapPath) {
            activeElements.labelmapPath.value = entry.labelmap_guess;
            if (activeElements.labelmapSelect) {
                const match = activeState.labelmaps.find((lm) => lm.path === entry.labelmap_guess);
                if (match) activeElements.labelmapSelect.value = match.path;
            }
        }
        if (activeElements.clipSelect) {
            const encoderType = String(entry.encoder_type || "clip").toLowerCase().trim();
            if (encoderType !== "clip") {
                activeElements.clipSelect.value = "";
                activeElements.clipSelect.disabled = true;
                activeElements.clipSelect.title = "Disabled for non-CLIP classifiers.";
            } else {
                activeElements.clipSelect.disabled = false;
                activeElements.clipSelect.title = "";
                if (entry.clip_model) {
                    activeElements.clipSelect.value = entry.clip_model;
                }
            }
        }
        syncActiveApplyAvailability();
    }

    function applyActiveLabelmapSelection() {
        const entry = getSelectedActiveLabelmap();
        if (!entry || !activeElements.labelmapPath) return;
        activeElements.labelmapPath.value = entry.path || "";
    }

    async function loadActiveClipClassifiers(selectedPath) {
        if (!activeElements.classifierSelect) return;
        try {
            const resp = await fetch(`${API_ROOT}/clip/classifiers`);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            const list = Array.isArray(data) ? data : [];
            activeState.classifiers = list;
            activeElements.classifierSelect.innerHTML = "";
            const empty = document.createElement("option");
            empty.value = "";
            empty.textContent = list.length ? "Select a classifier…" : "No classifiers found";
            activeElements.classifierSelect.appendChild(empty);
            list.forEach((entry) => {
                const opt = document.createElement("option");
                opt.value = entry.path || "";
                const bits = [];
                if (entry.filename) bits.push(entry.filename);
                if (entry.n_classes) bits.push(`${entry.n_classes} classes`);
                const encoderTypeRaw = entry.encoder_type || "clip";
                const encoderType = String(encoderTypeRaw).toUpperCase();
                const encoderModel = entry.encoder_model || entry.clip_model;
                if (encoderModel) {
                    bits.push(`${encoderType}:${encoderModel}`);
                } else if (encoderType) {
                    bits.push(encoderType);
                }
                if (!entry.encoder_type) {
                    bits.push("legacy/no meta");
                }
                if (!entry.encoder_type) {
                    bits.push("legacy/no meta");
                }
                opt.textContent = bits.join(" • ") || entry.rel_path || entry.path || "classifier";
                activeElements.classifierSelect.appendChild(opt);
            });
            const preferred = selectedPath || activeElements.classifierPath?.value || "";
            const match = Array.from(activeElements.classifierSelect.options || []).some((opt) => opt.value === preferred);
            if (match) {
                activeElements.classifierSelect.value = preferred;
            } else if (list.length === 1 && list[0].path) {
                activeElements.classifierSelect.value = list[0].path;
            }
        } catch (err) {
            console.warn("Failed to load classifiers", err);
        }
    }

    async function loadActiveLabelmaps(selectedPath) {
        if (!activeElements.labelmapSelect) return;
        try {
            const resp = await fetch(`${API_ROOT}/clip/labelmaps`);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            const list = Array.isArray(data) ? data : [];
            activeState.labelmaps = list;
            activeElements.labelmapSelect.innerHTML = "";
            const empty = document.createElement("option");
            empty.value = "";
            empty.textContent = list.length ? "Select a labelmap…" : "No labelmaps found";
            activeElements.labelmapSelect.appendChild(empty);
            list.forEach((entry) => {
                const opt = document.createElement("option");
                opt.value = entry.path || "";
                const bits = [];
                if (entry.filename) bits.push(entry.filename);
                if (entry.n_classes) bits.push(`${entry.n_classes} classes`);
                opt.textContent = bits.join(" • ") || entry.rel_path || entry.path || "labelmap";
                activeElements.labelmapSelect.appendChild(opt);
            });
            const preferred = selectedPath || activeElements.labelmapPath?.value || "";
            const match = Array.from(activeElements.labelmapSelect.options || []).some((opt) => opt.value === preferred);
            if (match) {
                activeElements.labelmapSelect.value = preferred;
            } else if (list.length === 1 && list[0].path) {
                activeElements.labelmapSelect.value = list[0].path;
            }
        } catch (err) {
            console.warn("Failed to load labelmaps", err);
        }
    }

    function downloadClipAsset(url, filenameFallback) {
        const link = document.createElement("a");
        link.href = url;
        if (filenameFallback) link.download = filenameFallback;
        document.body.appendChild(link);
        link.click();
        document.body.removeChild(link);
    }
function renderTrainingHistoryItem(container, job) {
    const item = document.createElement("div");
    item.className = "training-history-item";
    const left = document.createElement("div");
    left.textContent = `${job.job_id.slice(0, 8)}… — ${job.status}`;
    const right = document.createElement("div");
    const viewBtn = document.createElement("button");
    viewBtn.type = "button";
    viewBtn.textContent = "View";
    viewBtn.addEventListener("click", () => {
        loadTrainingJob(job.job_id, { forcePoll: job.status === "running" || job.status === "queued" });
    });
    right.appendChild(viewBtn);
    item.append(left, right);
    container.appendChild(item);
}

function setQwenTrainMessage(text, variant = null) {
    if (!qwenTrainElements.message) {
        return;
    }
    qwenTrainElements.message.textContent = text || "";
    qwenTrainElements.message.classList.remove("error", "warn", "success");
    if (variant) {
        qwenTrainElements.message.classList.add(variant);
    }
}

const sam3LossState = {
    jobId: null,
    avgPoints: [],
    instPoints: [],
    trendPoints: [],
    rawPoints: [],
    lastMetricCount: 0,
    chart: null, // { ctx }
};

function renderSam3ValMetrics() {
    const container = sam3TrainElements.valMetrics;
    if (!container) return;
    const vals = sam3TrainState.valMetrics || [];
    if (!vals.length) {
        container.textContent = "No validation metrics yet.";
        return;
    }
    const valsSorted = [...vals].sort((a, b) => {
        const ea = Number.isFinite(a.epoch) ? a.epoch : 0;
        const eb = Number.isFinite(b.epoch) ? b.epoch : 0;
        return eb - ea; // latest first
    });
    const latest = valsSorted[0];
    const best = valsSorted.reduce((bestSoFar, entry) => {
        if (Number.isFinite(entry.ap) && (!bestSoFar || entry.ap > bestSoFar.ap)) {
            return entry;
        }
        return bestSoFar;
    }, null);
    const rows = valsSorted
        .map((entry, idx) => {
            const ep = Number.isFinite(entry.epoch) ? entry.epoch : `#${idx + 1}`;
            const ap = Number.isFinite(entry.ap) ? entry.ap.toFixed(3) : "–";
            const ap50 = Number.isFinite(entry.ap50) ? entry.ap50.toFixed(3) : "–";
            const ap75 = Number.isFinite(entry.ap75) ? entry.ap75.toFixed(3) : "–";
            const ar10 = Number.isFinite(entry.ar10) ? entry.ar10.toFixed(3) : "–";
            const ar100 = Number.isFinite(entry.ar100) ? entry.ar100.toFixed(3) : "–";
            const cls = idx === 0 ? "highlight" : "";
            return `<tr class="${cls}"><td>${ep}</td><td>${ap}</td><td>${ap50}</td><td>${ap75}</td><td>${ar10}</td><td>${ar100}</td></tr>`;
        })
        .join("");
    const latestLabel = Number.isFinite(latest.epoch) ? `epoch ${latest.epoch}` : `validation #${vals.length}`;
    const bestLabel =
        best && Number.isFinite(best.epoch)
            ? `epoch ${best.epoch} (best AP)`
            : best
              ? "best AP"
              : "n/a";
    const bestAp = best && Number.isFinite(best.ap) ? best.ap.toFixed(3) : "–";
    const bestAp50 = best && Number.isFinite(best.ap50) ? best.ap50.toFixed(3) : "–";
    const bestAp75 = best && Number.isFinite(best.ap75) ? best.ap75.toFixed(3) : "–";
    container.innerHTML = `
        <div class="training-help">
            COCO bbox metrics on the validation set (higher is better).
            AP is averaged over IoU 0.50–0.95; AP50/AP75 are stricter IoU thresholds; AR10/AR100 are recall with 10/100 detections per image.
        </div>
        <div class="training-help">
            Latest ${latestLabel}: AP ${Number.isFinite(latest.ap) ? latest.ap.toFixed(3) : "–"} • AP50 ${
        Number.isFinite(latest.ap50) ? latest.ap50.toFixed(3) : "–"
    } • AP75 ${Number.isFinite(latest.ap75) ? latest.ap75.toFixed(3) : "–"}
            ${best ? `<br/>Best ${bestLabel}: AP ${bestAp} • AP50 ${bestAp50} • AP75 ${bestAp75}` : ""}
        </div>
        <table class="metrics-table">
            <thead><tr><th>Epoch</th><th>AP (0.50–0.95)</th><th>AP50</th><th>AP75</th><th>AR10</th><th>AR100</th></tr></thead>
            <tbody>${rows}</tbody>
        </table>
    `;
}

const sam3EtaState = {
    startTime: null,
};

function initSam3LossChart() {
    if (!sam3TrainElements.lossCanvas || sam3LossState.chart) return;
    const ctx = sam3TrainElements.lossCanvas.getContext("2d");
    sam3LossState.chart = { ctx };
}

function resetSam3LossChart(jobId = null) {
    sam3LossState.jobId = jobId;
    sam3LossState.avgPoints = [];
    sam3LossState.instPoints = [];
    sam3LossState.trendPoints = [];
    sam3LossState.rawPoints = [];
    sam3LossState.lastMetricCount = 0;
    const canvas = sam3TrainElements.lossCanvas;
    if (canvas) {
        const ctx = canvas.getContext("2d");
        if (ctx) {
            const width = canvas.width || canvas.clientWidth || 0;
            const height = canvas.height || canvas.clientHeight || 0;
            ctx.clearRect(0, 0, width, height);
        }
    }
}

function parseSam3LossPair(line) {
    // Expect log lines like "Losses/train_all_loss: 9.58e+01 (1.23e+02)"
    const match = line.match(/Losses\/train_all_loss:\s*([0-9.+-eE]+)(?:\s*\(\s*([0-9.+-eE]+)\s*\))?/);
    if (!match) return null;
    const inst = Number(match[1]);
    const avg = match[2] !== undefined ? Number(match[2]) : null;
    return {
        instant: Number.isFinite(inst) ? inst : null,
        average: Number.isFinite(avg) ? avg : null,
    };
}

function formatEta(seconds) {
    if (!Number.isFinite(seconds) || seconds < 0) return "";
    const mins = Math.floor(seconds / 60);
    const secs = Math.floor(seconds % 60);
    if (mins <= 0) return `${secs}s remaining`;
    if (mins < 60) return `${mins}m ${secs.toString().padStart(2, "0")}s remaining`;
    const hours = Math.floor(mins / 60);
    const remMins = mins % 60;
    return `${hours}h ${remMins.toString().padStart(2, "0")}m remaining`;
}

function resetSam3Eta() {
    sam3EtaState.startTime = null;
}

function computeSam3Progress(job) {
    const fallback = Number.isFinite(job?.progress) ? job.progress : 0;
    const metrics = Array.isArray(job?.metrics) ? job.metrics : [];
    if (!metrics.length) return Math.max(0, Math.min(1, fallback));
    const last = metrics[metrics.length - 1] || {};
    // Validation progress (if present) overrides train-derived progress
    const lastVal = [...metrics].reverse().find(
        (m) => m && m.phase === "val" && Number.isFinite(m.val_step) && Number.isFinite(m.val_total),
    );
    if (lastVal) {
        const valStep = Number(lastVal.val_step);
        const valTotal = Math.max(1, Number(lastVal.val_total));
        const valFrac = Math.max(0, Math.min(1, valStep / valTotal));
        const base = Math.max(0.9, fallback);
        return Math.max(base, Math.min(1, base + 0.1 * valFrac));
    }
    const epoch = Number.isFinite(last.epoch) ? Number(last.epoch) : null;
    const totalEpochs = Number.isFinite(last.total_epochs) ? Number(last.total_epochs) : null;
    const batch = Number.isFinite(last.batch) ? Number(last.batch) : null;
    // Prefer explicit batches_per_epoch from metrics; otherwise fall back to target_epoch_size if present on job
    const batchesPerEpochMetric = Number.isFinite(last.batches_per_epoch) ? Number(last.batches_per_epoch) : null;
    const batchesPerEpoch =
        batchesPerEpochMetric ||
        (Number.isFinite(job?.config?.scratch?.target_epoch_size) ? Number(job.config.scratch.target_epoch_size) : null);
    if (!epoch || !batch || !batchesPerEpoch || !totalEpochs) {
        return Math.max(0, Math.min(1, fallback));
    }
    const epochIdx0 = Math.max(0, epoch - 1);
    const fracEpoch = Math.max(0, Math.min(1, batch / Math.max(1, batchesPerEpoch)));
    const overall = (epochIdx0 + fracEpoch) / Math.max(1, totalEpochs);
    return Math.max(0, Math.min(1, overall));
}

function computeMetricProgress(job) {
    const metrics = Array.isArray(job?.metrics) ? job.metrics : [];
    if (!metrics.length) return null;
    const last = metrics[metrics.length - 1] || {};
    const batchesPerEpoch = Number.isFinite(last.batches_per_epoch) ? Number(last.batches_per_epoch) : null;
    const totalEpochs = Number.isFinite(last.total_epochs) ? Number(last.total_epochs) : null;
    const batch = Number.isFinite(last.batch) ? Number(last.batch) : null;
    const epoch = Number.isFinite(last.epoch) ? Number(last.epoch) : null;
    if (!batchesPerEpoch || !totalEpochs || !batch || !epoch) return null;
    const done = Math.max(0, (epoch - 1) * batchesPerEpoch + batch);
    const total = Math.max(1, batchesPerEpoch * totalEpochs);
    return Math.max(0, Math.min(1, done / total));
}

function computeMetricEta(job, progressOverride = null) {
    const metrics = Array.isArray(job?.metrics) ? job.metrics : [];
    const created = Number.isFinite(job?.created_at) ? Number(job.created_at) : null;
    const startTs = created;
    const endTs = Date.now() / 1000;
    if (!Number.isFinite(startTs) || endTs <= startTs) return null;
    const progress = progressOverride !== null ? progressOverride : computeMetricProgress(job);
    if (!Number.isFinite(progress) || progress <= 0) return null;
    const elapsed = endTs - startTs;
    const remaining = elapsed * (1 - progress) / progress;
    return remaining > 0 ? remaining : null;
}

function updateSam3Eta(progress) {
    const now = Date.now();
    if (!Number.isFinite(progress) || progress <= 0) {
        sam3EtaState.startTime = sam3EtaState.startTime || now;
        return null;
    }
    if (sam3EtaState.startTime === null) {
        sam3EtaState.startTime = now;
        return null;
    }
    const elapsed = (now - sam3EtaState.startTime) / 1000; // seconds
    if (elapsed <= 0) return null;
    const remaining = elapsed * (1 - progress) / progress;
    return remaining > 0 ? remaining : null;
}

function getMinMax(arr, accessor) {
    let min = Infinity;
    let max = -Infinity;
    arr.forEach((item) => {
        const val = accessor ? accessor(item) : item;
        if (Number.isFinite(val)) {
            if (val < min) min = val;
            if (val > max) max = val;
        }
    });
    if (min === Infinity || max === -Infinity) {
        return [0, 0];
    }
    return [min, max];
}

function drawSam3LossChart() {
    const canvas = sam3TrainElements.lossCanvas;
    const hasAvg = sam3LossState.avgPoints && sam3LossState.avgPoints.length;
    const hasInst = sam3LossState.instPoints && sam3LossState.instPoints.length;
    const hasTrend = sam3LossState.trendPoints && sam3LossState.trendPoints.length;
    if (!canvas || (!hasAvg && !hasInst && !hasTrend)) return;
    const ctx = canvas.getContext("2d");
    if (!ctx) return;

    const width = Math.max(canvas.clientWidth || 400, 320);
    const height = Math.max(canvas.clientHeight || 200, 160);
    const dpr = window.devicePixelRatio || 1;
    if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
        canvas.width = width * dpr;
        canvas.height = height * dpr;
    }
    ctx.save();
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, width, height);

    const padding = { top: 14, right: 14, bottom: 18, left: 48 };
    const chartWidth = Math.max(1, width - padding.left - padding.right);
    const chartHeight = Math.max(1, height - padding.top - padding.bottom);

    const seriesX = [];
    if (hasAvg) {
        seriesX.push(sam3LossState.avgPoints[0].x, sam3LossState.avgPoints[sam3LossState.avgPoints.length - 1].x);
    }
    if (hasInst) {
        seriesX.push(sam3LossState.instPoints[0].x, sam3LossState.instPoints[sam3LossState.instPoints.length - 1].x);
    }
    if (hasTrend) {
        seriesX.push(sam3LossState.trendPoints[0].x, sam3LossState.trendPoints[sam3LossState.trendPoints.length - 1].x);
    }
    const minX = Math.min(...seriesX);
    const maxX = Math.max(...seriesX);
    const xRange = Math.max(1, maxX - minX);

    // Shared axis across both series to keep scales comparable
    const allPoints = [];
    if (hasAvg) allPoints.push(...sam3LossState.avgPoints);
    if (hasInst) allPoints.push(...sam3LossState.instPoints);
    if (hasTrend) allPoints.push(...sam3LossState.trendPoints);
    const [yMinRaw, yMaxRaw] = allPoints.length ? getMinMax(allPoints, (p) => p.y) : [0, 1];
    const yMin = Math.max(0, Math.min(yMinRaw, yMaxRaw - 1e-6));
    const yMax = Math.max(yMin + 1e-6, yMaxRaw);
    const yRange = yMax - yMin;

    const tickCount = 4;
    const avgTickStep = yRange / tickCount;
    const avgTicks = [];
    for (let i = 0; i <= tickCount; i += 1) {
        avgTicks.push(yMin + avgTickStep * i);
    }

    // Grid + labels
    ctx.strokeStyle = "#e2e8f0";
    ctx.lineWidth = 1;
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#94a3b8";
    ctx.font = "12px sans-serif";
    avgTicks.forEach((tick) => {
        const norm = (tick - yMin) / yRange;
        const y = padding.top + (1 - norm) * chartHeight;
        ctx.beginPath();
        ctx.moveTo(padding.left, y);
        ctx.lineTo(width - padding.right, y);
        ctx.stroke();
        ctx.fillText(tick.toExponential(1), padding.left - 6, y);
    });

    // Axes
    ctx.strokeStyle = "#94a3b8";
    ctx.beginPath();
    ctx.moveTo(padding.left, padding.top);
    ctx.lineTo(padding.left, padding.top + chartHeight);
    ctx.stroke();

    // Average loss line (blue)
    if (hasAvg) {
        ctx.strokeStyle = "#2563eb";
        ctx.lineWidth = 2;
        ctx.lineJoin = "round";
        ctx.lineCap = "round";
        ctx.beginPath();
        sam3LossState.avgPoints.forEach((point, idx) => {
            const normX = (point.x - minX) / xRange;
            const normY = (point.y - yMin) / yRange;
            const xPos = padding.left + normX * chartWidth;
            const yPos = padding.top + (1 - normY) * chartHeight;
            if (idx === 0) {
                ctx.moveTo(xPos, yPos);
            } else {
                ctx.lineTo(xPos, yPos);
            }
        });
        ctx.stroke();
    }

    // Instant loss line (orange) on shared axis
    if (hasInst) {
        ctx.strokeStyle = "#f97316";
        ctx.lineWidth = 1.5;
        ctx.beginPath();
        sam3LossState.instPoints.forEach((point, idx) => {
            const normX = (point.x - minX) / xRange;
            const normY = (point.y - yMin) / yRange;
            const xPos = padding.left + normX * chartWidth;
            const yPos = padding.top + (1 - normY) * chartHeight;
            if (idx === 0) {
                ctx.moveTo(xPos, yPos);
            } else {
                ctx.lineTo(xPos, yPos);
            }
        });
        ctx.stroke();
    }
    // Trend line (green, dashed)
    if (hasTrend) {
        ctx.strokeStyle = "#22c55e";
        ctx.lineWidth = 2;
        ctx.setLineDash([6, 4]);
        ctx.beginPath();
        sam3LossState.trendPoints.forEach((point, idx) => {
            const normX = (point.x - minX) / xRange;
            const normY = (point.y - yMin) / yRange;
            const xPos = padding.left + normX * chartWidth;
            const yPos = padding.top + (1 - normY) * chartHeight;
            if (idx === 0) {
                ctx.moveTo(xPos, yPos);
            } else {
                ctx.lineTo(xPos, yPos);
            }
        });
        ctx.stroke();
        ctx.setLineDash([]);
    }
    ctx.restore();
}

function updateSam3LossChartFromMetrics(metrics, jobId) {
    if (!sam3TrainElements.lossCanvas) return;
    if (jobId && sam3LossState.jobId !== jobId) {
        resetSam3LossChart(jobId);
        sam3TrainState.valMetrics = [];
    }
    const entries = Array.isArray(metrics) ? metrics : [];
    if (!entries.length) return;
    if (entries.length < sam3LossState.lastMetricCount) {
        resetSam3LossChart(jobId || sam3LossState.jobId);
    }
    const newEntries = entries.slice(sam3LossState.lastMetricCount);
    sam3LossState.lastMetricCount = entries.length;
    if (!newEntries.length) return;
    initSam3LossChart();
    newEntries.forEach((entry) => {
        if (!entry || typeof entry !== "object") return;
        const inst = entry.train_loss_batch !== undefined ? Number(entry.train_loss_batch) : Number(entry.train_loss);
        const avg =
            entry.train_loss_avg10 !== undefined
                ? Number(entry.train_loss_avg10)
                : entry.train_loss_avg !== undefined
                  ? Number(entry.train_loss_avg)
                  : null;
        const stepVal = Number.isFinite(entry.step) ? entry.step : Math.max(sam3LossState.avgPoints.length, sam3LossState.instPoints.length);
        if (Number.isFinite(avg)) {
            sam3LossState.avgPoints.push({ x: stepVal, y: avg });
        }
        if (Number.isFinite(inst)) {
            sam3LossState.instPoints.push({ x: stepVal, y: inst });
        }
        const trendBase = Number.isFinite(avg) ? avg : Number.isFinite(inst) ? inst : null;
        if (trendBase !== null) {
            sam3LossState.rawPoints.push({ x: stepVal, y: trendBase });
            const alpha = sam3TrainState.trendAlpha || 0.05;
            if (!sam3LossState.trendPoints.length) {
                sam3LossState.trendPoints.push({ x: stepVal, y: trendBase });
            } else {
                const prev = sam3LossState.trendPoints[sam3LossState.trendPoints.length - 1].y;
                const smoothed = alpha * trendBase + (1 - alpha) * prev;
                sam3LossState.trendPoints.push({ x: stepVal, y: smoothed });
            }
        }
        if (entry.phase === "val" && (entry.coco_ap !== undefined || entry.coco_ap50 !== undefined)) {
            sam3TrainState.valMetrics.push({
                epoch: Number.isFinite(entry.epoch) ? Number(entry.epoch) : null,
                ap: entry.coco_ap !== undefined ? Number(entry.coco_ap) : null,
                ap50: entry.coco_ap50 !== undefined ? Number(entry.coco_ap50) : null,
                ap75: entry.coco_ap75 !== undefined ? Number(entry.coco_ap75) : null,
                ar10: entry.coco_ar10 !== undefined ? Number(entry.coco_ar10) : null,
                ar100: entry.coco_ar100 !== undefined ? Number(entry.coco_ar100) : null,
            });
        }
    });
    if (sam3LossState.avgPoints.length || sam3LossState.instPoints.length) {
        drawSam3LossChart();
    }
    renderSam3ValMetrics();
}

function recomputeSam3Trend() {
    sam3LossState.trendPoints = [];
    if (!sam3LossState.rawPoints.length) return;
    const alpha = sam3TrainState.trendAlpha || 0.05;
    sam3LossState.rawPoints.forEach((pt, idx) => {
        if (idx === 0) {
            sam3LossState.trendPoints.push({ x: pt.x, y: pt.y });
        } else {
            const prev = sam3LossState.trendPoints[sam3LossState.trendPoints.length - 1].y;
            const smoothed = alpha * pt.y + (1 - alpha) * prev;
            sam3LossState.trendPoints.push({ x: pt.x, y: smoothed });
        }
    });
}

function readNumberInput(input, { integer = false } = {}) {
    if (!input) {
        return undefined;
    }
    const raw = String(input.value ?? "").trim();
    if (!raw) {
        return undefined;
    }
    const parsed = integer ? parseInt(raw, 10) : parseFloat(raw);
    return Number.isFinite(parsed) ? parsed : undefined;
}

function getSelectedQwenTrainMode() {
    const selected = document.querySelector('input[name="qwenTrainMode"]:checked');
    return selected ? selected.value : "official_lora";
}

const QWEN_VRAM_ESTIMATE_GB = {
    official_lora: { "2B": 12.0, "4B": 20.0, "8B": 96.0, "32B": 192.0 },
    trl_qlora: { "2B": 8.0, "4B": 10.0, "8B": 16.0, "32B": 48.0 },
};
const QWEN_VRAM_THINKING_SCALE = 1.08;
const QWEN_VRAM_PIXEL_BASE = 451584;
const QWEN_VRAM_PIXEL_SCALE_MIN = 0.6;
const QWEN_VRAM_PIXEL_SCALE_MAX = 1.6;

function inferQwenModelSize(modelId) {
    const sizes = ["2B", "4B", "8B", "32B"];
    for (const size of sizes) {
        if (modelId.includes(size)) return size;
    }
    return null;
}

function estimateQwenVram({ modelId, trainingMode, maxPixels, batchSize }) {
    const size = inferQwenModelSize(modelId || "");
    if (!size) return { estimateMb: null, note: null };
    const mode = QWEN_VRAM_ESTIMATE_GB[trainingMode] ? trainingMode : "official_lora";
    const baseGb = QWEN_VRAM_ESTIMATE_GB[mode]?.[size];
    if (!baseGb) return { estimateMb: null, note: null };
    let scale = 1.0;
    let pixelScale = 1.0;
    let batchScale = 1.0;
    if (modelId.includes("Thinking")) {
        scale *= QWEN_VRAM_THINKING_SCALE;
    }
    if (typeof maxPixels === "number" && maxPixels > 0) {
        pixelScale = maxPixels / Math.max(1, QWEN_VRAM_PIXEL_BASE);
        pixelScale = Math.min(QWEN_VRAM_PIXEL_SCALE_MAX, Math.max(QWEN_VRAM_PIXEL_SCALE_MIN, pixelScale));
        scale *= pixelScale;
    }
    if (typeof batchSize === "number" && batchSize > 1) {
        batchScale = batchSize;
        scale *= batchSize;
    }
    const estimateMb = baseGb * 1024 * scale;
    let note = null;
    if (mode === "official_lora" && (size === "8B" || size === "32B")) {
        note = "Official LoRA is very VRAM-hungry; 8B/32B often exceed 48GB even at smaller pixel budgets.";
    }
    if (mode === "trl_qlora" && size === "32B" && modelId.includes("Thinking")) {
        note = "32B Thinking QLoRA is experimental; some setups hit multi-GPU gradient issues.";
    }
    if (mode === "trl_qlora" && size === "8B" && maxPixels === QWEN_VRAM_PIXEL_BASE) {
        note = "Verified: 8B QLoRA fits on a 48GB GPU at default pixel budget.";
    }
    return {
        estimateMb,
        note,
        baseGb,
        pixelScale,
        batchScale,
        totalGb: estimateMb / 1024,
    };
}

function maybeAutoSelectQwenTrainMode() {
    if (qwenTrainState.trainModeTouched) return;
    const modelId = resolveQwenModelId();
    const size = inferQwenModelSize(modelId || "");
    if (!qwenTrainElements.trainModeRadios) return;
    if (size === "8B" || size === "32B") {
        qwenTrainElements.trainModeRadios.forEach((radio) => {
            if (radio.value === "trl_qlora") radio.checked = true;
        });
    } else {
        qwenTrainElements.trainModeRadios.forEach((radio) => {
            if (radio.value === "official_lora") radio.checked = true;
        });
    }
}

function updateQwenVramEstimate() {
    if (!qwenTrainElements.vramEstimate) return;
    const modelId = resolveQwenModelId();
    const trainingMode = getSelectedQwenTrainMode();
    const maxPixels = readNumberInput(qwenTrainElements.maxPixelsInput, { integer: true });
    const batchSize = readNumberInput(qwenTrainElements.batchSizeInput, { integer: true });
    const { estimateMb, note, baseGb, pixelScale, batchScale, totalGb } = estimateQwenVram({
        modelId,
        trainingMode,
        maxPixels,
        batchSize,
    });
    if (!estimateMb) {
        qwenTrainElements.vramEstimate.textContent = "Estimated VRAM: --";
        if (qwenTrainElements.vramBreakdown) {
            qwenTrainElements.vramBreakdown.textContent = "VRAM budget: --";
        }
        qwenTrainElements.vramEstimate.classList.remove("warn");
        return;
    }
    let text = `Estimated VRAM: ~${totalGb.toFixed(1)} GB`;
    if (qwenTrainState.gpuTotalMb) {
        const gpuGb = qwenTrainState.gpuTotalMb / 1024;
        const fits = estimateMb <= qwenTrainState.gpuTotalMb;
        text += ` • GPU: ${gpuGb.toFixed(1)} GB (${fits ? "likely fits" : "likely OOM"})`;
        qwenTrainElements.vramEstimate.classList.toggle("warn", !fits);
    } else {
        qwenTrainElements.vramEstimate.classList.remove("warn");
    }
    if (note) {
        text += ` • ${note}`;
    }
    qwenTrainElements.vramEstimate.textContent = text;
    if (qwenTrainElements.vramBreakdown && baseGb) {
        const parts = [
            `VRAM budget: base ${baseGb.toFixed(1)} GB`,
            `pixel ×${pixelScale.toFixed(2)}`,
        ];
        if (batchScale > 1.0) {
            parts.push(`batch ×${batchScale.toFixed(1)}`);
        }
        parts.push(`= ${totalGb.toFixed(1)} GB`);
        qwenTrainElements.vramBreakdown.textContent = parts.join(" ");
    }
}

function resolveQwenModelId() {
    const size = qwenTrainElements.modelSizeSelect?.value || "4B";
    const variant = qwenTrainElements.modelVariantSelect?.value || "Instruct";
    return `Qwen/Qwen3-VL-${size}-${variant}`;
}

function updateQwenModelPreview() {
    maybeAutoSelectQwenTrainMode();
    if (qwenTrainElements.modelIdPreview) {
        qwenTrainElements.modelIdPreview.textContent = resolveQwenModelId();
    }
    updateQwenVramEstimate();
}

async function refreshQwenGpuInfo() {
    try {
        const resp = await fetch(`${API_ROOT}/predictor_settings`);
        if (!resp.ok) {
            throw new Error(await resp.text() || `HTTP ${resp.status}`);
        }
        const data = await resp.json();
        const total = typeof data.gpuTotalMb === "number" ? data.gpuTotalMb : null;
        qwenTrainState.gpuTotalMb = total && total > 0 ? total : null;
    } catch (error) {
        qwenTrainState.gpuTotalMb = null;
    } finally {
        updateQwenVramEstimate();
    }
}

function shuffleArray(input) {
    const arr = [...input];
    for (let i = arr.length - 1; i > 0; i--) {
        const j = Math.floor(Math.random() * (i + 1));
        [arr[i], arr[j]] = [arr[j], arr[i]];
    }
    return arr;
}

function sanitizeDatasetFilename(name) {
    return (name || "image").replace(/[\\/]/g, "_");
}

function makeUniqueFilename(baseName, usageMap) {
    const safeBase = sanitizeDatasetFilename(baseName);
    const count = usageMap.get(safeBase) || 0;
    usageMap.set(safeBase, count + 1);
    if (count === 0) {
        return safeBase;
    }
    const dotIndex = safeBase.lastIndexOf(".");
    if (dotIndex !== -1) {
        const stem = safeBase.slice(0, dotIndex);
        const ext = safeBase.slice(dotIndex);
        return `${stem}_${count}${ext}`;
    }
    return `${safeBase}_${count}`;
}

async function ensureImageDimensions(imageRecord) {
    if (imageRecord.width && imageRecord.height) {
        return;
    }
    await loadImageObject(imageRecord);
    const width = imageRecord.object?.naturalWidth || imageRecord.object?.width || imageRecord.width;
    const height = imageRecord.object?.naturalHeight || imageRecord.object?.height || imageRecord.height;
    if (!width || !height) {
        throw new Error(`Unable to read dimensions for ${imageRecord.meta?.name || "image"}`);
    }
    imageRecord.width = width;
    imageRecord.height = height;
}

function buildQwenInstruction(contextText, classNames) {
    const parts = [];
    if (contextText) {
        parts.push(`This image shows ${contextText}.`);
    }
    if (classNames.length) {
        parts.push(`Objects of interest: ${classNames.join(", ")}.`);
    }
    return parts.join(" ").trim();
}

function buildDetectionRecords(imageName, imageRecord) {
    const width = imageRecord.width || 0;
    const height = imageRecord.height || 0;
    const buckets = bboxes[imageName] || {};
    const records = [];
    for (const className of Object.keys(buckets)) {
        const bucket = buckets[className] || [];
        bucket.forEach((bbox) => {
            if (!bbox) {
                return;
            }
            const copy = {
                x: bbox.x,
                y: bbox.y,
                width: bbox.width,
                height: bbox.height,
            };
            const valid = clampBbox(copy, width, height);
            if (!valid) {
                return;
            }
            const x1 = Math.round(copy.x);
            const y1 = Math.round(copy.y);
            const x2 = Math.round(copy.x + copy.width);
            const y2 = Math.round(copy.y + copy.height);
            const cx = Math.round(copy.x + copy.width / 2);
            const cy = Math.round(copy.y + copy.height / 2);
            records.push({
                label: className,
                bbox: [x1, y1, x2, y2],
                point: [cx, cy],
            });
        });
    }
    return records;
}

function chooseQwenSampleLabelSet(detections) {
    const labels = Array.from(new Set((detections || []).map((det) => (det.label || "").trim()).filter(Boolean))).sort();
    if (!labels.length) {
        return { labels: [], mode: "all" };
    }
    if (labels.length === 1) {
        return Math.random() < 0.5 ? { labels, mode: "single" } : { labels, mode: "all" };
    }
    const roll = Math.random();
    if (roll < 0.34) {
        return { labels, mode: "all" };
    }
    if (roll < 0.67) {
        return { labels: [labels[Math.floor(Math.random() * labels.length)]], mode: "single" };
    }
    const subsetSize = Math.max(2, Math.floor(Math.random() * labels.length) + 1);
    const shuffled = shuffleArray(labels.slice());
    return { labels: shuffled.slice(0, Math.min(subsetSize, labels.length)).sort(), mode: "subset" };
}

function filterDetectionsForLabels(detections, labels, mode) {
    if (!Array.isArray(detections) || !detections.length || !labels || !labels.length || mode === "all") {
        return detections || [];
    }
    const labelSet = new Set(labels.map((label) => label.trim()).filter(Boolean));
    return detections.filter((det) => labelSet.has((det.label || "").trim()));
}

function buildQwenSampleUserPrompt(context, labels, mode, type) {
    const parts = [];
    if (context) {
        parts.push(context);
    }
    if (labels && labels.length) {
        if (mode === "single") {
            parts.push(`Focus only on the class '${labels[0]}'.`);
        } else if (mode === "subset") {
            parts.push(`Focus only on these classes: ${labels.join(", ")}.`);
        } else {
            parts.push(`Return detections for these classes: ${labels.join(", ")}.`);
        }
    } else {
        parts.push("Return detections for every labeled object.");
    }
    if (type === "bbox") {
        parts.push("Return a JSON object named \"detections\". Each detection must include \"label\" and \"bbox\" as [x1,y1,x2,y2] pixel coordinates (integers). If nothing is present, respond with {\"detections\": []}. Respond with JSON only.");
    } else {
        parts.push("Return a JSON object named \"detections\". Each detection must include \"label\" and \"point\" as [x,y] pixel coordinates near the object center. If nothing is present, respond with {\"detections\": []}. Respond with JSON only.");
    }
    return parts.filter(Boolean).join(" ").trim();
}

function buildQwenOutputPayload(detections, type) {
    const items = [];
    (detections || []).forEach((det) => {
        if (!det || !det.label) return;
        if (type === "bbox" && Array.isArray(det.bbox)) {
            items.push({ label: det.label, bbox: det.bbox });
        } else if (type === "point" && Array.isArray(det.point)) {
            items.push({ label: det.label, point: det.point });
        }
    });
    return JSON.stringify({ detections: items });
}

function buildQwenConversationRecord(imageName, promptText, outputText) {
    return JSON.stringify({
        image: imageName,
        conversations: [
            { from: "human", value: `<image>\n${promptText}` },
            { from: "gpt", value: outputText },
        ],
    });
}

function pickQwenValidationSet(imageNames) {
    const shuffled = shuffleArray(imageNames);
    if (!shuffled.length) {
        return new Set();
    }
    let valCount = Math.max(1, Math.round(shuffled.length * 0.2));
    if (valCount >= shuffled.length && shuffled.length > 1) {
        valCount = Math.max(1, shuffled.length - 1);
    }
    if (shuffled.length === 1) {
        valCount = 1;
    }
    const valSet = new Set(shuffled.slice(0, valCount));
    if (valSet.size === 0 && shuffled.length) {
        valSet.add(shuffled[0]);
    }
    if (valSet.size === shuffled.length && shuffled.length > 1) {
        valSet.delete(shuffled[shuffled.length - 1]);
    }
    return valSet;
}

async function initQwenDatasetUpload(runName) {
    const formData = new FormData();
    if (runName) {
        formData.append("run_name", runName);
    }
    const resp = await fetch(`${API_ROOT}/qwen/dataset/init`, {
        method: "POST",
        body: formData,
    });
    if (!resp.ok) {
        const detail = await resp.text();
        throw new Error(detail || "Failed to initialize Qwen dataset upload.");
    }
    return resp.json();
}

async function uploadQwenDatasetChunk(jobId, split, record) {
    const formData = new FormData();
    formData.append("job_id", jobId);
    formData.append("split", split);
    formData.append("image_name", record.imageName);
    formData.append("annotation_line", record.annotation);
    formData.append("file", record.file, record.file?.name || record.imageName);
    const resp = await fetch(`${API_ROOT}/qwen/dataset/chunk`, {
        method: "POST",
        body: formData,
    });
    if (!resp.ok) {
        const detail = await resp.text();
        throw new Error(detail || `Failed to upload ${split} chunk (${resp.status})`);
    }
    return resp.json();
}

async function finalizeQwenDatasetUpload(jobId, metadata, runName) {
    const formData = new FormData();
    formData.append("job_id", jobId);
    formData.append("metadata", JSON.stringify(metadata || {}));
    if (runName) {
        formData.append("run_name", runName);
    }
    const resp = await fetch(`${API_ROOT}/qwen/dataset/finalize`, {
        method: "POST",
        body: formData,
    });
    if (!resp.ok) {
        const detail = await resp.text();
        throw new Error(detail || `Dataset finalize failed (${resp.status})`);
    }
    return resp.json();
}

function setSam3Message(text, tone = "info") {
    if (!sam3TrainElements.message) return;
    sam3TrainElements.message.textContent = text || "";
    sam3TrainElements.message.className = `training-message ${tone}`;
}

function updateSam3DatasetSummary(entry) {
    if (!sam3TrainElements.datasetSummary) return;
    if (!entry) {
        sam3TrainElements.datasetSummary.textContent = "Pick a dataset to train.";
        return;
    }
    const coco = entry.coco_ready ? "COCO ready" : "Convert required";
    const src = entry.source || "unknown";
    const counts = [];
    if (entry.image_count) counts.push(`${entry.image_count} images`);
    if (entry.train_count) counts.push(`train ${entry.train_count}`);
    if (entry.val_count) counts.push(`val ${entry.val_count}`);
    const countText = counts.length ? ` • ${counts.join(" / ")}` : "";
    sam3TrainElements.datasetSummary.textContent = `${entry.label || entry.id} (${src}, ${coco})${countText}`;
}

async function loadSam3Datasets() {
    try {
        const resp = await fetch(`${API_ROOT}/sam3/datasets`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        sam3TrainState.datasets = Array.isArray(data) ? data : [];
        if (!sam3TrainState.selectedId && sam3TrainState.datasets.length) {
            sam3TrainState.selectedId = sam3TrainState.datasets[0].id;
        }
        if (sam3TrainElements.datasetSelect) {
            sam3TrainElements.datasetSelect.innerHTML = "";
            sam3TrainState.datasets.forEach((entry) => {
                const opt = document.createElement("option");
                opt.value = entry.id;
                opt.textContent = `${entry.label || entry.id}${entry.coco_ready ? "" : " (needs convert)"}`;
                if (entry.id === sam3TrainState.selectedId) {
                    opt.selected = true;
                }
                sam3TrainElements.datasetSelect.appendChild(opt);
            });
        }
        const selected = sam3TrainState.datasets.find((d) => d.id === sam3TrainState.selectedId) || sam3TrainState.datasets[0];
        sam3TrainState.selectedId = selected ? selected.id : null;
        updateSam3DatasetSummary(selected);
        resetSam3Eta();
    } catch (err) {
        console.error("Failed to load SAM3 datasets", err);
        setSam3Message(`Failed to load datasets: ${err.message || err}`, "error");
    }
}

async function convertSam3Dataset() {
    const datasetId = sam3TrainState.selectedId;
    if (!datasetId) {
        setSam3Message("Select a dataset first.", "warn");
        return;
    }
    setSam3Message("Converting dataset to COCO…", "info");
    try {
        const resp = await fetch(`${API_ROOT}/sam3/datasets/${encodeURIComponent(datasetId)}/convert`, { method: "POST" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const meta = await resp.json();
        setSam3Message("Dataset converted.", "success");
        await loadSam3Datasets();
        return meta;
    } catch (err) {
        console.error("SAM3 convert failed", err);
        setSam3Message(`Convert failed: ${err.message || err}`, "error");
        throw err;
    }
}

// Prompt helper (SAM3) - suggest and score text prompts per class
function setPromptHelperMessage(text, tone = "info") {
    if (!promptHelperElements.message) return;
    promptHelperElements.message.textContent = text || "";
    promptHelperElements.message.className = `training-message ${tone}`;
}

function setPromptSearchMessage(text, tone = "info") {
    if (!promptSearchElements.message) return;
    promptSearchElements.message.textContent = text || "";
    promptSearchElements.message.className = `training-message ${tone}`;
}

function setPromptRecipeMessage(text, tone = "info") {
    if (!promptRecipeElements.message) return;
    promptRecipeElements.message.textContent = text || "";
    promptRecipeElements.message.className = `training-message ${tone}`;
}

function readThresholdList(inputEl, fallback = 0.2) {
    if (!inputEl) return [fallback];
    const raw = inputEl.value || "";
    const parts = raw
        .split(/[,\s]+/)
        .map((s) => s.trim())
        .filter(Boolean)
        .map((s) => parseFloat(s))
        .filter((v) => !Number.isNaN(v) && v >= 0 && v <= 1);
    if (!parts.length) return [fallback];
    const seen = new Set();
    const cleaned = [];
    parts.forEach((v) => {
        const key = v.toFixed(4);
        if (seen.has(key)) return;
        seen.add(key);
        cleaned.push(v);
    });
    return cleaned;
}

function setAgentStatus(text, tone = "info") {
    if (!agentElements.status) return;
    agentElements.status.textContent = text || "";
    agentElements.status.className = `training-message ${tone}`;
}

function setAgentResultsMessage(text, tone = "info") {
    if (!agentElements.results) return;
    const msg = document.createElement("div");
    msg.className = `training-message ${tone}`;
    msg.textContent = text;
    agentElements.results.innerHTML = "";
    agentElements.results.appendChild(msg);
}

function updatePromptHelperDatasetSummary(entry) {
    if (!promptHelperElements.datasetSummary) return;
    if (!entry) {
        promptHelperElements.datasetSummary.textContent = "Pick a dataset to score prompts against.";
        return;
    }
    const coco = entry.coco_ready ? "COCO ready" : "Convert required";
    const counts = [];
    if (entry.image_count) counts.push(`${entry.image_count} images`);
    if (entry.train_count) counts.push(`train ${entry.train_count}`);
    if (entry.val_count) counts.push(`val ${entry.val_count}`);
    const countText = counts.length ? ` • ${counts.join(" / ")}` : "";
    promptHelperElements.datasetSummary.textContent = `${entry.label || entry.id} (${coco})${countText}`;
}

async function loadPromptHelperDatasets() {
    try {
        const resp = await fetch(`${API_ROOT}/sam3/datasets`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        promptHelperState.datasets = Array.isArray(data) ? data : [];
        if (!promptHelperState.selectedId && promptHelperState.datasets.length) {
            promptHelperState.selectedId = promptHelperState.datasets[0].id;
        }
        if (promptHelperElements.datasetSelect) {
            promptHelperElements.datasetSelect.innerHTML = "";
            promptHelperState.datasets.forEach((entry) => {
                const opt = document.createElement("option");
                opt.value = entry.id;
                opt.textContent = `${entry.label || entry.id}${entry.coco_ready ? "" : " (needs convert)"}`;
                if (entry.id === promptHelperState.selectedId) {
                    opt.selected = true;
                }
                promptHelperElements.datasetSelect.appendChild(opt);
            });
        }
        const selected = promptHelperState.datasets.find((d) => d.id === promptHelperState.selectedId) || promptHelperState.datasets[0];
        promptHelperState.selectedId = selected ? selected.id : null;
        updatePromptHelperDatasetSummary(selected);
    } catch (err) {
        console.error("Failed to load datasets for prompt helper", err);
        setPromptHelperMessage(`Failed to load datasets: ${err.message || err}`, "error");
    }
}

async function loadPromptHelperPresets() {
    try {
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/presets`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        promptHelperState.presets = Array.isArray(data) ? data : [];
        if (promptHelperElements.presetSelect) {
            promptHelperElements.presetSelect.innerHTML = "";
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "Select preset…";
            promptHelperElements.presetSelect.appendChild(placeholder);
            promptHelperState.presets.forEach((p) => {
                const opt = document.createElement("option");
                opt.value = p.id;
                const ds = p.dataset_id ? ` • ${p.dataset_id}` : "";
                opt.textContent = `${p.label || p.id}${ds}`;
                promptHelperElements.presetSelect.appendChild(opt);
            });
        }
    } catch (err) {
        console.error("Failed to load prompt helper presets", err);
    }
}

async function savePromptHelperPreset() {
    const datasetId = promptHelperState.selectedId;
    if (!datasetId) {
        setPromptHelperMessage("Select a dataset first.", "warn");
        return;
    }
    const promptsMap = collectPromptsFromUi();
    if (!Object.keys(promptsMap).length) {
        setPromptHelperMessage("Add prompts before saving.", "warn");
        return;
    }
    const label = promptHelperElements.presetName?.value?.trim() || "";
    try {
        const form = new FormData();
        form.append("dataset_id", datasetId);
        form.append("label", label);
        form.append("prompts_json", JSON.stringify(promptsMap));
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/presets`, {
            method: "POST",
            body: form,
        });
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || `HTTP ${resp.status}`);
        }
        const preset = await resp.json();
        setPromptHelperMessage(`Saved preset ${preset.label || preset.id}.`, "success");
        await loadPromptHelperPresets();
        if (promptHelperElements.presetSelect) {
            promptHelperElements.presetSelect.value = preset.id;
        }
    } catch (err) {
        console.error("Prompt helper preset save failed", err);
        setPromptHelperMessage(`Save failed: ${err.message || err}`, "error");
    }
}

async function loadPromptHelperPresetIntoUi() {
    const presetId = promptHelperElements.presetSelect?.value;
    if (!presetId) {
        setPromptHelperMessage("Choose a preset to load.", "warn");
        return;
    }
    const datasetId = promptHelperState.selectedId;
    if (!datasetId) {
        setPromptHelperMessage("Select a dataset first.", "warn");
        return;
    }
    if (!promptHelperState.suggestions.length) {
        setPromptHelperMessage("Generate prompts first, then load a preset to edit/evaluate.", "warn");
        return;
    }
    try {
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/presets/${encodeURIComponent(presetId)}`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const preset = await resp.json();
        if (preset.dataset_id && preset.dataset_id !== datasetId) {
            setPromptHelperMessage(`Preset is for dataset ${preset.dataset_id}; switch dataset to use it.`, "warn");
            return;
        }
        const map = preset.prompts_by_class || {};
        const normalized = {};
        Object.entries(map).forEach(([k, v]) => {
            const vals = Array.isArray(v) ? v.map((s) => String(s).trim()).filter(Boolean) : [];
            if (vals.length) {
                normalized[parseInt(k, 10)] = vals;
            }
        });
        promptHelperState.promptsByClass = normalized;
        renderPromptHelperPrompts();
        setPromptHelperMessage(`Loaded preset ${preset.label || preset.id}.`, "success");
        if (promptHelperElements.evaluateButton) promptHelperElements.evaluateButton.disabled = false;
    } catch (err) {
        console.error("Prompt helper preset load failed", err);
        setPromptHelperMessage(`Load failed: ${err.message || err}`, "error");
    }
}

function formatMetric(value, digits = 3) {
    if (value === null || value === undefined || Number.isNaN(value)) return "–";
    return Number(value).toFixed(digits);
}

function renderPromptHelperPrompts() {
    if (!promptHelperElements.prompts) return;
    promptHelperElements.prompts.innerHTML = "";
    const classes = promptHelperState.suggestions || [];
    if (!classes.length) {
        const empty = document.createElement("div");
        empty.className = "training-help";
        empty.textContent = "Generate prompts to edit and evaluate.";
        promptHelperElements.prompts.appendChild(empty);
        return;
    }
    const frag = document.createDocumentFragment();
    classes.forEach((cls) => {
        const card = document.createElement("div");
        card.className = "training-card";
        const header = document.createElement("div");
        header.className = "training-card__header";
        const title = document.createElement("div");
        title.className = "training-card__title";
        const metaBits = [];
        if (cls.image_count) metaBits.push(`${cls.image_count} images`);
        if (cls.gt_count) metaBits.push(`${cls.gt_count} boxes`);
        const name = cls.class_name || cls.class_id;
        title.innerHTML = `<strong>${name}</strong>${metaBits.length ? ` <span class="training-help">(${metaBits.join(" / ")})</span>` : ""}`;
        header.appendChild(title);
        card.appendChild(header);
        const body = document.createElement("div");
        body.className = "training-card__body";
        const label = document.createElement("label");
        label.textContent = "Prompts (comma or newline separated)";
        label.setAttribute("for", `promptHelperInput-${cls.class_id}`);
        const textarea = document.createElement("textarea");
        textarea.id = `promptHelperInput-${cls.class_id}`;
        textarea.rows = 2;
        const prompts = promptHelperState.promptsByClass[cls.class_id] || cls.default_prompts || [];
        textarea.value = prompts.join(", ");
        body.appendChild(label);
        body.appendChild(textarea);
        const hint = document.createElement("div");
        hint.className = "training-help";
        hint.textContent = "Edit before evaluation; first prompt is used as-is.";
        body.appendChild(hint);
        card.appendChild(body);
        frag.appendChild(card);
    });
    promptHelperElements.prompts.appendChild(frag);
}

function collectPromptsFromUi() {
    const map = {};
    (promptHelperState.suggestions || []).forEach((cls) => {
        const input = document.getElementById(`promptHelperInput-${cls.class_id}`);
        if (!input) return;
        const raw = input.value || "";
        const parts = raw
            .split(/[\n,]+/)
            .map((p) => p.trim())
            .filter(Boolean);
        if (parts.length) {
            map[cls.class_id] = parts;
        }
    });
    promptHelperState.promptsByClass = map;
    return map;
}

function renderPromptHelperResults(job) {
    if (!promptHelperElements.status || !promptHelperElements.results || !promptHelperElements.summary) return;
    promptHelperElements.status.textContent = `${job.status.toUpperCase()}: ${job.message || ""}`;
    promptHelperElements.summary.textContent = "";
    promptHelperElements.results.innerHTML = "";
    if (promptHelperElements.logs) {
        promptHelperElements.logs.innerHTML = "";
    }
    if (promptHelperElements.summary) {
        promptHelperElements.summary.title =
            "Score = F1 * (0.5 + 0.5 * detection-rate). Higher is better; balances precision, recall, and how many images yielded matches.";
    }
    if (job.error) {
        const errEl = document.createElement("div");
        errEl.className = "training-message error";
        errEl.textContent = job.error;
        promptHelperElements.results.appendChild(errEl);
        return;
    }
    const result = job.result;
    if (!result || !Array.isArray(result.classes)) {
        promptHelperElements.summary.textContent = "No results yet.";
        return;
    }
    const cfg = result.config || {};
    promptHelperElements.summary.textContent = `Dataset ${result.dataset_id || ""} • ${cfg.sample_per_class || "?"} images/class • score ≥ ${cfg.score_threshold ?? "?"} • max dets ${cfg.max_dets ?? "?"} • IoU ${cfg.iou_threshold ?? "?"} • seed ${cfg.seed ?? "?"}`;
    if (Array.isArray(job.logs) && promptHelperElements.logs) {
        const logFrag = document.createDocumentFragment();
        job.logs.slice(-200).forEach((entry) => {
            const div = document.createElement("div");
            div.className = "training-log-line";
            const ts = entry.ts ? new Date(entry.ts * 1000).toLocaleTimeString() : "";
            div.textContent = `${ts ? `[${ts}] ` : ""}${entry.msg || entry.message || entry}`;
            logFrag.appendChild(div);
        });
        promptHelperElements.logs.appendChild(logFrag);
    }
    const frag = document.createDocumentFragment();
    result.classes.forEach((cls) => {
        const card = document.createElement("div");
        card.className = "training-card";
        const header = document.createElement("div");
        header.className = "training-card__header";
        const title = document.createElement("div");
        title.className = "training-card__title";
        title.textContent = `${cls.class_name || cls.class_id} (sampled ${cls.images_sampled || 0} images)`;
        header.appendChild(title);
        card.appendChild(header);
        const body = document.createElement("div");
        body.className = "training-card__body";
        const table = document.createElement("table");
        table.className = "metric-table";
        const thead = document.createElement("thead");
        thead.innerHTML = `
                <tr>
                    <th>Score</th>
                    <th>Prompt</th>
                    <th>Detects/img</th>
                    <th>Precision</th>
                    <th>Recall</th>
                    <th>Avg IoU</th>
                    <th>Avg score</th>
                    <th>Preds</th>
                    <th>GTs</th>
                </tr>
            `;
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        (cls.candidates || []).forEach((cand) => {
            const row = document.createElement("tr");
            const detsPerImg = cls.images_sampled ? (cand.matches || 0) / cls.images_sampled : 0;
            row.innerHTML = `
                    <td>${formatMetric(cand.score, 3)}</td>
                    <td>${cand.prompt}</td>
                    <td>${formatMetric(detsPerImg, 2)}</td>
                    <td>${formatMetric(cand.precision, 3)}</td>
                    <td>${formatMetric(cand.recall, 3)}</td>
                    <td>${formatMetric(cand.avg_iou, 3)}</td>
                    <td>${formatMetric(cand.avg_score, 3)}</td>
                    <td>${cand.preds ?? 0}</td>
                    <td>${cand.gts ?? 0}</td>
                `;
            tbody.appendChild(row);
        });
        table.appendChild(tbody);
        body.appendChild(table);
        card.appendChild(body);
        frag.appendChild(card);
    });
    promptHelperElements.results.appendChild(frag);
    if (promptHelperElements.applyButton) {
        promptHelperElements.applyButton.disabled = false;
    }
}

function renderPromptSearchResults(job) {
    if (!promptSearchElements.results || !promptSearchElements.status) return;
    promptSearchElements.results.innerHTML = "";
    if (promptSearchElements.logs) promptSearchElements.logs.innerHTML = "";
    if (job.error) {
        const err = document.createElement("div");
        err.className = "training-message error";
        err.textContent = job.error;
        promptSearchElements.results.appendChild(err);
        return;
    }
    const result = job.result;
    if (!result || !Array.isArray(result.classes)) {
        return;
    }
    const cfg = result.config || {};
    const summaryBits = [
        `Dataset ${result.dataset_id || ""}`,
        `${cfg.sample_per_class ?? "?"} pos/imgs`,
        `${cfg.negatives_per_class ?? 0} neg/imgs`,
        `score ≥ ${cfg.score_threshold ?? "?"}`,
        `max dets ${cfg.max_dets ?? "?"}`,
        `IoU ${cfg.iou_threshold ?? "?"}`,
        `precision floor ${cfg.precision_floor ?? "?"}`,
        `seed ${cfg.seed ?? "?"}`,
    ];
    if (cfg.class_id !== undefined && cfg.class_id !== null) {
        summaryBits.unshift(`Class ${cfg.class_id}`);
    }
    if (promptSearchElements.status) {
        promptSearchElements.status.title = "Search score boosts recall/det-rate but penalizes prompts that fall below the precision floor.";
        promptSearchElements.status.textContent = `${job.status.toUpperCase()}: ${job.message || ""}`;
    }
    if (promptSearchElements.message) {
        promptSearchElements.message.textContent = summaryBits.join(" • ");
    }
    const frag = document.createDocumentFragment();
    result.classes.forEach((cls) => {
        const card = document.createElement("div");
        card.className = "training-card";
        const header = document.createElement("div");
        header.className = "training-card__header";
        const title = document.createElement("div");
        title.className = "training-card__title";
        title.textContent = `${cls.class_name || cls.class_id} (pos ${cls.positive_images || 0} / neg ${cls.negative_images || 0})`;
        header.appendChild(title);
        card.appendChild(header);
        const body = document.createElement("div");
        body.className = "training-card__body";
        const table = document.createElement("table");
        table.className = "metric-table";
        const thead = document.createElement("thead");
        thead.innerHTML = `
                <tr>
                    <th>Best?</th>
                    <th>Search score</th>
                    <th>Prompt</th>
                    <th>Precision</th>
                    <th>Recall</th>
                    <th>Det rate</th>
                    <th>Avg IoU</th>
                    <th>Preds</th>
                    <th>GTs</th>
                    <th>FPs</th>
                </tr>
            `;
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        (cls.candidates || []).forEach((cand, idx) => {
            const row = document.createElement("tr");
            if (idx === 0) row.classList.add("metric-table__highlight");
            const detRate = cand.det_rate ?? 0;
            row.innerHTML = `
                    <td>${idx === 0 ? "★" : ""}</td>
                    <td>${formatMetric(cand.search_score, 3)}</td>
                    <td>${cand.prompt}</td>
                    <td>${formatMetric(cand.precision, 3)}</td>
                    <td>${formatMetric(cand.recall, 3)}</td>
                    <td>${formatMetric(detRate, 3)}</td>
                    <td>${formatMetric(cand.avg_iou, 3)}</td>
                    <td>${cand.preds ?? 0}</td>
                    <td>${cand.gts ?? 0}</td>
                    <td>${cand.fps ?? 0}</td>
                `;
            tbody.appendChild(row);
        });
        table.appendChild(tbody);
        body.appendChild(table);
        card.appendChild(body);
        frag.appendChild(card);
    });
    promptSearchElements.results.appendChild(frag);
}

    function renderPromptRecipeResults(job) {
        if (!promptRecipeElements.results || !promptRecipeElements.status) return;
        promptRecipeElements.results.innerHTML = "";
        if (promptRecipeElements.logs) promptRecipeElements.logs.innerHTML = "";
        if (promptRecipeElements.applyButton) promptRecipeElements.applyButton.disabled = true;
    if (job.error) {
        const err = document.createElement("div");
        err.className = "training-message error";
        err.textContent = job.error;
        promptRecipeElements.results.appendChild(err);
        return;
    }
    const result = job.result;
    if (!result) return;
    const recipe = result.recipe || {};
    const steps = Array.isArray(recipe.steps) ? recipe.steps : [];
    const stepCount = steps.length;
    const summary = recipe.summary || {};
    const posIds = Array.isArray(result.positive_image_ids) ? result.positive_image_ids : [];
    const negIds = Array.isArray(result.negative_image_ids) ? result.negative_image_ids : [];
    const seedVal = result.config ? result.config.seed : null;
    const recipeLabel = result.class_name || result.class_id || "recipe";
    if (promptRecipeElements.status) {
        promptRecipeElements.status.textContent = `${job.status.toUpperCase()}: ${job.message || ""}`;
        promptRecipeElements.status.title =
            "Simulated per-image early stop: run prompts in order, skip covered images to avoid extra FPs, best threshold per prompt, drop zero-gain steps.";
    }
    const frag = document.createDocumentFragment();
    const summaryCard = document.createElement("div");
    summaryCard.className = "training-card";
    const summaryBody = document.createElement("div");
    summaryBody.className = "training-card__body";
    const coverageRate = Number.isFinite(summary.coverage_rate) ? (summary.coverage_rate * 100).toFixed(1) : "0";
    summaryBody.innerHTML = `
        <div><strong>Class:</strong> ${escapeHtml(result.class_name || result.class_id)}</div>
        <div><strong>Recipe:</strong> ${stepCount} step${stepCount === 1 ? "" : "s"} (best threshold per prompt; dropped no-gain steps)</div>
        <div><strong>Simulation:</strong> Per-image early stop; negatives run every step. Precision per step uses only images still active.</div>
        <div><strong>Sample:</strong> ${posIds.length} pos / ${negIds.length} neg${Number.isFinite(seedVal) ? ` (seed ${seedVal})` : ""}</div>
        <div><strong>Coverage:</strong> ${summary.covered || 0}/${summary.total_gt || 0} (${coverageRate}%)
        • FPs: ${summary.fps || 0}
        • Duplicates: ${summary.duplicates || 0}
        • Pos imgs: ${result.positive_images || 0}
        • Neg imgs: ${result.negative_images || 0}</div>
    `;
    if (posIds.length || negIds.length) {
        const samplePreview = document.createElement("div");
        samplePreview.className = "training-help";
        const preview = (arr) => {
            if (!arr.length) return "none";
            const slice = arr.slice(0, 12).join(", ");
            return arr.length > 12 ? `${slice} … (${arr.length} total)` : slice;
        };
        samplePreview.textContent = `Pos IDs: ${preview(posIds)} • Neg IDs: ${preview(negIds)}`;
        summaryBody.appendChild(samplePreview);
        const copyRow = document.createElement("div");
        copyRow.className = "training-actions";
        const makeCopyBtn = (label, ids) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.className = "training-button secondary";
            btn.textContent = label;
            btn.addEventListener("click", async () => {
                const text = ids.join(",");
                try {
                    await navigator.clipboard.writeText(text);
                    setPromptRecipeMessage(`Copied ${label.toLowerCase()}.`, "success");
                } catch (err) {
                    setPromptRecipeMessage(`Copy failed: ${err.message || err}`, "error");
                }
            });
            return btn;
        };
        if (posIds.length) copyRow.appendChild(makeCopyBtn("Copy pos IDs", posIds));
        if (negIds.length) copyRow.appendChild(makeCopyBtn("Copy neg IDs", negIds));
        summaryBody.appendChild(copyRow);
    }
    if (steps.length) {
        const downloadRow = document.createElement("div");
        downloadRow.className = "training-actions";
        const dlBtn = document.createElement("button");
        dlBtn.type = "button";
        dlBtn.className = "training-button secondary";
        dlBtn.textContent = "Download recipe JSON";
        dlBtn.addEventListener("click", () => {
            const payload = {
                id: `recipe_${Date.now()}`,
                label: `${recipeLabel}_recipe`,
                class_name: result.class_name,
                class_id: result.class_id,
                seed: seedVal,
                steps: steps.map((s) => ({ prompt: s.prompt, threshold: s.threshold })),
            };
            const blob = new Blob([JSON.stringify(payload, null, 2)], { type: "application/json" });
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${recipeLabel}_recipe.json`;
            a.click();
            URL.revokeObjectURL(url);
        });
        downloadRow.appendChild(dlBtn);
        summaryBody.appendChild(downloadRow);
    }
    summaryCard.appendChild(summaryBody);
    frag.appendChild(summaryCard);

    if (steps.length) {
        const stepCard = document.createElement("div");
        stepCard.className = "training-card";
        const body = document.createElement("div");
        body.className = "training-card__body";
        const title = document.createElement("div");
        title.className = "training-card__title";
        title.textContent = "Best sequence (run top-to-bottom)";
        body.appendChild(title);
        const helper = document.createElement("div");
        helper.className = "training-help";
        helper.textContent =
            "Run prompts in order. Stops running later prompts on images once their GTs are covered (to reduce FPs). Adds = new GTs covered by this step. Cov% is cumulative. FPs shows step vs running total. Prec is recalculated on images still active at this step.";
        body.appendChild(helper);
        const sequenceLabel = steps
            .map((step) => {
                const thr = typeof step.threshold === "number" ? step.threshold.toFixed(2) : step.threshold;
                const thrLabel = thr !== undefined && thr !== null ? ` @ ${thr}` : "";
                return `${step.prompt || ""}${thrLabel}`.trim();
            })
            .filter(Boolean)
            .join(" → ");
        if (sequenceLabel) {
            const sequence = document.createElement("div");
            sequence.className = "training-help";
            sequence.textContent = `Use this order: ${sequenceLabel}`;
            body.appendChild(sequence);
        }
        const table = document.createElement("table");
        table.className = "metric-table";
        const thead = document.createElement("thead");
        thead.innerHTML = `
            <tr>
                <th>#</th>
                <th>Prompt</th>
                <th>Thr</th>
                <th>Adds</th>
                <th>Cov after %</th>
                <th>FPs (step)</th>
                <th>FPs (total)</th>
                <th>Prec</th>
            </tr>
        `;
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        steps.forEach((step, idx) => {
            const gain = step.gain ?? 0;
            const gainText = gain > 0 ? `+${gain}` : gain;
            const cov =
                Number.isFinite(step.coverage_after) && step.coverage_after > 0
                    ? (step.coverage_after * 100).toFixed(1)
                    : Number.isFinite(step.cum_coverage)
                    ? (step.cum_coverage * 100).toFixed(1)
                    : "0";
            const stepFps = step.fps ?? 0;
            const totalFps = step.cum_fps ?? stepFps;
            const row = document.createElement("tr");
            if (idx === 0) row.classList.add("metric-table__highlight");
            row.innerHTML = `
                <td>${idx + 1}</td>
                <td>${escapeHtml(step.prompt || "")}</td>
                <td>${step.threshold ?? "–"}</td>
                <td>${gainText}</td>
                <td>${cov}</td>
                <td>${stepFps}</td>
                <td>${totalFps}</td>
                <td>${formatMetric(step.precision, 3)}</td>
            `;
            tbody.appendChild(row);
        });
        table.appendChild(tbody);
        body.appendChild(table);
        stepCard.appendChild(body);
        frag.appendChild(stepCard);
    }

    const candidates = Array.isArray(result.candidates) ? result.candidates : [];
    if (candidates.length) {
        const candCard = document.createElement("div");
        candCard.className = "training-card";
        const body = document.createElement("div");
        body.className = "training-card__body";
        const helper = document.createElement("div");
        helper.className = "training-help";
        helper.textContent =
            "All tested prompts/thresholds (no early-stop simulation). We already used the best threshold per prompt in the sequence above.";
        body.appendChild(helper);
        const table = document.createElement("table");
        table.className = "metric-table";
        const thead = document.createElement("thead");
        thead.innerHTML = `
            <tr>
                <th>Prompt</th>
                <th>Thr</th>
                <th>Matched GT</th>
                <th>FPs</th>
                <th>Prec</th>
                <th>Rec</th>
                <th>Det rate</th>
                <th>Avg IoU</th>
                <th>Preds</th>
                <th>GTs</th>
            </tr>
        `;
        table.appendChild(thead);
        const tbody = document.createElement("tbody");
        candidates.forEach((cand) => {
            const row = document.createElement("tr");
            row.innerHTML = `
                <td>${escapeHtml(cand.prompt || "")}</td>
                <td>${cand.threshold ?? "–"}</td>
                <td>${cand.matched_gt ?? 0}</td>
                <td>${cand.fps ?? 0}</td>
                <td>${formatMetric(cand.precision, 3)}</td>
                <td>${formatMetric(cand.recall, 3)}</td>
                <td>${formatMetric(cand.det_rate, 3)}</td>
                <td>${formatMetric(cand.avg_iou, 3)}</td>
                <td>${cand.preds ?? 0}</td>
                <td>${cand.gts ?? 0}</td>
            `;
            tbody.appendChild(row);
        });
        table.appendChild(tbody);
        const details = document.createElement("details");
        const summary = document.createElement("summary");
        summary.textContent = `Show tested prompts (${candidates.length})`;
        details.appendChild(summary);
        details.appendChild(table);
        body.appendChild(details);
        candCard.appendChild(body);
        frag.appendChild(candCard);
    }

    const coverage = Array.isArray(result.coverage_by_image) ? result.coverage_by_image : [];
    if (coverage.length) {
        const covCard = document.createElement("div");
        covCard.className = "training-card";
        const body = document.createElement("div");
        body.className = "training-card__body";
        const helper = document.createElement("div");
        helper.className = "training-help";
        helper.textContent = "Per-image hits on the sampled set (debug view).";
        body.appendChild(helper);
        const list = document.createElement("div");
        coverage.slice(0, 40).forEach((entry) => {
            const hits = (entry.hits || [])
                .map((h) => `#${(h.step ?? 0) + 1}(${h.matched || 0}/${h.fps || 0}fp)`)
                .join(", ");
            const div = document.createElement("div");
            div.className = "training-history-item";
            const kind = entry.type === "neg" ? "NEG" : "POS";
            div.textContent = `[${kind}] ${entry.file_name || entry.image_id}: GT ${entry.gt || 0}, hits [${hits || "none"}]`;
            list.appendChild(div);
        });
        if (coverage.length > 40) {
            const more = document.createElement("div");
            more.className = "training-help";
            more.textContent = `Showing first 40 of ${coverage.length} images.`;
            list.appendChild(more);
        }
        const details = document.createElement("details");
        const summary = document.createElement("summary");
        summary.textContent = `Per-image coverage (${coverage.length} images)`;
        details.appendChild(summary);
        details.appendChild(list);
        body.appendChild(details);
        covCard.appendChild(body);
        frag.appendChild(covCard);
    }

    promptRecipeElements.results.appendChild(frag);
    if (promptRecipeElements.logs && Array.isArray(job.logs)) {
        const logFrag = document.createDocumentFragment();
        job.logs.slice(-200).forEach((entry) => {
            const div = document.createElement("div");
            div.className = "training-log-line";
            const ts = entry.ts ? new Date(entry.ts * 1000).toLocaleTimeString() : "";
            div.textContent = `${ts ? `[${ts}] ` : ""}${entry.msg || entry.message || entry}`;
            logFrag.appendChild(div);
        });
        promptRecipeElements.logs.appendChild(logFrag);
    }
    if (promptRecipeElements.applyButton && job.status === "completed") {
        promptRecipeElements.applyButton.disabled = false;
    }
}

async function pollPromptSearchJob(force = false) {
    if (!promptSearchState.activeJobId) return;
    if (promptSearchState.pollHandle && !force) {
        // interval controls timing
    }
    try {
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/jobs/${encodeURIComponent(promptSearchState.activeJobId)}`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const job = await resp.json();
        promptSearchState.lastJob = job;
        if (promptSearchElements.logs && Array.isArray(job.logs)) {
            const logFrag = document.createDocumentFragment();
            job.logs.slice(-200).forEach((entry) => {
                const div = document.createElement("div");
                div.className = "training-log-line";
                const ts = entry.ts ? new Date(entry.ts * 1000).toLocaleTimeString() : "";
                div.textContent = `${ts ? `[${ts}] ` : ""}${entry.msg || entry.message || entry}`;
                logFrag.appendChild(div);
            });
            promptSearchElements.logs.innerHTML = "";
            promptSearchElements.logs.appendChild(logFrag);
        }
        if (promptSearchElements.status) {
            const pct = job.progress ? Math.round(job.progress * 100) : 0;
            const steps = job.total_steps ? ` • ${job.completed_steps || 0}/${job.total_steps}` : "";
            promptSearchElements.status.textContent = `${job.status.toUpperCase()}: ${job.message || ""} (${pct}%${steps})`;
        }
        if (job.status === "completed" || job.status === "failed") {
            if (promptSearchState.pollHandle) {
                clearInterval(promptSearchState.pollHandle);
                promptSearchState.pollHandle = null;
            }
            if (promptSearchElements.runButton) promptSearchElements.runButton.disabled = false;
            renderPromptSearchResults(job);
        }
    } catch (err) {
        console.error("Prompt search poll failed", err);
        setPromptSearchMessage(`Poll failed: ${err.message || err}`, "error");
    }
}

async function pollPromptRecipeJob(force = false) {
    if (!promptRecipeState.activeJobId) return;
    if (promptRecipeState.pollHandle && !force) {
        // interval controls timing
    }
    try {
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/jobs/${encodeURIComponent(promptRecipeState.activeJobId)}`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const job = await resp.json();
        promptRecipeState.lastJob = job;
        if (promptRecipeElements.logs && Array.isArray(job.logs)) {
            const logFrag = document.createDocumentFragment();
            job.logs.slice(-200).forEach((entry) => {
                const div = document.createElement("div");
                div.className = "training-log-line";
                const ts = entry.ts ? new Date(entry.ts * 1000).toLocaleTimeString() : "";
                div.textContent = `${ts ? `[${ts}] ` : ""}${entry.msg || entry.message || entry}`;
                logFrag.appendChild(div);
            });
            promptRecipeElements.logs.innerHTML = "";
            promptRecipeElements.logs.appendChild(logFrag);
        }
        if (promptRecipeElements.status) {
            const pct = job.progress ? Math.round(job.progress * 100) : 0;
            const steps = job.total_steps ? ` • ${job.completed_steps || 0}/${job.total_steps}` : "";
            promptRecipeElements.status.textContent = `${job.status.toUpperCase()}: ${job.message || ""} (${pct}%${steps})`;
        }
        if (job.status === "completed" || job.status === "failed") {
            if (promptRecipeState.pollHandle) {
                clearInterval(promptRecipeState.pollHandle);
                promptRecipeState.pollHandle = null;
            }
            if (promptRecipeElements.runButton) promptRecipeElements.runButton.disabled = false;
            renderPromptRecipeResults(job);
        }
    } catch (err) {
        console.error("Prompt recipe poll failed", err);
        setPromptRecipeMessage(`Poll failed: ${err.message || err}`, "error");
    }
}

async function startPromptRecipeJob() {
    const datasetId = promptHelperState.selectedId;
    if (!datasetId) {
        setPromptRecipeMessage("Select a dataset first.", "warn");
        return;
    }
    const targetVal = promptRecipeElements.classSelect?.value;
    const classId = targetVal ? parseInt(targetVal, 10) : NaN;
    if (Number.isNaN(classId)) {
        setPromptRecipeMessage("Choose a class to target.", "warn");
        return;
    }
    const promptsMap = collectPromptsFromUi();
    const prompts = promptsMap[classId];
    if (!prompts || !prompts.length) {
        setPromptRecipeMessage("Add prompts for the selected class.", "warn");
        return;
    }
    const sampleSize = readNumberInput(promptRecipeElements.sampleSize, { integer: true }) ?? 30;
    const negatives = readNumberInput(promptRecipeElements.negatives, { integer: true }) ?? 10;
    const maxDets = readNumberInput(promptRecipeElements.maxDets, { integer: true }) ?? 100;
    const iouThreshold = readNumberInput(promptRecipeElements.iouThresh, { integer: false }) ?? 0.5;
    const seed = readNumberInput(promptRecipeElements.seed, { integer: true }) ?? 42;
    const thresholds = readThresholdList(promptRecipeElements.thresholds, 0.2);
    const scoreThreshold = thresholds.length ? thresholds[0] : 0.2;
    const payload = {
        dataset_id: datasetId,
        class_id: classId,
        sample_size: sampleSize,
        negatives,
        max_dets: maxDets,
        iou_threshold: iouThreshold,
        seed,
        score_threshold: scoreThreshold,
        prompts: prompts.map((p) => ({ prompt: p, thresholds })),
    };
    try {
        setPromptRecipeMessage("Starting recipe mining…", "info");
        if (promptRecipeElements.runButton) promptRecipeElements.runButton.disabled = true;
        if (promptRecipeElements.applyButton) promptRecipeElements.applyButton.disabled = true;
        if (promptRecipeElements.status) promptRecipeElements.status.textContent = "Starting recipe job…";
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/recipe`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
        });
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || `HTTP ${resp.status}`);
        }
        const job = await resp.json();
        promptRecipeState.activeJobId = job.job_id;
        promptRecipeState.lastJob = job;
        if (promptRecipeState.pollHandle) clearInterval(promptRecipeState.pollHandle);
        promptRecipeState.pollHandle = setInterval(() => pollPromptRecipeJob(), 2000);
        pollPromptRecipeJob(true);
    } catch (err) {
        console.error("Prompt recipe start failed", err);
        setPromptRecipeMessage(err.message || "Start failed", "error");
        if (promptRecipeElements.runButton) promptRecipeElements.runButton.disabled = false;
    }
}

async function expandPromptRecipePrompts() {
    const datasetId = promptHelperState.selectedId;
    if (!datasetId) {
        setPromptRecipeMessage("Select a dataset first.", "warn");
        return;
    }
    const targetVal = promptRecipeElements.classSelect?.value;
    const classId = targetVal ? parseInt(targetVal, 10) : NaN;
    if (Number.isNaN(classId)) {
        setPromptRecipeMessage("Choose a class to expand.", "warn");
        return;
    }
    const expandCount = readNumberInput(promptRecipeElements.expandCount, { integer: true }) ?? 10;
    const promptsMap = collectPromptsFromUi();
    const prompts = promptsMap[classId] || [];
    if (!prompts.length) {
        setPromptRecipeMessage("Add at least one prompt for the class, then expand.", "warn");
        return;
    }
    try {
        setPromptRecipeMessage("Requesting Qwen expansions…", "info");
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/expand`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                dataset_id: datasetId,
                class_id: classId,
                base_prompts: prompts,
                max_new: expandCount,
            }),
        });
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || `HTTP ${resp.status}`);
        }
        const data = await resp.json();
        const combined = Array.isArray(data.combined) ? data.combined : prompts;
        const target = document.getElementById(`promptHelperInput-${classId}`);
        if (target) {
            target.value = combined.join(", ");
        }
        promptHelperState.promptsByClass[classId] = combined;
        setPromptRecipeMessage(`Added ${Math.max(0, combined.length - prompts.length)} new prompts from Qwen.`, "success");
    } catch (err) {
        console.error("Prompt recipe expand failed", err);
        setPromptRecipeMessage(err.message || "Expand failed", "error");
    }
}

    async function applyLastPromptRecipeToPrompts() {
        const job = promptRecipeState.lastJob;
        const datasetId = promptHelperState.selectedId;
        if (!job || !job.result) {
            setPromptRecipeMessage("Run recipe mining first.", "warn");
            return;
        }
    if (!datasetId) {
        setPromptRecipeMessage("Select a dataset first.", "warn");
        return;
    }
    const result = job.result;
    const classId = result.class_id;
    const steps = result.recipe && Array.isArray(result.recipe.steps) ? result.recipe.steps : [];
    if (classId === undefined || classId === null) {
        setPromptRecipeMessage("No class in the last recipe result.", "warn");
        return;
    }
    if (!steps.length) {
        setPromptRecipeMessage("Recipe is empty; nothing to apply.", "warn");
        return;
    }
    const orderedPrompts = [];
    const seen = new Set();
    steps.forEach((step) => {
        const p = (step.prompt || "").trim();
        if (!p) return;
        const key = p.toLowerCase();
        if (seen.has(key)) return;
        seen.add(key);
        orderedPrompts.push(p);
    });
    if (!orderedPrompts.length) {
        setPromptRecipeMessage("No prompts to apply from recipe.", "warn");
        return;
    }
    const thresholds = [];
    const thrSeen = new Set();
    steps.forEach((step) => {
        if (typeof step.threshold !== "number") return;
        const key = step.threshold.toFixed(4);
        if (thrSeen.has(key)) return;
        thrSeen.add(key);
        thresholds.push(step.threshold);
    });
    promptHelperState.promptsByClass[classId] = orderedPrompts;
    const target = document.getElementById(`promptHelperInput-${classId}`);
    if (target) {
        target.value = orderedPrompts.join(", ");
    }
    if (promptRecipeElements.thresholds && thresholds.length) {
        promptRecipeElements.thresholds.value = thresholds.map((t) => t.toFixed(2)).join(", ");
    }
    setPromptRecipeMessage(
        `Applied recipe to prompts for class ${classId}. Save a preset to keep it.`,
        "success"
    );
}

async function startPromptSearchJob() {
    const datasetId = promptHelperState.selectedId;
    if (!datasetId) {
        setPromptSearchMessage("Select a dataset first.", "warn");
        return;
    }
    if (!promptHelperState.suggestions.length) {
        setPromptSearchMessage("Generate prompts first, then run search.", "warn");
        return;
    }
    const promptsMap = collectPromptsFromUi();
    if (!Object.keys(promptsMap).length) {
        setPromptSearchMessage("Add prompts for at least one class.", "warn");
        return;
    }
    const samplePerClass = readNumberInput(promptSearchElements.sampleSize, { integer: true }) ?? 20;
    const negativesPerClass = readNumberInput(promptSearchElements.negatives, { integer: true }) ?? 20;
    const precisionFloor = readNumberInput(promptSearchElements.precisionFloor, { integer: false }) ?? 0.9;
    const scoreThreshold = readNumberInput(promptSearchElements.scoreThresh, { integer: false }) ?? 0.2;
    const maxDets = readNumberInput(promptSearchElements.maxDets, { integer: true }) ?? 100;
    const iouThreshold = readNumberInput(promptSearchElements.iouThresh, { integer: false }) ?? 0.5;
    const seed = readNumberInput(promptSearchElements.seed, { integer: true }) ?? 42;
    const targetVal = promptSearchElements.classSelect?.value;
    let classId = null;
    if (targetVal && targetVal !== "all") {
        const parsed = parseInt(targetVal, 10);
        if (!Number.isNaN(parsed)) classId = parsed;
    }
    try {
        setPromptSearchMessage("Starting prompt search…", "info");
        if (promptSearchElements.runButton) promptSearchElements.runButton.disabled = true;
        if (promptSearchElements.status) promptSearchElements.status.textContent = "Starting search…";
        const payload = {
            dataset_id: datasetId,
            sample_per_class: samplePerClass,
            negatives_per_class: negativesPerClass,
            score_threshold: scoreThreshold,
            max_dets: maxDets,
            iou_threshold: iouThreshold,
            seed,
            precision_floor: precisionFloor,
            prompts_by_class: promptsMap,
            class_id: classId,
        };
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/search`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
        });
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || `HTTP ${resp.status}`);
        }
        const job = await resp.json();
        promptSearchState.activeJobId = job.job_id;
        promptSearchState.lastJob = job;
        if (promptSearchState.pollHandle) clearInterval(promptSearchState.pollHandle);
        promptSearchState.pollHandle = setInterval(() => pollPromptSearchJob(), 2000);
        pollPromptSearchJob(true);
    } catch (err) {
        console.error("Prompt search start failed", err);
        setPromptSearchMessage(`Start failed: ${err.message || err}`, "error");
        if (promptSearchElements.runButton) promptSearchElements.runButton.disabled = false;
    }
}

async function pollPromptHelperJob(force = false) {
    if (!promptHelperState.activeJobId) return;
    if (promptHelperState.pollHandle && !force) {
        // interval controls timing
    }
    try {
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/jobs/${encodeURIComponent(promptHelperState.activeJobId)}`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const job = await resp.json();
        promptHelperState.lastJob = job;
        console.info("[prompt-helper] poll", job);
        if (promptHelperElements.logs && Array.isArray(job.logs)) {
            const logFrag = document.createDocumentFragment();
            job.logs.slice(-200).forEach((entry) => {
                const div = document.createElement("div");
                div.className = "training-log-line";
                const ts = entry.ts ? new Date(entry.ts * 1000).toLocaleTimeString() : "";
                div.textContent = `${ts ? `[${ts}] ` : ""}${entry.msg || entry.message || entry}`;
                logFrag.appendChild(div);
            });
            promptHelperElements.logs.innerHTML = "";
            promptHelperElements.logs.appendChild(logFrag);
        }
        if (promptHelperElements.status) {
            const pct = job.progress ? Math.round(job.progress * 100) : 0;
            const steps = job.total_steps ? ` • ${job.completed_steps || 0}/${job.total_steps}` : "";
            promptHelperElements.status.textContent = `${job.status.toUpperCase()}: ${job.message || ""} (${pct}%${steps})`;
        }
        if (job.status === "completed" || job.status === "failed") {
            if (promptHelperState.pollHandle) {
                clearInterval(promptHelperState.pollHandle);
                promptHelperState.pollHandle = null;
            }
            if (promptHelperElements.evaluateButton) {
                promptHelperElements.evaluateButton.disabled = false;
            }
            renderPromptHelperResults(job);
        }
    } catch (err) {
        console.error("Prompt helper poll failed", err);
        setPromptHelperMessage(`Poll failed: ${err.message || err}`, "error");
    }
}

async function generatePromptHelperPrompts() {
    const datasetId = promptHelperState.selectedId;
    if (!datasetId) {
        setPromptHelperMessage("Select a dataset first.", "warn");
        return;
    }
    const maxSynonyms = readNumberInput(promptHelperElements.maxSynonyms, { integer: true }) ?? 3;
    const useQwen = promptHelperElements.useQwen ? !!promptHelperElements.useQwen.checked : true;
    try {
        setPromptHelperMessage("Generating prompt suggestions…", "info");
        if (promptHelperElements.evaluateButton) promptHelperElements.evaluateButton.disabled = true;
        console.info("[prompt-helper] generating suggestions", { datasetId, maxSynonyms, useQwen });
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/suggest`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                dataset_id: datasetId,
                max_synonyms: maxSynonyms,
                use_qwen: useQwen,
            }),
        });
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || `HTTP ${resp.status}`);
        }
        const data = await resp.json();
        console.info("[prompt-helper] suggestions received", data);
        promptHelperState.suggestions = Array.isArray(data.classes) ? data.classes : [];
        promptHelperState.promptsByClass = {};
        promptHelperState.suggestions.forEach((cls) => {
            if (Array.isArray(cls.default_prompts) && cls.default_prompts.length) {
                promptHelperState.promptsByClass[cls.class_id] = cls.default_prompts;
            }
        });
        populatePromptSearchClassSelect();
        promptHelperState.lastJob = null;
        promptHelperState.activeJobId = null;
        renderPromptHelperPrompts();
        if (promptHelperElements.results) promptHelperElements.results.innerHTML = "";
        if (promptHelperElements.summary) promptHelperElements.summary.textContent = "Prompts ready; run evaluation to score them.";
        if (promptHelperElements.status) promptHelperElements.status.textContent = "Generated prompts (not evaluated yet).";
        setPromptHelperMessage("Suggestions ready. Review/edit, then evaluate with SAM3.", "success");
        if (promptHelperElements.evaluateButton) promptHelperElements.evaluateButton.disabled = false;
    } catch (err) {
        console.error("Prompt helper suggest failed", err);
        setPromptHelperMessage(`Generation failed: ${err.message || err}`, "error");
    }
}

async function startPromptHelperJob() {
    const datasetId = promptHelperState.selectedId;
    if (!datasetId) {
        setPromptHelperMessage("Select a dataset first.", "warn");
        return;
    }
    const samplePerClass = readNumberInput(promptHelperElements.sampleSize, { integer: true }) ?? 20;
    const maxSynonyms = readNumberInput(promptHelperElements.maxSynonyms, { integer: true }) ?? 3;
    const scoreThreshold = readNumberInput(promptHelperElements.scoreThresh, { integer: false }) ?? 0.2;
    const maxDets = readNumberInput(promptHelperElements.maxDets, { integer: true }) ?? 100;
    const iouThreshold = readNumberInput(promptHelperElements.iouThresh, { integer: false }) ?? 0.5;
    const seed = readNumberInput(promptHelperElements.seed, { integer: true }) ?? 42;
    const useQwen = promptHelperElements.useQwen ? !!promptHelperElements.useQwen.checked : true;
    const promptsMap = collectPromptsFromUi();
    if (!Object.keys(promptsMap).length) {
        setPromptHelperMessage("Add prompts for at least one class, or generate suggestions first.", "warn");
        return;
    }
    setPromptHelperMessage("Starting prompt helper evaluation…", "info");
    if (promptHelperElements.applyButton) {
        promptHelperElements.applyButton.disabled = true;
    }
    if (promptHelperElements.evaluateButton) {
        promptHelperElements.evaluateButton.disabled = true;
    }
    if (promptHelperElements.status) {
        promptHelperElements.status.textContent = "Starting evaluation…";
    }
    try {
        const payload = {
            dataset_id: datasetId,
            sample_per_class: samplePerClass,
            max_synonyms: maxSynonyms,
            score_threshold: scoreThreshold,
            max_dets: maxDets,
            iou_threshold: iouThreshold,
            seed,
            use_qwen: useQwen,
            prompts_by_class: promptsMap,
        };
        console.info("[prompt-helper] starting evaluation", payload);
        const resp = await fetch(`${API_ROOT}/sam3/prompt_helper/jobs`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
        });
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || `HTTP ${resp.status}`);
        }
        const job = await resp.json();
        promptHelperState.activeJobId = job.job_id;
        promptHelperState.lastJob = job;
        if (promptHelperState.pollHandle) {
            clearInterval(promptHelperState.pollHandle);
        }
        promptHelperState.pollHandle = setInterval(() => pollPromptHelperJob(), 2000);
        pollPromptHelperJob(true);
    } catch (err) {
        console.error("Prompt helper start failed", err);
        setPromptHelperMessage(`Start failed: ${err.message || err}`, "error");
    }
}

function applyPromptHelperMapping() {
    const job = promptHelperState.lastJob;
    if (!job || !job.result || !Array.isArray(job.result.classes)) {
        setPromptHelperMessage("No completed results to apply.", "warn");
        return;
    }
    const lines = [];
    job.result.classes.forEach((cls) => {
        const prompts = (cls.candidates || []).slice(0, 3).map((c) => c.prompt).filter(Boolean);
        if (prompts.length) {
            lines.push(`${cls.class_name || cls.class_id}: ${prompts.join(", ")}`);
        }
    });
    if (!lines.length) {
        setPromptHelperMessage("No prompts to apply.", "warn");
        return;
    }
    if (sam3TrainElements.promptVariants) {
        sam3TrainElements.promptVariants.value = lines.join("\n");
    }
    setPromptHelperMessage("Applied top prompts to SAM3 training form.", "success");
}

async function initPromptHelperUi() {
    if (promptHelperInitialized) {
        return;
    }
    promptHelperInitialized = true;
    promptHelperElements.datasetSelect = document.getElementById("promptHelperDatasetSelect");
    promptHelperElements.datasetRefresh = document.getElementById("promptHelperDatasetRefresh");
    promptHelperElements.datasetSummary = document.getElementById("promptHelperDatasetSummary");
    promptHelperElements.sampleSize = document.getElementById("promptHelperSampleSize");
    promptHelperElements.maxSynonyms = document.getElementById("promptHelperMaxSynonyms");
    promptHelperElements.scoreThresh = document.getElementById("promptHelperScoreThresh");
    promptHelperElements.maxDets = document.getElementById("promptHelperMaxDets");
    promptHelperElements.iouThresh = document.getElementById("promptHelperIouThresh");
    promptHelperElements.seed = document.getElementById("promptHelperSeed");
    promptHelperElements.useQwen = document.getElementById("promptHelperUseQwen");
    promptHelperElements.generateButton = document.getElementById("promptHelperGenerateBtn");
    promptHelperElements.evaluateButton = document.getElementById("promptHelperEvaluateBtn");
    promptHelperElements.presetName = document.getElementById("promptHelperPresetName");
    promptHelperElements.presetSaveBtn = document.getElementById("promptHelperPresetSave");
    promptHelperElements.presetSelect = document.getElementById("promptHelperPresetSelect");
    promptHelperElements.presetLoadBtn = document.getElementById("promptHelperPresetLoad");
    promptHelperElements.status = document.getElementById("promptHelperStatus");
    promptHelperElements.summary = document.getElementById("promptHelperSummary");
    promptHelperElements.prompts = document.getElementById("promptHelperPrompts");
    promptHelperElements.results = document.getElementById("promptHelperResults");
    promptHelperElements.logs = document.getElementById("promptHelperLogs");
    promptHelperElements.message = document.getElementById("promptHelperMessage");
    promptHelperElements.applyButton = document.getElementById("promptHelperApplyBtn");
    populatePromptSearchClassSelect();
    promptSearchElements.sampleSize = document.getElementById("promptSearchSampleSize");
    promptSearchElements.negatives = document.getElementById("promptSearchNegatives");
    promptSearchElements.precisionFloor = document.getElementById("promptSearchPrecisionFloor");
    promptSearchElements.scoreThresh = document.getElementById("promptSearchScoreThresh");
    promptSearchElements.maxDets = document.getElementById("promptSearchMaxDets");
    promptSearchElements.iouThresh = document.getElementById("promptSearchIouThresh");
    promptSearchElements.seed = document.getElementById("promptSearchSeed");
    promptSearchElements.runButton = document.getElementById("promptSearchRunBtn");
    promptSearchElements.classSelect = document.getElementById("promptSearchClassSelect");
    promptSearchElements.status = document.getElementById("promptSearchStatus");
    promptSearchElements.logs = document.getElementById("promptSearchLogs");
    promptSearchElements.results = document.getElementById("promptSearchResults");
    promptSearchElements.message = document.getElementById("promptSearchMessage");
    promptRecipeElements.classSelect = document.getElementById("promptRecipeClassSelect");
    promptRecipeElements.sampleSize = document.getElementById("promptRecipeSampleSize");
    promptRecipeElements.negatives = document.getElementById("promptRecipeNegatives");
    promptRecipeElements.thresholds = document.getElementById("promptRecipeThresholds");
    promptRecipeElements.maxDets = document.getElementById("promptRecipeMaxDets");
    promptRecipeElements.iouThresh = document.getElementById("promptRecipeIouThresh");
    promptRecipeElements.seed = document.getElementById("promptRecipeSeed");
    promptRecipeElements.expandCount = document.getElementById("promptRecipeExpandCount");
    promptRecipeElements.expandButton = document.getElementById("promptRecipeExpandBtn");
    promptRecipeElements.runButton = document.getElementById("promptRecipeRunBtn");
    promptRecipeElements.applyButton = document.getElementById("promptRecipeApplyBtn");
    promptRecipeElements.status = document.getElementById("promptRecipeStatus");
    promptRecipeElements.logs = document.getElementById("promptRecipeLogs");
    promptRecipeElements.results = document.getElementById("promptRecipeResults");
    promptRecipeElements.message = document.getElementById("promptRecipeMessage");
    if (promptRecipeElements.applyButton) {
        promptRecipeElements.applyButton.disabled = true;
    }

    sam3RecipeElements.fileInput = document.getElementById("sam3RecipeFile");
    sam3RecipeElements.applyButton = document.getElementById("sam3RecipeApplyButton");
    sam3RecipeElements.status = document.getElementById("sam3RecipeStatus");
    if (promptHelperElements.evaluateButton) {
        promptHelperElements.evaluateButton.disabled = true;
    }

    if (promptHelperElements.datasetSelect) {
        promptHelperElements.datasetSelect.addEventListener("change", (e) => {
            promptHelperState.selectedId = e.target.value;
            const entry = promptHelperState.datasets.find((d) => d.id === promptHelperState.selectedId);
            updatePromptHelperDatasetSummary(entry);
            promptHelperState.suggestions = [];
            promptHelperState.promptsByClass = {};
            renderPromptHelperPrompts();
            if (promptHelperElements.evaluateButton) promptHelperElements.evaluateButton.disabled = true;
            if (promptHelperElements.results) promptHelperElements.results.innerHTML = "";
            if (promptHelperElements.summary) promptHelperElements.summary.textContent = "";
            if (promptSearchElements.results) promptSearchElements.results.innerHTML = "";
            if (promptSearchElements.logs) promptSearchElements.logs.innerHTML = "";
            if (promptSearchElements.status) promptSearchElements.status.textContent = "Idle";
            setPromptSearchMessage("");
            if (promptRecipeElements.results) promptRecipeElements.results.innerHTML = "";
            if (promptRecipeElements.logs) promptRecipeElements.logs.innerHTML = "";
            if (promptRecipeElements.status) promptRecipeElements.status.textContent = "Idle";
            setPromptRecipeMessage("");
            if (promptRecipeElements.applyButton) promptRecipeElements.applyButton.disabled = true;
            sam3RecipeState.recipe = null;
            if (sam3RecipeElements.applyButton) sam3RecipeElements.applyButton.disabled = true;
            if (sam3RecipeElements.status) sam3RecipeElements.status.textContent = "";
            if (promptRecipeState.pollHandle) {
                clearInterval(promptRecipeState.pollHandle);
                promptRecipeState.pollHandle = null;
            }
            promptRecipeState.activeJobId = null;
            promptRecipeState.lastJob = null;
            if (promptSearchElements.classSelect) {
                promptSearchElements.classSelect.innerHTML = "";
                const allOpt = document.createElement("option");
                allOpt.value = "all";
                allOpt.textContent = "All classes";
                promptSearchElements.classSelect.appendChild(allOpt);
                promptSearchElements.classSelect.disabled = true;
            }
            if (promptRecipeElements.classSelect) {
                promptRecipeElements.classSelect.innerHTML = "";
                promptRecipeElements.classSelect.disabled = true;
            }
            populatePromptSearchClassSelect();
        });
    }
    if (promptHelperElements.datasetRefresh) {
        promptHelperElements.datasetRefresh.addEventListener("click", () => {
            loadPromptHelperDatasets().catch((err) => console.error("Prompt helper dataset refresh failed", err));
        });
    }
    if (promptHelperElements.generateButton) {
        promptHelperElements.generateButton.addEventListener("click", () => {
            generatePromptHelperPrompts().catch((err) => console.error("Prompt helper generate failed", err));
        });
    }
    if (promptHelperElements.evaluateButton) {
        promptHelperElements.evaluateButton.addEventListener("click", () => {
            startPromptHelperJob().catch((err) => console.error("Prompt helper start failed", err));
        });
    }
    if (promptHelperElements.presetSaveBtn) {
        promptHelperElements.presetSaveBtn.addEventListener("click", () => {
            savePromptHelperPreset().catch((err) => console.error("Prompt helper preset save failed", err));
        });
    }
    if (promptHelperElements.presetLoadBtn) {
        promptHelperElements.presetLoadBtn.addEventListener("click", () => {
            loadPromptHelperPresetIntoUi().catch((err) => console.error("Prompt helper preset load failed", err));
        });
    }
    if (promptHelperElements.applyButton) {
        promptHelperElements.applyButton.addEventListener("click", applyPromptHelperMapping);
    }
    if (promptSearchElements.runButton) {
        promptSearchElements.runButton.addEventListener("click", () => {
            startPromptSearchJob().catch((err) => console.error("Prompt search start failed", err));
        });
    }
    if (promptRecipeElements.runButton) {
        promptRecipeElements.runButton.addEventListener("click", () => {
            startPromptRecipeJob().catch((err) => console.error("Prompt recipe start failed", err));
        });
    }
    if (promptRecipeElements.applyButton) {
        promptRecipeElements.applyButton.addEventListener("click", () => {
            applyLastPromptRecipeToPrompts().catch((err) => console.error("Prompt recipe apply failed", err));
        });
    }
    if (promptRecipeElements.expandButton) {
        promptRecipeElements.expandButton.addEventListener("click", () => {
            expandPromptRecipePrompts().catch((err) => console.error("Prompt recipe expand failed", err));
        });
    }
    await loadPromptHelperDatasets();
    await loadPromptHelperPresets();
    setPromptHelperMessage("Generate suggestions, edit prompts, then evaluate with SAM3.", "info");
    setPromptSearchMessage("Use the prompts above, then run a targeted search for the best wording.", "info");
    setPromptRecipeMessage("Mine an ordered recipe per class using the prompts you’ve edited above.", "info");
    // Make sure class dropdowns are visible/enabled when prompts are present.
    populatePromptSearchClassSelect();
}

function populatePromptSearchClassSelect() {
    const classes = promptHelperState.suggestions || [];
    if (promptSearchElements.classSelect) {
        const select = promptSearchElements.classSelect;
        select.innerHTML = "";
        const allOpt = document.createElement("option");
        allOpt.value = "all";
        allOpt.textContent = "All classes";
        select.appendChild(allOpt);
        classes.forEach((cls) => {
            const opt = document.createElement("option");
            opt.value = cls.class_id;
            opt.textContent = cls.class_name || cls.class_id;
            select.appendChild(opt);
        });
        select.value = "all";
        select.disabled = !classes.length;
    }
    if (promptRecipeElements.classSelect) {
        const select = promptRecipeElements.classSelect;
        select.innerHTML = "";
        classes.forEach((cls) => {
            const opt = document.createElement("option");
            opt.value = cls.class_id;
            opt.textContent = cls.class_name || cls.class_id;
            select.appendChild(opt);
        });
        if (classes.length) {
            select.value = classes[0].class_id;
            select.disabled = false;
        } else {
            const placeholder = document.createElement("option");
            placeholder.value = "";
            placeholder.textContent = "No classes yet";
            select.appendChild(placeholder);
            select.value = "";
            select.disabled = true;
        }
    }
}

function renderSam3History(list) {
    if (!sam3TrainElements.history) return;
    sam3TrainElements.history.innerHTML = "";
    if (!Array.isArray(list) || !list.length) {
        const empty = document.createElement("div");
        empty.className = "training-history-item";
        empty.textContent = "No SAM3 training jobs yet.";
        sam3TrainElements.history.appendChild(empty);
        return;
    }
    list.forEach((job) => {
        const item = document.createElement("div");
        item.className = "training-history-item";
        const left = document.createElement("div");
        const created = formatTimestamp(job.created_at || 0);
        left.innerHTML = `<strong>${escapeHtml(job.job_id.slice(0, 8))}</strong><div class="training-help">${escapeHtml(job.status)} • ${escapeHtml(created)}</div>`;
        item.appendChild(left);
        item.addEventListener("click", () => {
            if (job.job_id) {
                pollSam3TrainingJob(job.job_id, { force: true }).catch((err) => console.error("SAM3 poll history failed", err));
            }
        });
        sam3TrainElements.history.appendChild(item);
    });
}

function renderRunStorage(entries, elements) {
    if (!elements.list) return;
    elements.list.innerHTML = "";
    if (!Array.isArray(entries) || !entries.length) {
        const empty = document.createElement("div");
        empty.className = "training-history-item";
        empty.textContent = "No runs found.";
        elements.list.appendChild(empty);
        return;
    }
    entries.forEach((entry) => {
        const item = document.createElement("div");
        item.className = "storage-item";
        const main = document.createElement("div");
        main.className = "storage-main";
        const heading = document.createElement("div");
        heading.innerHTML = `<strong>${escapeHtml(entry.id)}</strong>`;
        if (entry.active) {
            const badge = document.createElement("span");
            badge.className = "storage-badge warn";
            badge.textContent = "Active";
            heading.appendChild(document.createTextNode(" "));
            heading.appendChild(badge);
        }
        if (entry.promoted) {
            const badge = document.createElement("span");
            badge.className = "storage-badge success";
            badge.textContent = "Promoted";
            heading.appendChild(document.createTextNode(" "));
            heading.appendChild(badge);
        }
        main.appendChild(heading);
        const parts = [];
        if (Number.isFinite(entry.size_bytes)) parts.push(`total ${formatBytes(entry.size_bytes)}`);
        if (Number.isFinite(entry.checkpoints_size_bytes) && entry.checkpoints_size_bytes > 0)
            parts.push(`ckpts ${formatBytes(entry.checkpoints_size_bytes)}`);
        if (Number.isFinite(entry.logs_size_bytes) && entry.logs_size_bytes > 0)
            parts.push(`logs ${formatBytes(entry.logs_size_bytes)}`);
        if (Number.isFinite(entry.tensorboard_size_bytes) && entry.tensorboard_size_bytes > 0)
            parts.push(`tensorboard ${formatBytes(entry.tensorboard_size_bytes)}`);
        if (Number.isFinite(entry.dumps_size_bytes) && entry.dumps_size_bytes > 0)
            parts.push(`dumps ${formatBytes(entry.dumps_size_bytes)}`);
        const meta = document.createElement("div");
        meta.className = "storage-meta";
        meta.textContent = parts.length ? parts.join(" • ") : "Empty run folder.";
        main.appendChild(meta);
        const actions = document.createElement("div");
        actions.className = "storage-actions";
        const scopes = [
            { label: "Delete ckpts", scope: "checkpoints" },
            { label: "Delete logs", scope: "logs" },
            { label: "Delete dumps", scope: "dumps" },
            { label: "Delete TB", scope: "tensorboard" },
            { label: "Delete run", scope: "all", danger: true },
        ];
        if (!entry.promoted) {
            scopes.push({ label: "Promote (keep last, strip optimizer)", scope: "promote", danger: false });
        }
        scopes.forEach(({ label, scope, danger }) => {
            const btn = document.createElement("button");
            btn.type = "button";
            btn.textContent = label;
            btn.className = `training-button${danger ? " training-button-danger" : ""}`;
            btn.disabled = !!entry.active;
            btn.addEventListener("click", () => deleteRunStorage(entry.id, scope));
            actions.appendChild(btn);
        });
        item.appendChild(main);
        item.appendChild(actions);
        elements.list.appendChild(item);
    });
}

async function refreshRunStorage() {
    if (!sam3StorageElements.list) return;
    try {
        const resp = await fetch(`${API_ROOT}/sam3/storage/runs?variant=sam3`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        sam3StorageState.items = Array.isArray(data) ? data : [];
        renderRunStorage(sam3StorageState.items, sam3StorageElements);
    } catch (err) {
        console.error("Failed to load run storage", err);
    }
}

async function deleteRunStorage(runId, scope) {
    if (scope === "promote") {
        const qs = new URLSearchParams({ variant: "sam3" });
        try {
            const resp = await fetch(`${API_ROOT}/sam3/storage/runs/${encodeURIComponent(runId)}/promote?${qs.toString()}`, {
                method: "POST",
            });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            const msg = `Promoted ${runId}: kept ${data.kept || "checkpoint"}, freed ${formatBytes(data.freed_bytes || 0)}.`;
            setSam3Message(msg, "success");
        } catch (err) {
            console.error("Promote run failed", err);
            setSam3Message(`Promote failed: ${err.message || err}`, "error");
        }
    } else {
        const label = scope === "all" ? "entire run folder" : scope;
        let confirmText = `Delete ${label} for ${runId}?`;
        const entry = sam3StorageState.items.find((r) => r.id === runId) || null;
        if (entry && entry.promoted) {
            confirmText = `This run is promoted.\n${confirmText}\nClick OK to delete anyway.`;
            const second = typeof window !== "undefined" ? window.confirm(confirmText) : true;
            if (!second) return;
        } else if (typeof window !== "undefined" && !window.confirm(confirmText)) {
            return;
        }
        const qs = new URLSearchParams({ variant: "sam3", scope });
        try {
            const resp = await fetch(`${API_ROOT}/sam3/storage/runs/${encodeURIComponent(runId)}?${qs.toString()}`, {
                method: "DELETE",
            });
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            setSam3Message(`Deleted ${label} for ${runId}.`, "success");
        } catch (err) {
            console.error("Delete run failed", err);
            setSam3Message(`Delete failed: ${err.message || err}`, "error");
        }
    }
    await refreshRunStorage();
}

async function refreshSam3History() {
    try {
        const resp = await fetch(`${API_ROOT}/sam3/train/jobs`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        renderSam3History(data);
        const latestRunning = Array.isArray(data)
            ? data.find((j) => ["running", "queued", "cancelling"].includes(j.status))
            : null;
        if (latestRunning && latestRunning.job_id) {
            pollSam3TrainingJob(latestRunning.job_id, { force: true, silent: true }).catch((err) =>
                console.error("SAM3 poll history failed", err),
            );
        }
    } catch (err) {
        console.error("Failed to load SAM3 training history", err);
    }
}

function updateSam3Ui(job) {
    if (!job || !sam3TrainElements.statusText) return;
    sam3TrainState.lastJobSnapshot = job;
    const metricProgress = computeMetricProgress(job);
    const progressVal = metricProgress !== null ? metricProgress : computeSam3Progress(job);
    const pctVal = Math.max(0, Math.min(100, progressVal * 100));
    const pct = Number.isFinite(pctVal) ? pctVal : 0;
    const pctText = pct.toFixed(1).replace(/\.0$/, "");
    const lastMetric = job.metrics && job.metrics.length ? job.metrics[job.metrics.length - 1] : null;
    const batch = lastMetric && Number.isFinite(lastMetric.batch) ? lastMetric.batch : null;
    const batchesPerEpoch =
        lastMetric && Number.isFinite(lastMetric.batches_per_epoch) ? lastMetric.batches_per_epoch : null;
    const epoch = lastMetric && Number.isFinite(lastMetric.epoch) ? lastMetric.epoch : null;
    const totalEpochs = lastMetric && Number.isFinite(lastMetric.total_epochs) ? lastMetric.total_epochs : null;
    const lastPhase = lastMetric && lastMetric.phase ? String(lastMetric.phase) : null;
    const valStep = lastPhase === "val" && Number.isFinite(lastMetric?.val_step) ? Number(lastMetric.val_step) : null;
    const valTotal = lastPhase === "val" && Number.isFinite(lastMetric?.val_total) ? Number(lastMetric.val_total) : null;
    let statusText = job.status === "running" || job.status === "queued" ? `Training running, ${pctText}% done` : job.status;
    if (lastPhase === "val" && Number.isFinite(valStep) && Number.isFinite(valTotal)) {
        statusText = `Validation running, ${pctText}% done (batch ${valStep}/${valTotal})`;
    } else if (Number.isFinite(epoch) && Number.isFinite(batch) && Number.isFinite(batchesPerEpoch)) {
        const epochPart = Number.isFinite(totalEpochs) ? `epoch ${epoch}/${totalEpochs}` : `epoch ${epoch}`;
        statusText = job.status === "running" || job.status === "queued" ? `Training running, ${pctText}% done` : job.status;
        statusText += ` (${epochPart}, batch ${batch}/${batchesPerEpoch})`;
    }
    if (job.status === "succeeded") {
        statusText = "Training + validation complete";
    }
    sam3TrainElements.statusText.textContent = statusText;
    if (sam3TrainElements.progressFill) {
        sam3TrainElements.progressFill.style.width = `${pct}%`;
        sam3TrainElements.progressFill.setAttribute("aria-valuenow", pctText);
    }
    if (sam3TrainElements.etaText) {
        const remaining = computeMetricEta(job, metricProgress !== null ? metricProgress : progressVal);
        if (job.status === "succeeded") {
            sam3TrainElements.etaText.textContent = "ETA: complete";
        } else if (remaining !== null && remaining > 0) {
            sam3TrainElements.etaText.textContent = `ETA: ${formatEta(remaining)}`;
        } else {
            sam3TrainElements.etaText.textContent = "ETA: estimating…";
        }
    }
    if (sam3TrainElements.cancelButton) {
        sam3TrainElements.cancelButton.disabled = !job || !["queued", "running", "cancelling"].includes(job.status);
    }
    if (sam3TrainElements.log) {
        const logs = Array.isArray(job.logs) ? job.logs : [];
        const linesDisplay = logs.map((entry) => (entry.message ? entry.message : "")).filter(Boolean).slice(-200);
        sam3TrainElements.log.textContent = linesDisplay.join("\n");
        updateSam3LossChartFromMetrics(job.metrics, job.job_id);
        renderSam3ValMetrics();
    } else {
        // If we lost references (e.g., DOM re-render), rebind and retry
        sam3TrainElements.log = document.getElementById("sam3Log");
        sam3TrainElements.lossCanvas = document.getElementById("sam3LossChart");
        sam3TrainElements.valMetrics = document.getElementById("sam3ValMetrics");
        if (sam3TrainElements.log && sam3TrainElements.lossCanvas && job && Array.isArray(job.logs)) {
            const linesAll = job.logs.map((entry) => (entry.message ? entry.message : "")).filter(Boolean);
            sam3TrainElements.log.textContent = linesAll.slice(-200).join("\n");
            updateSam3LossChartFromMetrics(job.metrics, job.job_id);
            renderSam3ValMetrics();
        }
    }
    if (sam3TrainElements.summary) {
        if (job.result && job.result.checkpoint) {
            const ckpt = escapeHtml(job.result.checkpoint);
            sam3TrainElements.summary.innerHTML = `Checkpoint: <code>${ckpt}</code>`;
            sam3TrainState.latestCheckpoint = job.result.checkpoint;
            sam3TrainElements.summary.style.display = "block";
        } else {
            sam3TrainElements.summary.textContent = "";
            sam3TrainState.latestCheckpoint = null;
            sam3TrainElements.summary.style.display = "none";
        }
    }
    if (sam3TrainElements.balanceSummary) {
        const info = job.result && job.result.balance_info ? String(job.result.balance_info) : "";
        if (info) {
            sam3TrainElements.balanceSummary.textContent = info;
            sam3TrainElements.balanceSummary.style.display = "block";
        } else {
            sam3TrainElements.balanceSummary.textContent = "";
            sam3TrainElements.balanceSummary.style.display = "none";
        }
    }
    if (sam3TrainElements.activateButton) {
        sam3TrainElements.activateButton.disabled = !sam3TrainState.latestCheckpoint;
    }
}

async function pollSam3TrainingJob(jobId, options = {}) {
    if (!jobId) return;
    sam3TrainState.activeJobId = jobId;
    sam3TrainState.lastSeenJob = sam3TrainState.lastSeenJob || {};
    try {
        const resp = await fetch(`${API_ROOT}/sam3/train/jobs/${jobId}`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const job = await resp.json();
        updateSam3Ui(job);
        const running = ["queued", "running", "cancelling"].includes(job.status);
        if (running || options.force) {
            if (sam3TrainState.pollHandle) {
                clearTimeout(sam3TrainState.pollHandle);
            }
            sam3TrainState.pollHandle = window.setTimeout(() => {
                pollSam3TrainingJob(jobId).catch((err) => console.error("SAM3 poll failed", err));
            }, 1500);
        } else {
            sam3TrainState.pollHandle = null;
            refreshSam3History();
        }
        sam3TrainState.lastSeenJob[jobId] = job;
    } catch (err) {
        console.error("SAM3 job poll failed", err);
        if (!options.silent) {
            setSam3Message(`Polling failed: ${err.message || err}`, "error");
        }
    }
}

async function startSam3Training() {
    const datasetId = sam3TrainState.selectedId;
    if (!datasetId) {
        setSam3Message("Select a dataset first.", "warn");
        return;
    }
    try {
        await convertSam3Dataset();
    } catch {
        return;
    }
    const payload = { dataset_id: datasetId };
    if (sam3TrainElements.randomSplit) {
        payload.random_split = !!sam3TrainElements.randomSplit.checked;
    }
    const sam3ValPct = readNumberInput(sam3TrainElements.valPercent, { integer: true });
    if (sam3ValPct !== undefined && sam3ValPct !== null) {
        payload.val_percent = Math.max(1, Math.min(sam3ValPct, 90)) / 100;
    }
    const sam3Seed = readNumberInput(sam3TrainElements.splitSeed, { integer: true });
    if (sam3Seed !== undefined && sam3Seed !== null) {
        payload.split_seed = sam3Seed;
    }
    const maybeNumber = (input) => {
        if (!input || !input.value) return null;
        const num = Number(input.value);
        return Number.isFinite(num) ? num : null;
    };
    const parsePromptVariants = (text) => {
        if (!text) return {};
        const mapping = {};
        text
            .split(/\n+/)
            .map((l) => l.trim())
            .filter(Boolean)
            .forEach((line) => {
                const splitter = line.includes("=") && !line.includes(":") ? "=" : ":";
                const [rawLabel, rest] = line.split(splitter);
                const label = (rawLabel || "").trim();
                if (!label) return;
                const variants = (rest || "")
                    .split(/[,;]/)
                    .map((v) => v.trim())
                    .filter(Boolean);
                if (variants.length) {
                    mapping[label] = variants;
                }
            });
        return mapping;
    };
    if (sam3TrainElements.runName && sam3TrainElements.runName.value.trim()) {
        payload.run_name = sam3TrainElements.runName.value.trim();
    }
    const fields = [
        ["train_batch_size", sam3TrainElements.trainBatch],
        ["val_batch_size", sam3TrainElements.valBatch],
        ["num_train_workers", sam3TrainElements.trainWorkers],
        ["num_val_workers", sam3TrainElements.valWorkers],
        ["max_epochs", sam3TrainElements.epochs],
        ["resolution", sam3TrainElements.resolution],
        ["lr_scale", sam3TrainElements.lrScale],
        ["gradient_accumulation_steps", sam3TrainElements.gradAccum],
        ["val_epoch_freq", sam3TrainElements.valFreq],
        ["scheduler_warmup", sam3TrainElements.warmupSteps],
        ["scheduler_timescale", sam3TrainElements.schedulerTimescale],
    ];
    const capEpoch = sam3TrainElements.capEpoch ? sam3TrainElements.capEpoch.checked : true;
    if (capEpoch) {
        fields.push(["target_epoch_size", sam3TrainElements.targetEpochSize]);
    }
    const capVal = sam3TrainElements.capVal ? sam3TrainElements.capVal.checked : false;
    if (capVal) {
        fields.push(["val_limit", sam3TrainElements.valCapSize]);
    }
    const strategy = sam3TrainElements.balanceStrategy ? sam3TrainElements.balanceStrategy.value : "none";
    if (strategy && strategy !== "none") {
        payload.balance_strategy = strategy;
        payload.balance_classes = true;
        const power = maybeNumber(sam3TrainElements.balancePower);
        const clip = maybeNumber(sam3TrainElements.balanceClip);
        const beta = maybeNumber(sam3TrainElements.balanceBeta);
        const gamma = maybeNumber(sam3TrainElements.balanceGamma);
        if (power !== null && ["inv_sqrt", "clipped_inv"].includes(strategy)) {
            payload.balance_power = power;
        }
        if (clip !== null && strategy === "clipped_inv" && clip >= 1) {
            payload.balance_clip = clip;
        }
        if (beta !== null && strategy === "effective_num") {
            payload.balance_beta = beta;
        }
        if (gamma !== null && strategy === "focal") {
            payload.balance_gamma = gamma;
        }
    } else {
        payload.balance_classes = false;
    }
    fields.forEach(([key, el]) => {
        const val = maybeNumber(el);
        if (val !== null) payload[key] = val;
    });
    if (sam3TrainElements.freezeLanguage && sam3TrainElements.freezeLanguage.checked) {
        payload.freeze_language_backbone = true;
    }
    const langLr = maybeNumber(sam3TrainElements.languageLr);
    if (langLr !== null) {
        payload.language_backbone_lr = langLr;
    }
    if (sam3TrainElements.promptVariants) {
        const variants = parsePromptVariants(sam3TrainElements.promptVariants.value);
        if (Object.keys(variants).length) {
            payload.prompt_variants = variants;
            if (sam3TrainElements.promptRandomize) {
                payload.prompt_randomize = !!sam3TrainElements.promptRandomize.checked;
            }
        }
    }
    if (sam3TrainElements.logAll && sam3TrainElements.logAll.checked) {
        payload.log_every_batch = true;
    }
    const valScore = maybeNumber(sam3TrainElements.valScoreThresh);
    if (valScore !== null) {
        payload.val_score_thresh = valScore;
    }
    const valMaxDets = maybeNumber(sam3TrainElements.valMaxDets);
    if (valMaxDets !== null) {
        payload.val_max_dets = valMaxDets;
    }
    const wantsSegTrain = sam3TrainElements.segTrain ? sam3TrainElements.segTrain.checked : false;
    const bboxOnly = sam3TrainElements.bboxOnly ? sam3TrainElements.bboxOnly.checked : false;
    if (bboxOnly) {
        payload.enable_segmentation_head = false;
        payload.train_segmentation = false;
    } else {
        const segHeadChecked = sam3TrainElements.segHead ? sam3TrainElements.segHead.checked : true;
        payload.enable_segmentation_head = segHeadChecked || wantsSegTrain;
        if (wantsSegTrain) {
            payload.train_segmentation = true;
        }
    }
    setSam3Message("Starting SAM3 training…", "info");
    try {
        const resp = await fetch(`${API_ROOT}/sam3/train/jobs`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
        });
        if (!resp.ok) {
            const text = await resp.text();
            throw new Error(text || `HTTP ${resp.status}`);
        }
        const data = await resp.json();
        sam3TrainState.activeJobId = data.job_id;
        resetSam3LossChart(data.job_id);
        resetSam3Eta();
        pollSam3TrainingJob(data.job_id, { force: true }).catch((err) => console.error("SAM3 poll start failed", err));
        setSam3Message("Job queued.", "success");
        refreshSam3History();
    } catch (err) {
        console.error("SAM3 training start failed", err);
        setSam3Message(err.message || "Failed to start training", "error");
    }
}

async function cancelSam3Training() {
    if (!sam3TrainState.activeJobId) {
        setSam3Message("No active job.", "warn");
        return;
    }
    try {
        const resp = await fetch(`${API_ROOT}/sam3/train/jobs/${sam3TrainState.activeJobId}/cancel`, { method: "POST" });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        setSam3Message("Cancellation requested…", "info");
    } catch (err) {
        console.error("SAM3 cancel failed", err);
        setSam3Message(`Cancel failed: ${err.message || err}`, "error");
    }
}

async function activateSam3Checkpoint() {
    const ckpt = sam3TrainState.latestCheckpoint || (sam3TrainState.lastJobSnapshot && sam3TrainState.lastJobSnapshot.result && sam3TrainState.lastJobSnapshot.result.checkpoint);
    if (!ckpt) {
        setSam3Message("No checkpoint to activate.", "warn");
        return;
    }
    const enableSeg = sam3TrainState.lastJobSnapshot && sam3TrainState.lastJobSnapshot.result ? sam3TrainState.lastJobSnapshot.result.enable_segmentation : false;
    const payload = {
        checkpoint_path: ckpt,
        enable_segmentation: enableSeg,
        label: sam3TrainElements.runName && sam3TrainElements.runName.value.trim() ? sam3TrainElements.runName.value.trim() : undefined,
    };
    try {
        const resp = await fetch(`${API_ROOT}/sam3/models/activate`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
        });
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        setSam3Message("Activated SAM3 checkpoint.", "success");
    } catch (err) {
        console.error("SAM3 activate failed", err);
        setSam3Message(`Activate failed: ${err.message || err}`, "error");
    }
}

function setSegBuilderMessage(text, tone = "info") {
    if (!segBuilderElements.message) return;
    segBuilderElements.message.textContent = text || "";
    segBuilderElements.message.className = `training-message ${tone}`;
}

function renderSegBuilderLog(job) {
    const logEl = segBuilderElements.log;
    if (!logEl) return;
    logEl.innerHTML = "";
    const logs = job && Array.isArray(job.logs) ? job.logs.slice(-100) : [];
    if (!logs.length) return;
    logs.forEach((entry) => {
        const row = document.createElement("div");
        row.className = "training-log-line";
        const ts = entry.timestamp ? formatTimestamp(entry.timestamp) : "";
        row.textContent = ts ? `[${ts}] ${entry.message || ""}` : entry.message || "";
        logEl.appendChild(row);
    });
    logEl.scrollTop = logEl.scrollHeight;
}

function updateSegBuilderDatasetSummary(entry) {
    if (!segBuilderElements.datasetSummary) return;
    if (!entry) {
        segBuilderElements.datasetSummary.textContent = "Pick a dataset to convert (bbox required; others will fail at start).";
        if (segBuilderElements.startButton) segBuilderElements.startButton.disabled = true;
        return;
    }
    const isBbox = (entry.type || "bbox") === "bbox";
    const pieces = [];
    pieces.push(entry.type ? `${entry.type.toUpperCase()} dataset` : "bbox dataset");
    if (entry.source) pieces.push(entry.source);
    const counts = [];
    if (entry.image_count) counts.push(`${entry.image_count} images`);
    if (entry.train_count) counts.push(`train ${entry.train_count}`);
    if (entry.val_count) counts.push(`val ${entry.val_count}`);
    if (counts.length) pieces.push(counts.join(" / "));
    if (!isBbox) pieces.unshift("Requires bbox dataset");
    segBuilderElements.datasetSummary.textContent = pieces.join(" • ");
    if (segBuilderElements.startButton) segBuilderElements.startButton.disabled = !isBbox;
}

function renderSegBuilderDatasets(list) {
    segBuilderState.datasets = Array.isArray(list) ? list : [];
    if (!segBuilderElements.datasetSelect) return;
    segBuilderElements.datasetSelect.innerHTML = "";
    segBuilderState.datasets.forEach((entry) => {
        const opt = document.createElement("option");
        opt.value = entry.id;
        const isBbox = (entry.type || "bbox") === "bbox";
        const typeLabel = entry.type ? `[${entry.type}] ` : "";
        const cocoNote = entry.coco_ready ? "" : " (needs convert)";
        opt.textContent = `${typeLabel}${entry.label || entry.id}${cocoNote}`;
        opt.disabled = !isBbox;
        if (entry.id === segBuilderState.selectedId) {
            opt.selected = true;
        }
        segBuilderElements.datasetSelect.appendChild(opt);
    });
    const selected =
        segBuilderState.datasets.find((d) => d.id === segBuilderState.selectedId && (d.type || "bbox") === "bbox") ||
        segBuilderState.datasets.find((d) => (d.type || "bbox") === "bbox") ||
        null;
    segBuilderState.selectedId = selected ? selected.id : null;
    if (segBuilderElements.datasetSelect && segBuilderState.selectedId) {
        segBuilderElements.datasetSelect.value = segBuilderState.selectedId;
    }
    updateSegBuilderDatasetSummary(selected);
}

async function refreshSegBuilderDatasets() {
    try {
        const resp = await fetch(`${API_ROOT}/datasets`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        renderSegBuilderDatasets(data);
    } catch (err) {
        console.error("Failed to load datasets for segmentation builder", err);
        setSegBuilderMessage(`Failed to load datasets: ${err.message || err}`, "error");
    }
}

function renderSegBuilderJobs(list) {
    segBuilderState.jobs = Array.isArray(list) ? list : [];
    const container = segBuilderElements.jobsContainer;
    if (!container) return;
    container.innerHTML = "";
    if (!segBuilderState.jobs.length) {
        const empty = document.createElement("div");
        empty.className = "training-history-item";
        empty.textContent = "No segmentation build jobs yet.";
        container.appendChild(empty);
        return;
    }
    segBuilderState.jobs.forEach((job) => {
        const item = document.createElement("div");
        item.className = "training-history-item";
        const left = document.createElement("div");
        const created = formatTimestamp(job.created_at || 0);
        const planned = job.result && job.result.planned_metadata ? job.result.planned_metadata : job.config && job.config.planned_metadata;
        const targetId = planned && planned.id ? planned.id : "";
        const subtitleParts = [job.status || "unknown", created];
        if (targetId) {
            subtitleParts.unshift(targetId);
        }
        left.innerHTML = `<strong>${escapeHtml(job.job_id ? job.job_id.slice(0, 8) : "job")}</strong><div class="training-help">${escapeHtml(subtitleParts.filter(Boolean).join(" • "))}</div>`;
        item.appendChild(left);
        if (job.message) {
            const msg = document.createElement("div");
            msg.className = "training-help";
            msg.textContent = job.message;
            item.appendChild(msg);
        }
        container.appendChild(item);
    });
}

async function pollSegBuilderJob(jobId, { force = false } = {}) {
    if (!jobId) return;
    if (segBuilderState.pollInFlight && !force) return;
    segBuilderState.pollInFlight = true;
    try {
        const resp = await fetch(`${API_ROOT}/segmentation/build/jobs/${jobId}`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        segBuilderState.lastSeenJob[jobId] = data;
        const pct = Number.isFinite(data.progress) ? Math.round(data.progress * 100) : null;
        const tone = data.status === "failed" ? "error" : data.status === "completed" ? "success" : "info";
        const message = pct !== null ? `${data.message || ""} (${pct}%)` : data.message || "";
        setSegBuilderMessage(message, tone);
        renderSegBuilderLog(data);
        if (["completed", "failed", "cancelled"].includes(data.status)) {
            segBuilderState.activeJobId = null;
            if (segBuilderState.pollTimer) {
                clearTimeout(segBuilderState.pollTimer);
                segBuilderState.pollTimer = null;
            }
            refreshSegBuilderJobs();
        } else {
            segBuilderState.pollTimer = setTimeout(() => pollSegBuilderJob(jobId), 2000);
        }
    } catch (err) {
        console.error("Failed to poll segmentation builder job", err);
    } finally {
        segBuilderState.pollInFlight = false;
    }
}

async function refreshSegBuilderJobs() {
    try {
        const resp = await fetch(`${API_ROOT}/segmentation/build/jobs`);
        if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
        const data = await resp.json();
        renderSegBuilderJobs(data);
        if (!segBuilderState.activeJobId) {
            const running = data.find((job) => ["running", "queued", "blocked"].includes(job.status));
            if (running) {
                segBuilderState.activeJobId = running.job_id;
                pollSegBuilderJob(running.job_id, { force: true });
            }
        }
    } catch (err) {
        console.error("Failed to refresh segmentation jobs", err);
        setSegBuilderMessage(`Failed to refresh jobs: ${err.message || err}`, "error");
    }
}

async function startSegmentationBuild() {
    const datasetId = segBuilderState.selectedId;
    if (!datasetId) {
        setSegBuilderMessage("Select a bbox dataset first.", "warn");
        return;
    }
    const entry = segBuilderState.datasets.find((d) => d.id === datasetId);
    if (!entry || (entry.type || "bbox") !== "bbox") {
        setSegBuilderMessage("Segmentation build requires a bbox dataset.", "warn");
        return;
    }
    const payload = {
        source_dataset_id: datasetId,
        sam_variant: segBuilderElements.samVariant ? segBuilderElements.samVariant.value || "sam3" : "sam3",
    };
    if (segBuilderElements.outputName && segBuilderElements.outputName.value.trim()) {
        payload.output_name = segBuilderElements.outputName.value.trim();
    }
    setSegBuilderMessage("Queuing segmentation build…", "info");
    renderSegBuilderLog(null);
    if (segBuilderState.pollTimer) {
        clearTimeout(segBuilderState.pollTimer);
        segBuilderState.pollTimer = null;
    }
    segBuilderState.activeJobId = null;
    try {
        const resp = await fetch(`${API_ROOT}/segmentation/build/jobs`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
        });
        if (!resp.ok) {
            const text = await resp.text();
            throw new Error(text || `HTTP ${resp.status}`);
        }
        const job = await resp.json();
        segBuilderState.activeJobId = job.job_id;
        setSegBuilderMessage("Job queued.", "success");
        pollSegBuilderJob(job.job_id, { force: true });
        await refreshSegBuilderJobs();
    } catch (err) {
        console.error("Segmentation build start failed", err);
        setSegBuilderMessage(err.message || "Failed to start segmentation build", "error");
    }
}

async function initSegBuilderTab() {
    if (segBuilderUiInitialized) return;
    segBuilderUiInitialized = true;
    segBuilderElements.datasetSelect = document.getElementById("segBuilderDatasetSelect");
    segBuilderElements.datasetSummary = document.getElementById("segBuilderDatasetSummary");
    segBuilderElements.outputName = document.getElementById("segBuilderOutputName");
    segBuilderElements.samVariant = document.getElementById("segBuilderVariant");
    segBuilderElements.startButton = document.getElementById("segBuilderStartBtn");
    segBuilderElements.refreshButton = document.getElementById("segBuilderRefreshBtn");
    segBuilderElements.jobsRefresh = document.getElementById("segBuilderJobsRefresh");
    segBuilderElements.jobsContainer = document.getElementById("segBuilderJobs");
    segBuilderElements.message = document.getElementById("segBuilderMessage");
    segBuilderElements.log = document.getElementById("segBuilderLog");
    if (segBuilderElements.datasetSelect) {
        segBuilderElements.datasetSelect.addEventListener("change", () => {
            segBuilderState.selectedId = segBuilderElements.datasetSelect.value || null;
            const entry = segBuilderState.datasets.find((d) => d.id === segBuilderState.selectedId);
            updateSegBuilderDatasetSummary(entry);
        });
    }
    if (segBuilderElements.startButton) {
        segBuilderElements.startButton.addEventListener("click", () => startSegmentationBuild());
    }
    if (segBuilderElements.refreshButton) {
        segBuilderElements.refreshButton.addEventListener("click", () => refreshSegBuilderDatasets());
    }
    if (segBuilderElements.jobsRefresh) {
        segBuilderElements.jobsRefresh.addEventListener("click", () => refreshSegBuilderJobs());
    }
    await refreshSegBuilderDatasets();
    await refreshSegBuilderJobs();
    // If a running job exists after the first refresh, start polling immediately.
    const running = segBuilderState.jobs.find((job) => ["running", "queued", "blocked"].includes(job.status));
    if (running) {
        segBuilderState.activeJobId = running.job_id;
        pollSegBuilderJob(running.job_id, { force: true });
    }
}

async function initSam3TrainUi() {
    if (sam3TrainUiInitialized) return;
    sam3TrainUiInitialized = true;
    sam3TrainState.lastSeenJob = {};
    sam3TrainElements.datasetSelect = document.getElementById("sam3DatasetSelect");
    sam3TrainElements.datasetSummary = document.getElementById("sam3DatasetSummary");
    sam3TrainElements.datasetRefresh = document.getElementById("sam3DatasetRefresh");
    sam3TrainElements.datasetConvert = document.getElementById("sam3DatasetConvert");
    sam3TrainElements.randomSplit = document.getElementById("sam3RandomSplit");
    sam3TrainElements.valPercent = document.getElementById("sam3ValPercent");
    sam3TrainElements.splitSeed = document.getElementById("sam3SplitSeed");
    sam3TrainElements.cacheInfo = document.getElementById("sam3CacheInfo");
    sam3TrainElements.cachePurge = document.getElementById("sam3CachePurge");
    sam3TrainElements.runName = document.getElementById("sam3RunName");
    sam3TrainElements.trainBatch = document.getElementById("sam3TrainBatch");
    sam3TrainElements.valBatch = document.getElementById("sam3ValBatch");
    sam3TrainElements.trainWorkers = document.getElementById("sam3TrainWorkers");
    sam3TrainElements.valWorkers = document.getElementById("sam3ValWorkers");
    sam3TrainElements.epochs = document.getElementById("sam3Epochs");
    sam3TrainElements.resolution = document.getElementById("sam3Resolution");
    sam3TrainElements.lrScale = document.getElementById("sam3LrScale");
    sam3TrainElements.gradAccum = document.getElementById("sam3GradAccum");
    sam3TrainElements.valFreq = document.getElementById("sam3ValFreq");
    sam3TrainElements.capEpoch = document.getElementById("sam3CapEpoch");
    sam3TrainElements.targetEpochSize = document.getElementById("sam3TargetEpochSize");
    sam3TrainElements.capVal = document.getElementById("sam3CapVal");
    sam3TrainElements.valCapSize = document.getElementById("sam3ValCapSize");
    sam3TrainElements.balanceStrategy = document.getElementById("sam3BalanceStrategy");
    sam3TrainElements.balancePower = document.getElementById("sam3BalancePower");
    sam3TrainElements.balanceClip = document.getElementById("sam3BalanceClip");
    sam3TrainElements.balanceBeta = document.getElementById("sam3BalanceBeta");
    sam3TrainElements.balanceGamma = document.getElementById("sam3BalanceGamma");
    sam3TrainElements.balanceDescription = document.getElementById("sam3BalanceDescription");
    sam3TrainElements.warmupSteps = document.getElementById("sam3Warmup");
    sam3TrainElements.schedulerTimescale = document.getElementById("sam3Timescale");
    sam3TrainElements.freezeLanguage = document.getElementById("sam3FreezeLanguage");
    sam3TrainElements.languageLr = document.getElementById("sam3LanguageLr");
    sam3TrainElements.promptVariants = document.getElementById("sam3PromptVariants");
    sam3TrainElements.promptRandomize = document.getElementById("sam3PromptRandomize");
    sam3TrainElements.logAll = document.getElementById("sam3LogAll");
    sam3TrainElements.valScoreThresh = document.getElementById("sam3ValScoreThresh");
    sam3TrainElements.valMaxDets = document.getElementById("sam3ValMaxDets");
    sam3TrainElements.trendSmooth = document.getElementById("sam3TrendSmooth");
    sam3TrainElements.trendSmoothValue = document.getElementById("sam3TrendSmoothValue");
    sam3TrainElements.segHead = document.getElementById("sam3SegHead");
    sam3TrainElements.segTrain = document.getElementById("sam3SegTrain");
    sam3TrainElements.bboxOnly = document.getElementById("sam3BBoxOnly");
    sam3TrainElements.startButton = document.getElementById("sam3StartBtn");
    sam3TrainElements.cancelButton = document.getElementById("sam3CancelBtn");
    sam3TrainElements.statusText = document.getElementById("sam3StatusText");
    sam3TrainElements.etaText = document.getElementById("sam3EtaText");
    sam3TrainElements.progressFill = document.getElementById("sam3ProgressFill");
    sam3TrainElements.message = document.getElementById("sam3Message");
    sam3TrainElements.summary = document.getElementById("sam3Summary");
    sam3TrainElements.balanceSummary = document.getElementById("sam3BalanceSummary");
    sam3TrainElements.log = document.getElementById("sam3Log");
    sam3TrainElements.history = document.getElementById("sam3TrainingHistory");
    sam3TrainElements.lossCanvas = document.getElementById("sam3LossChart");
    sam3TrainElements.valMetrics = document.getElementById("sam3ValMetrics");
    sam3TrainElements.activateButton = document.getElementById("sam3ActivateBtn");
    sam3StorageElements.list = document.getElementById("sam3StorageList");
    sam3StorageElements.refresh = document.getElementById("sam3StorageRefresh");

    if (sam3TrainElements.balanceStrategy) {
        sam3TrainElements.balanceStrategy.addEventListener("change", () => updateBalanceParamVisibility());
        updateBalanceParamVisibility();
    }
    if (sam3TrainElements.trendSmooth && sam3TrainElements.trendSmoothValue) {
        const setTrendLabel = (val) => {
            sam3TrainElements.trendSmoothValue.textContent = Number(val).toFixed(2);
        };
        sam3TrainElements.trendSmooth.addEventListener("input", (e) => {
            const val = parseFloat(e.target.value);
            if (!Number.isFinite(val)) return;
            sam3TrainState.trendAlpha = Math.max(0.001, Math.min(0.9, val));
            setTrendLabel(sam3TrainState.trendAlpha);
            recomputeSam3Trend();
            drawSam3LossChart();
        });
        setTrendLabel(sam3TrainState.trendAlpha || sam3TrainElements.trendSmooth.value || 0.05);
    }
    if (sam3TrainElements.freezeLanguage && sam3TrainElements.languageLr) {
        sam3TrainElements.freezeLanguage.addEventListener("change", () => {
            const frozen = sam3TrainElements.freezeLanguage.checked;
            sam3TrainElements.languageLr.disabled = frozen;
            if (frozen) {
                sam3TrainElements.languageLr.value = "";
            }
        });
    }
    if (sam3TrainElements.segTrain && sam3TrainElements.segHead) {
        sam3TrainElements.segTrain.addEventListener("change", () => {
            if (sam3TrainElements.segTrain.checked) {
                sam3TrainElements.segHead.checked = true;
            }
        });
    }
    if (sam3TrainElements.bboxOnly && sam3TrainElements.segHead && sam3TrainElements.segTrain) {
        sam3TrainElements.bboxOnly.addEventListener("change", () => {
            const bboxMode = sam3TrainElements.bboxOnly.checked;
            if (bboxMode) {
                sam3TrainElements.segHead.checked = false;
                sam3TrainElements.segTrain.checked = false;
            }
        });
    }
    if (sam3TrainElements.datasetSelect) {
        sam3TrainElements.datasetSelect.addEventListener("change", () => {
            sam3TrainState.selectedId = sam3TrainElements.datasetSelect.value;
            const entry = sam3TrainState.datasets.find((d) => d.id === sam3TrainState.selectedId);
            updateSam3DatasetSummary(entry);
            resetSam3Eta();
        });
    }
    if (sam3TrainElements.datasetRefresh) {
        sam3TrainElements.datasetRefresh.addEventListener("click", () => loadSam3Datasets());
    }
    if (sam3TrainElements.randomSplit && sam3TrainElements.valPercent && sam3TrainElements.splitSeed) {
        const syncSam3SplitControls = () => {
            const enabled = !!sam3TrainElements.randomSplit.checked;
            sam3TrainElements.valPercent.disabled = !enabled;
            sam3TrainElements.splitSeed.disabled = !enabled;
        };
        sam3TrainElements.randomSplit.addEventListener("change", syncSam3SplitControls);
        syncSam3SplitControls();
    }
    if (sam3TrainElements.cachePurge) {
        sam3TrainElements.cachePurge.addEventListener("click", purgeSam3SplitCache);
    }
    refreshSam3SplitCache();
    if (sam3TrainElements.capEpoch && sam3TrainElements.targetEpochSize) {
        sam3TrainElements.capEpoch.addEventListener("change", () => {
            sam3TrainElements.targetEpochSize.disabled = !sam3TrainElements.capEpoch.checked;
        });
        sam3TrainElements.targetEpochSize.disabled = !sam3TrainElements.capEpoch.checked;
    }
    if (sam3TrainElements.capVal && sam3TrainElements.valCapSize) {
        sam3TrainElements.capVal.addEventListener("change", () => {
            sam3TrainElements.valCapSize.disabled = !sam3TrainElements.capVal.checked;
        });
        sam3TrainElements.valCapSize.disabled = !sam3TrainElements.capVal.checked;
    }
    if (sam3TrainElements.datasetConvert) {
        sam3TrainElements.datasetConvert.addEventListener("click", () => convertSam3Dataset().catch(() => {}));
    }
    if (sam3TrainElements.startButton) {
        sam3TrainElements.startButton.addEventListener("click", () => startSam3Training());
    }
    if (sam3TrainElements.cancelButton) {
        sam3TrainElements.cancelButton.addEventListener("click", () => cancelSam3Training());
    }
    if (sam3TrainElements.activateButton) {
        sam3TrainElements.activateButton.addEventListener("click", () => activateSam3Checkpoint());
    }
    if (sam3StorageElements.refresh) {
        sam3StorageElements.refresh.addEventListener("click", () => refreshRunStorage());
    }
    await loadSam3Datasets();
    await refreshSam3History();
    await refreshRunStorage();
}

async function cancelQwenDatasetUpload(jobId) {
    if (!jobId) {
        return;
    }
    try {
        const formData = new FormData();
        formData.append("job_id", jobId);
        await fetch(`${API_ROOT}/qwen/dataset/cancel`, {
            method: "POST",
            body: formData,
        });
    } catch (error) {
        console.debug("Failed to cancel Qwen dataset upload", error);
    }
}

	async function uploadQwenDatasetStream(options = {}) {
	    const imageNames = Object.keys(images);
	    if (!imageNames.length) {
	        throw new Error("Load images before starting Qwen training.");
	    }
	    const classNames = Object.keys(classes || {});
	    if (!classNames.length) {
	        throw new Error("Load a label map before starting Qwen training.");
	    }
	    const contextOverride = typeof options.contextText === "string" ? options.contextText.trim() : "";
	    const contextText = contextOverride || qwenTrainElements.contextInput?.value?.trim() || "";
	    const instruction = buildQwenInstruction(contextText, classNames);
	    const stats = computeQwenDatasetStats(imageNames);
    let packagingModalVisible = false;
    let jobId = null;
    try {
        const summaryText = `${stats.imageCount} image${stats.imageCount === 1 ? "" : "s"} (${formatBytes(stats.imageBytes)}) + streaming annotations`;
        showTrainingPackagingModal(stats, {
            indeterminate: false,
            progressText: "Preparing dataset…",
            hintText: "Keep this tab open while we package the dataset for Qwen training.",
            summaryText,
        });
        packagingModalVisible = true;
	        const runNameOverride = typeof options.runName === "string" ? options.runName.trim() : "";
	        const runName = runNameOverride || qwenTrainElements.runNameInput?.value?.trim() || "qwen_dataset";
	        const initInfo = await initQwenDatasetUpload(runName);
        jobId = initInfo?.job_id;
        if (!jobId) {
            throw new Error("Dataset upload job id missing in response.");
        }
        const usedNames = new Map();
        const valSet = pickQwenValidationSet(imageNames);
        let processed = 0;
        let totalBoxes = 0;
        let uploadedTrain = 0;
        let uploadedVal = 0;
        let firstTrainRecord = null;
        let firstValRecord = null;
        for (const imageKey of imageNames) {
            const imageRecord = images[imageKey];
            if (!imageRecord || !imageRecord.meta) {
                throw new Error(`Missing original file for ${imageKey}. Re-import the images and try again.`);
            }
            await ensureImageDimensions(imageRecord);
            const baseName = imageRecord.meta.name || imageKey;
            const safeName = makeUniqueFilename(baseName, usedNames);
            const detections = buildDetectionRecords(imageKey, imageRecord);
            totalBoxes += detections.length;
            const split = valSet.has(imageKey) ? "val" : "train";
            const bboxPrompt = buildQwenSampleUserPrompt(instruction, classNames, "all", "bbox");
            const pointPrompt = buildQwenSampleUserPrompt(instruction, classNames, "all", "point");
            const bboxOutput = buildQwenOutputPayload(detections, "bbox");
            const pointOutput = buildQwenOutputPayload(detections, "point");
            const recordPayloads = [
                {
                    imageName: safeName,
                    annotation: buildQwenConversationRecord(safeName, bboxPrompt, bboxOutput),
                    file: imageRecord.meta,
                },
                {
                    imageName: safeName,
                    annotation: buildQwenConversationRecord(safeName, pointPrompt, pointOutput),
                    file: imageRecord.meta,
                },
            ];
            for (const recordPayload of recordPayloads) {
                await uploadQwenDatasetChunk(jobId, split, recordPayload);
                if (split === "train") {
                    uploadedTrain += 1;
                    if (!firstTrainRecord) {
                        firstTrainRecord = recordPayload;
                    }
                } else {
                    uploadedVal += 1;
                    if (!firstValRecord) {
                        firstValRecord = recordPayload;
                    }
                }
            }
            processed += 1;
            if (stats.imageCount > 0) {
                const percent = Math.min(95, Math.round((processed / stats.imageCount) * 90));
                updateTrainingPackagingProgress(percent, `Uploading dataset… ${percent}%`);
            }
        }
        if (uploadedTrain === 0 && firstValRecord) {
            await uploadQwenDatasetChunk(jobId, "train", firstValRecord);
            uploadedTrain += 1;
        }
        if (uploadedVal === 0 && firstTrainRecord) {
            await uploadQwenDatasetChunk(jobId, "val", firstTrainRecord);
            uploadedVal += 1;
        }
        if (totalBoxes === 0) {
            throw new Error("No bounding boxes available. Draw bboxes before training.");
        }
        const datasetMeta = {
            context: contextText,
            classes: classNames,
            created_at: Date.now(),
        };
        const finalizeInfo = await finalizeQwenDatasetUpload(jobId, datasetMeta, runName);
        updateTrainingPackagingProgress(100, "Dataset staged");
        return finalizeInfo;
    } catch (error) {
        await cancelQwenDatasetUpload(jobId);
        throw error;
    } finally {
        if (packagingModalVisible) {
            hideTrainingPackagingModal();
        }
    }
}

	function buildQwenTrainingPayload(datasetId, datasetRunName) {
	    const payload = { dataset_id: datasetId };
	    const runName = qwenTrainElements.runNameInput?.value?.trim() || datasetRunName;
	    if (runName) {
	        payload.run_name = runName;
	    }
    if (qwenTrainElements.randomSplit) {
        payload.random_split = !!qwenTrainElements.randomSplit.checked;
    }
    const valPct = readNumberInput(qwenTrainElements.valPercent, { integer: true });
    if (valPct !== undefined) {
        const clampedPct = Math.max(1, Math.min(valPct, 90));
        payload.val_percent = clampedPct / 100;
    }
    const splitSeed = readNumberInput(qwenTrainElements.splitSeed, { integer: true });
    if (splitSeed !== undefined) {
        payload.split_seed = splitSeed;
    }
    payload.model_id = resolveQwenModelId();
    payload.training_mode = getSelectedQwenTrainMode();
    const systemPrompt = qwenTrainElements.systemPromptInput?.value?.trim();
    if (systemPrompt) {
        payload.system_prompt = systemPrompt;
    }
    const numericMap = [
        ["batch_size", qwenTrainElements.batchSizeInput, { integer: true }],
        ["max_epochs", qwenTrainElements.epochsInput, { integer: true }],
        ["lr", qwenTrainElements.lrInput, { integer: false }],
        ["accumulate_grad_batches", qwenTrainElements.accumulateInput, { integer: true }],
        ["lora_rank", qwenTrainElements.loraRankInput, { integer: true }],
        ["lora_alpha", qwenTrainElements.loraAlphaInput, { integer: true }],
        ["lora_dropout", qwenTrainElements.loraDropoutInput, { integer: false }],
        ["log_every_n_steps", qwenTrainElements.logStepsInput, { integer: true }],
        ["min_pixels", qwenTrainElements.minPixelsInput, { integer: true }],
        ["max_pixels", qwenTrainElements.maxPixelsInput, { integer: true }],
        ["max_length", qwenTrainElements.maxLengthInput, { integer: true }],
    ];
    numericMap.forEach(([key, input, opts]) => {
        const value = readNumberInput(input, opts || {});
        if (value !== undefined) {
            payload[key] = value;
        }
    });
    const rawTargets = qwenTrainElements.loraTargetsInput?.value?.trim();
    if (rawTargets) {
        payload.lora_target_modules = rawTargets.split(",").map((value) => value.trim()).filter(Boolean);
    }
    return payload;
}

function setQwenSampleOverlay(text, variant) {
    const overlay = qwenTrainElements.sampleMessage;
    if (!overlay) {
        return;
    }
    overlay.textContent = text || "";
    overlay.classList.remove("hidden", "error", "success");
    if (variant) {
        overlay.classList.add(variant);
    }
    if (!text) {
        overlay.classList.add("hidden");
    }
}

function updateQwenSampleMeta(text) {
    if (qwenTrainElements.sampleMeta) {
        qwenTrainElements.sampleMeta.textContent = text || "";
    }
}

async function generateRandomQwenSample() {
    if (!qwenTrainElements.sampleButton) {
        return;
    }
    qwenTrainElements.sampleButton.disabled = true;
    try {
        setQwenSampleOverlay("Building sample…", "");
        const sample = await buildRandomQwenSampleData();
        await renderQwenSamplePreview(sample);
        const scope = describeQwenSampleScope(sample.mode, sample.labels);
        updateQwenSampleMeta(`Image: ${sample.imageLabel} • ${sample.useBBox ? "Bounding boxes" : "Points"} • ${scope}`);
        setQwenSampleOverlay("", "");
    } catch (error) {
        console.error(error);
        clearQwenSamplePreview();
        setQwenSampleOverlay(error.message || "Unable to build sample", "error");
        updateQwenSampleMeta("");
    } finally {
        qwenTrainElements.sampleButton.disabled = false;
    }
}

function describeQwenSampleScope(mode, labels) {
    if (!labels || !labels.length || mode === "all") {
        return "All classes";
    }
    if (mode === "single") {
        return `Only '${labels[0]}'`;
    }
    return `Subset: ${labels.join(", ")}`;
}

async function buildRandomQwenSampleData() {
    const imageKeys = Object.keys(images || {});
    if (!imageKeys.length) {
        throw new Error("Load images before generating a sample.");
    }
    const classNames = Object.keys(classes || {});
    if (!classNames.length) {
        throw new Error("Load a label map before generating a sample.");
    }
    const randomKey = imageKeys[Math.floor(Math.random() * imageKeys.length)];
    const imageRecord = images[randomKey];
    if (!imageRecord || !imageRecord.meta) {
        throw new Error("Selected image is missing its source file. Re-import and try again.");
    }
    await ensureImageDimensions(imageRecord);
    if (!imageRecord.object) {
        await loadImageObject(imageRecord);
    }
    const detections = buildDetectionRecords(randomKey, imageRecord);
    const contextText = qwenTrainElements.contextInput?.value?.trim() || "";
    const datasetInstruction = buildQwenInstruction(contextText, classNames);
    const { labels, mode } = chooseQwenSampleLabelSet(detections);
    const filtered = filterDetectionsForLabels(detections, labels, mode);
    const useBBox = Math.random() < 0.5;
    const prompt = buildQwenSampleUserPrompt(datasetInstruction, labels, mode, useBBox ? "bbox" : "point");
    const expectedDetections = filtered.map((det) => {
        const payload = { label: det.label };
        if (useBBox) {
            payload.bbox = det.bbox;
        } else {
            payload.point = det.point;
        }
        return payload;
    });
    return {
        imageKey: randomKey,
        imageLabel: imageRecord.meta.name || randomKey,
        imageRecord,
        prompt,
        expected: { detections: expectedDetections },
        labels,
        mode,
        useBBox,
    };
}

function clearQwenSamplePreview() {
    if (qwenTrainElements.sampleCanvas) {
        const ctx = qwenTrainElements.sampleCanvas.getContext("2d");
        if (ctx) {
            ctx.clearRect(0, 0, qwenTrainElements.sampleCanvas.width, qwenTrainElements.sampleCanvas.height);
        }
    }
    if (qwenTrainElements.samplePrompt) {
        qwenTrainElements.samplePrompt.textContent = "";
    }
    if (qwenTrainElements.sampleExpected) {
        qwenTrainElements.sampleExpected.textContent = "";
    }
}

async function renderQwenSamplePreview(sample) {
    if (!qwenTrainElements.sampleCanvas || !sample.imageRecord.object) {
        return;
    }
    const canvas = qwenTrainElements.sampleCanvas;
    const ctx = canvas.getContext("2d");
    if (!ctx) {
        return;
    }
    const width = sample.imageRecord.width || sample.imageRecord.object.width || 1;
    const height = sample.imageRecord.height || sample.imageRecord.object.height || 1;
    const maxW = 360;
    const maxH = 260;
    const scale = Math.min(maxW / width, maxH / height, 1);
    canvas.width = Math.max(1, Math.round(width * scale));
    canvas.height = Math.max(1, Math.round(height * scale));
    ctx.clearRect(0, 0, canvas.width, canvas.height);
    ctx.drawImage(sample.imageRecord.object, 0, 0, canvas.width, canvas.height);
    if (sample.useBBox) {
        ctx.strokeStyle = "#10b981";
        ctx.lineWidth = Math.max(1, 2 * scale);
        (sample.expected.detections || []).forEach((det) => {
            if (!det.bbox) {
                return;
            }
            const [x1, y1, x2, y2] = det.bbox;
            ctx.strokeRect(x1 * scale, y1 * scale, (x2 - x1) * scale, (y2 - y1) * scale);
        });
    } else {
        ctx.fillStyle = "#ef4444";
        const radius = Math.max(3, 4 * scale);
        (sample.expected.detections || []).forEach((det) => {
            if (!det.point) {
                return;
            }
            const [x, y] = det.point;
            ctx.beginPath();
            ctx.arc(x * scale, y * scale, radius, 0, Math.PI * 2);
            ctx.fill();
        });
    }
    if (qwenTrainElements.samplePrompt) {
        qwenTrainElements.samplePrompt.textContent = sample.prompt;
    }
    if (qwenTrainElements.sampleExpected) {
        qwenTrainElements.sampleExpected.textContent = JSON.stringify(sample.expected, null, 2);
    }
}

		async function handleStartQwenTraining() {
		    if (qwenTrainElements.startButton) {
		        qwenTrainElements.startButton.disabled = true;
		    }
		    try {
		        const cachedEntry = getSelectedQwenDataset();
		        if (!cachedEntry) {
		            setQwenTrainMessage("Select a dataset (manage them in Dataset Management first).", "error");
		            if (qwenTrainElements.startButton) {
		                qwenTrainElements.startButton.disabled = false;
		            }
		            return;
		        }
		        if (!cachedEntry.qwen_ready) {
		            setQwenTrainMessage("Selected dataset needs Qwen annotations. Go to Dataset Management and click “Build Qwen”.", "error");
		            return;
		        }
		        const datasetInfo = {
		            dataset_id: cachedEntry.id,
		            run_name: qwenTrainElements.runNameInput?.value?.trim() || cachedEntry.id,
		        };
		        setQwenTrainMessage("Starting training job…");
		        const payload = buildQwenTrainingPayload(datasetInfo.dataset_id, datasetInfo.run_name);
	        const resp = await fetch(`${API_ROOT}/qwen/train/jobs`, {
	            method: "POST",
	            headers: { "Content-Type": "application/json" },
	            body: JSON.stringify(payload),
        });
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || `HTTP ${resp.status}`);
        }
        const data = await resp.json();
        qwenTrainState.activeJobId = data.job_id;
        setQwenTrainMessage("Job started", "success");
        if (qwenTrainElements.cancelButton) {
            qwenTrainElements.cancelButton.disabled = false;
        }
        await pollQwenTrainingJob(data.job_id, { force: true });
        await refreshQwenTrainingHistory();
    } catch (error) {
        console.error("Qwen training submit failed", error);
        setQwenTrainMessage(error.message || "Failed to start training", "error");
    } finally {
        if (qwenTrainElements.startButton) {
            qwenTrainElements.startButton.disabled = false;
        }
    }
}

async function cancelQwenTrainingJobRequest() {
    if (!qwenTrainState.activeJobId) {
        return;
    }
    try {
        const resp = await fetch(`${API_ROOT}/qwen/train/jobs/${qwenTrainState.activeJobId}/cancel`, { method: "POST" });
        if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}`);
        }
        setQwenTrainMessage("Cancellation requested", "warn");
    } catch (error) {
        console.error("Cancel Qwen job failed", error);
        setQwenTrainMessage(error.message || "Failed to cancel job", "error");
    }
}

function updateQwenTrainingUI(job) {
    if (!job) {
        return;
    }
    qwenTrainState.lastJobSnapshot = job;
    const pct = Math.round((job.progress || 0) * 100);
    if (qwenTrainElements.progressFill) {
        qwenTrainElements.progressFill.style.width = `${pct}%`;
    }
    if (qwenTrainElements.statusText) {
        const message = job.message ? ` • ${job.message}` : "";
        qwenTrainElements.statusText.textContent = `${job.status?.toUpperCase() || ""}${message}`;
    }
    if (qwenTrainElements.log) {
        const logs = Array.isArray(job.logs) ? job.logs : [];
        qwenTrainElements.log.textContent = logs
            .map((entry) => `[${formatTimestamp(entry.timestamp)}] ${entry.message}`)
            .join("\n");
    }
    if (qwenTrainElements.summary) {
        if (job.result) {
            const latest = job.result.latest || "–";
            const epochs = job.result.epochs_ran ?? "–";
            qwenTrainElements.summary.innerHTML = `
                <p><strong>Latest checkpoint:</strong> ${escapeHtml(latest)}</p>
                <p><strong>Epochs:</strong> ${escapeHtml(String(epochs))}</p>
            `;
        } else {
            qwenTrainElements.summary.textContent = "";
        }
    }
    if (job.status === "succeeded" || job.status === "failed" || job.status === "cancelled") {
        if (qwenTrainElements.cancelButton) {
            qwenTrainElements.cancelButton.disabled = true;
        }
    }
    updateQwenEpochDetail(job);
    updateQwenLossChart(job);
}

function findLatestMetric(metrics, predicate) {
    if (!Array.isArray(metrics)) {
        return null;
    }
    for (let index = metrics.length - 1; index >= 0; index -= 1) {
        const entry = metrics[index];
        if (!entry || typeof entry !== "object") {
            continue;
        }
        if (!predicate || predicate(entry)) {
            return entry;
        }
    }
    return null;
}

function updateQwenEpochDetail(job) {
    if (!qwenTrainElements.epochDetail) {
        return;
    }
    const metrics = Array.isArray(job?.metrics) ? job.metrics : [];
    if (!metrics.length) {
        qwenTrainElements.epochDetail.textContent = "Waiting for telemetry…";
        return;
    }
    const latestTrain = findLatestMetric(metrics, (entry) => entry.phase === "train");
    const source = latestTrain || findLatestMetric(metrics);
    if (!source) {
        qwenTrainElements.epochDetail.textContent = "Waiting for telemetry…";
        return;
    }
    const parts = [];
    const epoch = Number.isFinite(source.epoch) ? source.epoch : null;
    const totalEpochs = Number.isFinite(source.total_epochs)
        ? source.total_epochs
        : Number.isFinite(job?.config?.max_epochs)
            ? job.config.max_epochs
            : null;
    if (epoch && totalEpochs) {
        parts.push(`Epoch ${epoch}/${totalEpochs}`);
    } else if (epoch) {
        parts.push(`Epoch ${epoch}`);
    }
    if (source.phase === "train") {
        if (Number.isFinite(source.batch) && Number.isFinite(source.batches_per_epoch)) {
            parts.push(`Batch ${source.batch}/${source.batches_per_epoch}`);
        }
        if (typeof source.epoch_progress === "number") {
            parts.push(`${Math.round(source.epoch_progress * 100)}% of epoch`);
        }
        if (typeof source.train_loss === "number") {
            parts.push(`Loss ${source.train_loss.toFixed(4)}`);
        }
    } else if (source.phase === "val") {
        if (typeof source.value === "number") {
            const metricLabel =
                typeof source.metric === "string" && source.metric.length
                    ? source.metric.replace(/_/g, " ")
                    : "Validation metric";
            parts.push(`${metricLabel} ${source.value.toFixed(4)}`);
        }
    }
    qwenTrainElements.epochDetail.textContent = parts.length ? parts.join(" • ") : "Telemetry updating…";
}

function getQwenLossSeries(job) {
    const metrics = Array.isArray(job?.metrics) ? job.metrics : [];
    const series = [];
    metrics.forEach((entry) => {
        if (!entry || typeof entry !== "object") {
            return;
        }
        if (entry.phase !== "train") {
            return;
        }
        const loss = Number.isFinite(entry.train_loss) ? entry.train_loss : null;
        if (loss === null) {
            return;
        }
        const step =
            Number.isFinite(entry.step) && entry.step !== null
                ? entry.step
                : Number.isFinite(entry.batch)
                    ? entry.batch
                    : series.length + 1;
        series.push({ x: step, y: loss });
    });
    return series;
}

function smoothLossSeries(points, windowSize) {
    if (!Number.isFinite(windowSize) || windowSize <= 1) {
        return points.slice();
    }
    const window = [];
    let sum = 0;
    return points.map((point) => {
        window.push(point.y);
        sum += point.y;
        if (window.length > windowSize) {
            sum -= window.shift();
        }
        const average = sum / window.length;
        return { x: point.x, y: average };
    });
}

function drawQwenLossChart(points) {
    const canvas = qwenTrainElements.lossCanvas;
    if (!canvas) {
        return;
    }
    const ctx = canvas.getContext("2d");
    if (!ctx) {
        return;
    }
    const width = Math.max(canvas.clientWidth || 400, 320);
    const height = Math.max(canvas.clientHeight || 200, 160);
    const dpr = window.devicePixelRatio || 1;
    if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
        canvas.width = width * dpr;
        canvas.height = height * dpr;
    }
    ctx.save();
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, width, height);
    const axisMinY = 0;
    const axisMaxY = 8;
    const topPadding = 14;
    const bottomPadding = 14;
    const rightPadding = 14;
    const leftPadding = 44;
    const chartWidth = Math.max(1, width - leftPadding - rightPadding);
    const chartHeight = Math.max(1, height - topPadding - bottomPadding);
    const minX = points[0].x;
    const maxX = points[points.length - 1].x;
    const xRange = maxX - minX || 1;
    const yRange = axisMaxY - axisMinY || 1;
    const clampY = (value) => Math.min(Math.max(value, axisMinY), axisMaxY);
    ctx.strokeStyle = "#e2e8f0";
    ctx.lineWidth = 1;
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#94a3b8";
    ctx.font = "12px sans-serif";
    for (let tick = axisMinY; tick <= axisMaxY; tick += 1) {
        const norm = (tick - axisMinY) / yRange;
        const y = topPadding + (1 - norm) * chartHeight;
        ctx.beginPath();
        ctx.moveTo(leftPadding, y);
        ctx.lineTo(width - rightPadding, y);
        ctx.stroke();
        ctx.fillText(String(tick), leftPadding - 6, y);
    }
    ctx.strokeStyle = "#94a3b8";
    ctx.beginPath();
    ctx.moveTo(leftPadding, topPadding);
    ctx.lineTo(leftPadding, topPadding + chartHeight);
    ctx.stroke();
    ctx.strokeStyle = "#2563eb";
    ctx.lineWidth = 2;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.beginPath();
    points.forEach((point, index) => {
        const normX = (point.x - minX) / xRange;
        const normY = (clampY(point.y) - axisMinY) / yRange;
        const xPos = leftPadding + normX * chartWidth;
        const yPos = topPadding + (1 - normY) * chartHeight;
        if (index === 0) {
            ctx.moveTo(xPos, yPos);
        } else {
            ctx.lineTo(xPos, yPos);
        }
    });
    ctx.stroke();
    ctx.restore();
}

function pickYoloMetricKey(metrics) {
    const options = [
        { key: "metrics/mAP50-95(B)", label: "mAP50-95 (box)" },
        { key: "metrics/mAP50-95(M)", label: "mAP50-95 (mask)" },
        { key: "metrics/mAP50(B)", label: "mAP50 (box)" },
        { key: "metrics/mAP50(M)", label: "mAP50 (mask)" },
        { key: "metrics/precision(B)", label: "Precision (box)" },
        { key: "metrics/precision(M)", label: "Precision (mask)" },
        { key: "metrics/recall(B)", label: "Recall (box)" },
        { key: "metrics/recall(M)", label: "Recall (mask)" },
    ];
    for (const option of options) {
        if (metrics.some((entry) => Number.isFinite(entry?.[option.key]))) {
            return option;
        }
    }
    return { key: null, label: "Metric" };
}

function drawMetricChartCanvas(canvas, points, lineColor = "#16a34a") {
    if (!canvas) {
        return;
    }
    const ctx = canvas.getContext("2d");
    if (!ctx) {
        return;
    }
    const width = Math.max(canvas.clientWidth || 400, 320);
    const height = Math.max(canvas.clientHeight || 200, 160);
    const dpr = window.devicePixelRatio || 1;
    if (canvas.width !== width * dpr || canvas.height !== height * dpr) {
        canvas.width = width * dpr;
        canvas.height = height * dpr;
    }
    ctx.save();
    ctx.scale(dpr, dpr);
    ctx.clearRect(0, 0, width, height);
    if (!points.length) {
        ctx.restore();
        return;
    }
    const values = points.map((point) => point.y).filter((val) => Number.isFinite(val));
    const minY = values.length ? Math.min(...values) : 0;
    const maxY = values.length ? Math.max(...values) : 1;
    const bounded = minY >= 0 && maxY <= 1.0;
    const axisMinY = bounded ? 0 : minY;
    const axisMaxY = bounded ? 1 : maxY;
    const topPadding = 14;
    const bottomPadding = 14;
    const rightPadding = 14;
    const leftPadding = 44;
    const chartWidth = Math.max(1, width - leftPadding - rightPadding);
    const chartHeight = Math.max(1, height - topPadding - bottomPadding);
    const minX = points[0].x;
    const maxX = points[points.length - 1].x;
    const xRange = maxX - minX || 1;
    const yRange = axisMaxY - axisMinY || 1;
    ctx.strokeStyle = "#e2e8f0";
    ctx.lineWidth = 1;
    ctx.textAlign = "right";
    ctx.textBaseline = "middle";
    ctx.fillStyle = "#94a3b8";
    ctx.font = "12px sans-serif";
    const ticks = 5;
    for (let i = 0; i <= ticks; i += 1) {
        const tick = axisMinY + (i / ticks) * yRange;
        const norm = (tick - axisMinY) / yRange;
        const y = topPadding + (1 - norm) * chartHeight;
        ctx.beginPath();
        ctx.moveTo(leftPadding, y);
        ctx.lineTo(width - rightPadding, y);
        ctx.stroke();
        ctx.fillText(tick.toFixed(2), leftPadding - 6, y);
    }
    ctx.strokeStyle = "#94a3b8";
    ctx.beginPath();
    ctx.moveTo(leftPadding, topPadding);
    ctx.lineTo(leftPadding, topPadding + chartHeight);
    ctx.stroke();
    ctx.strokeStyle = lineColor;
    ctx.lineWidth = 2;
    ctx.lineJoin = "round";
    ctx.lineCap = "round";
    ctx.beginPath();
    points.forEach((point, index) => {
        const normX = (point.x - minX) / xRange;
        const normY = (point.y - axisMinY) / yRange;
        const xPos = leftPadding + normX * chartWidth;
        const yPos = topPadding + (1 - normY) * chartHeight;
        if (index === 0) {
            ctx.moveTo(xPos, yPos);
        } else {
            ctx.lineTo(xPos, yPos);
        }
    });
    ctx.stroke();
    ctx.restore();
}

function updateClipTrainingChart(metricsOrArtifacts) {
    if (!trainingElements.metricCanvas || !trainingElements.chartStatus) {
        return;
    }
    const trace = Array.isArray(metricsOrArtifacts)
        ? metricsOrArtifacts
        : (metricsOrArtifacts && Array.isArray(metricsOrArtifacts.convergence_trace)
            ? metricsOrArtifacts.convergence_trace
            : []);
    if (!trace.length) {
        trainingElements.chartStatus.textContent = "Metrics appear after training completes.";
        const ctx = trainingElements.metricCanvas.getContext("2d");
        if (ctx) {
            ctx.clearRect(0, 0, trainingElements.metricCanvas.width, trainingElements.metricCanvas.height);
        }
        return;
    }
    let metricKey = null;
    let label = null;
    let color = "#16a34a";
    if (trace.some((entry) => Number.isFinite(entry?.val_accuracy))) {
        metricKey = "val_accuracy";
        label = "Validation accuracy";
    } else if (trace.some((entry) => Number.isFinite(entry?.val_loss))) {
        metricKey = "val_loss";
        label = "Validation loss";
        color = "#2563eb";
    } else if (trace.some((entry) => Number.isFinite(entry?.loss))) {
        metricKey = "loss";
        label = "Training loss";
        color = "#2563eb";
    }
    if (!metricKey) {
        trainingElements.chartStatus.textContent = "No numeric metrics available yet.";
        return;
    }
    const series = trace
        .map((entry, idx) => {
            if (!entry) return null;
            const y = entry[metricKey];
            if (!Number.isFinite(y)) {
                return null;
            }
            const x = Number.isFinite(entry.epoch)
                ? entry.epoch
                : Number.isFinite(entry.iteration)
                    ? entry.iteration
                    : idx + 1;
            return { x, y: Number(y) };
        })
        .filter(Boolean);
    if (!series.length) {
        trainingElements.chartStatus.textContent = "No numeric metrics available yet.";
        return;
    }
    drawMetricChartCanvas(trainingElements.metricCanvas, series, color);
    trainingElements.chartStatus.textContent = `${label} over ${series.length} step${series.length === 1 ? "" : "s"}.`;
}

function drawYoloMetricChart(points) {
    drawMetricChartCanvas(yoloTrainElements.metricCanvas, points, "#16a34a");
}

function updateYoloMetricChart(metrics) {
    if (!yoloTrainElements.metricCanvas || !yoloTrainElements.chartStatus) {
        return;
    }
    if (!Array.isArray(metrics) || !metrics.length) {
        yoloTrainElements.chartStatus.textContent = "Metrics appear after training completes.";
        const ctx = yoloTrainElements.metricCanvas.getContext("2d");
        if (ctx) {
            ctx.clearRect(0, 0, yoloTrainElements.metricCanvas.width, yoloTrainElements.metricCanvas.height);
        }
        return;
    }
    const choice = pickYoloMetricKey(metrics);
    if (!choice.key) {
        yoloTrainElements.chartStatus.textContent = "No mAP/precision metrics found.";
        return;
    }
    const series = metrics
        .map((entry, idx) => {
            const y = entry[choice.key];
            if (!Number.isFinite(y)) {
                return null;
            }
            const x = Number.isFinite(entry.epoch) ? entry.epoch : idx + 1;
            return { x, y };
        })
        .filter(Boolean);
    if (!series.length) {
        yoloTrainElements.chartStatus.textContent = "No numeric metrics available yet.";
        return;
    }
    drawYoloMetricChart(series);
    yoloTrainElements.chartStatus.textContent = `${choice.label} over ${series.length} epoch${series.length === 1 ? "" : "s"}.`;
}

function updateRfDetrMetricChart(metrics) {
    if (!rfdetrTrainElements.metricCanvas || !rfdetrTrainElements.chartStatus) {
        return;
    }
    if (!Array.isArray(metrics) || !metrics.length) {
        rfdetrTrainElements.chartStatus.textContent = "Metrics appear after training completes.";
        const ctx = rfdetrTrainElements.metricCanvas.getContext("2d");
        if (ctx) {
            ctx.clearRect(0, 0, rfdetrTrainElements.metricCanvas.width, rfdetrTrainElements.metricCanvas.height);
        }
        return;
    }
    let seriesLabel = null;
    const series = metrics
        .map((entry, idx) => {
            if (!entry) return null;
            const epoch = Number.isFinite(entry.epoch) ? entry.epoch : idx + 1;
            const emaArr = Array.isArray(entry.ema_test_coco_eval_bbox) ? entry.ema_test_coco_eval_bbox : null;
            const baseArr = Array.isArray(entry.test_coco_eval_bbox) ? entry.test_coco_eval_bbox : null;
            if (emaArr && Number.isFinite(emaArr[0])) {
                seriesLabel = "AP50-95 (EMA)";
                return { x: epoch, y: Number(emaArr[0]) };
            }
            if (baseArr && Number.isFinite(baseArr[0])) {
                seriesLabel = "AP50-95";
                return { x: epoch, y: Number(baseArr[0]) };
            }
            if (Number.isFinite(entry.train_loss)) {
                if (!seriesLabel) seriesLabel = "Train loss";
                return { x: epoch, y: Number(entry.train_loss) };
            }
            return null;
        })
        .filter(Boolean);
    if (!series.length) {
        rfdetrTrainElements.chartStatus.textContent = "No numeric metrics available yet.";
        return;
    }
    drawMetricChartCanvas(rfdetrTrainElements.metricCanvas, series, "#2563eb");
    rfdetrTrainElements.chartStatus.textContent = `${seriesLabel || "Metric"} over ${series.length} epoch${series.length === 1 ? "" : "s"}.`;
}

function resetQwenLossCanvas() {
    const canvas = qwenTrainElements.lossCanvas;
    if (!canvas) {
        return;
    }
    const ctx = canvas.getContext("2d");
    if (ctx) {
        ctx.clearRect(0, 0, canvas.width || 0, canvas.height || 0);
    }
}

function updateQwenLossChart(job) {
    if (!qwenTrainElements.lossCanvas || !qwenTrainElements.chartStatus) {
        return;
    }
    const points = getQwenLossSeries(job);
    if (!points.length) {
        resetQwenLossCanvas();
        qwenTrainElements.chartStatus.textContent = "Loss telemetry will appear while a job is running.";
        return;
    }
    const smoothing = Math.max(1, parseInt(qwenTrainState.chartSmoothing, 10) || 1);
    const processed = smoothing > 1 ? smoothLossSeries(points, smoothing) : points;
    drawQwenLossChart(processed);
    const smoothingLabel = smoothing > 1 ? ` • ${smoothing}-point avg` : "";
    qwenTrainElements.chartStatus.textContent = `${points.length} samples${smoothingLabel}`;
}

function renderQwenTrainingHistoryItem(container, job) {
    if (!container) {
        return;
    }
    const item = document.createElement("div");
    item.className = "training-history-item";
    const label = job?.config?.run_name || job.job_id;
    const status = job.status || "unknown";
    const created = job.created_at ? new Date(job.created_at * 1000).toLocaleString() : "";
    const left = document.createElement("div");
    left.innerHTML = `<strong>${escapeHtml(label)}</strong><div class="training-help">${escapeHtml(status)} • ${escapeHtml(created)}</div>`;
    const right = document.createElement("div");
    const viewBtn = document.createElement("button");
    viewBtn.type = "button";
    viewBtn.className = "training-button";
    viewBtn.textContent = "View";
    viewBtn.addEventListener("click", () => {
        qwenTrainState.activeJobId = job.job_id;
        pollQwenTrainingJob(job.job_id, { force: true }).catch((error) => console.error("Poll Qwen job failed", error));
    });
    right.appendChild(viewBtn);
    item.append(left, right);
    container.appendChild(item);
}

async function refreshQwenTrainingHistory() {
    if (!qwenTrainElements.historyContainer) {
        return;
    }
    try {
        const resp = await fetch(`${API_ROOT}/qwen/train/jobs`);
        if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}`);
        }
        const jobs = await resp.json();
        qwenTrainElements.historyContainer.innerHTML = "";
        if (!Array.isArray(jobs) || !jobs.length) {
            const empty = document.createElement("div");
            empty.className = "training-history-item";
            empty.textContent = "No Qwen jobs yet.";
            qwenTrainElements.historyContainer.appendChild(empty);
            return;
        }
        jobs.forEach((job) => renderQwenTrainingHistoryItem(qwenTrainElements.historyContainer, job));
    } catch (error) {
        console.error("Failed to load Qwen job history", error);
        qwenTrainElements.historyContainer.textContent = `Unable to load history: ${error.message || error}`;
    }
}

function scheduleQwenJobPoll(jobId, delayMs = 5000) {
    if (qwenTrainState.pollHandle) {
        clearTimeout(qwenTrainState.pollHandle);
    }
    qwenTrainState.pollHandle = window.setTimeout(() => {
        pollQwenTrainingJob(jobId, { force: true }).catch((error) => console.error("Qwen poll failed", error));
    }, delayMs);
}

async function pollQwenTrainingJob(jobId, { force = false } = {}) {
    if (!jobId) {
        return;
    }
    try {
        const resp = await fetch(`${API_ROOT}/qwen/train/jobs/${jobId}`);
        if (!resp.ok) {
            throw new Error(`HTTP ${resp.status}`);
        }
        const job = await resp.json();
        qwenTrainState.activeJobId = job.job_id;
        updateQwenTrainingUI(job);
        const terminalStates = new Set(["succeeded", "failed", "cancelled"]);
        if (!terminalStates.has(job.status)) {
            scheduleQwenJobPoll(job.job_id);
        } else if (qwenTrainState.pollHandle) {
            clearTimeout(qwenTrainState.pollHandle);
            qwenTrainState.pollHandle = null;
        }
    } catch (error) {
        console.error("pollQwenTrainingJob error", error);
        setQwenTrainMessage(error.message || "Unable to load job", "error");
    }
}

function initQwenTrainingTab() {
	        if (qwenTrainElements.runNameInput) {
	            return;
	        }
	        qwenTrainElements.runNameInput = document.getElementById("qwenTrainRunName");
	        qwenTrainElements.modelSizeSelect = document.getElementById("qwenTrainModelSize");
	        qwenTrainElements.modelVariantSelect = document.getElementById("qwenTrainModelVariant");
        qwenTrainElements.modelIdPreview = document.getElementById("qwenTrainModelIdPreview");
        qwenTrainElements.vramEstimate = document.getElementById("qwenTrainVramEstimate");
        qwenTrainElements.vramBreakdown = document.getElementById("qwenTrainVramBreakdown");
	        qwenTrainElements.systemPromptInput = document.getElementById("qwenTrainSystemPrompt");
        qwenTrainElements.batchSizeInput = document.getElementById("qwenTrainBatchSize");
        qwenTrainElements.epochsInput = document.getElementById("qwenTrainEpochs");
        qwenTrainElements.lrInput = document.getElementById("qwenTrainLR");
        qwenTrainElements.accumulateInput = document.getElementById("qwenTrainAccumulate");
        qwenTrainElements.loraRankInput = document.getElementById("qwenTrainLoraRank");
        qwenTrainElements.loraAlphaInput = document.getElementById("qwenTrainLoraAlpha");
	        qwenTrainElements.loraDropoutInput = document.getElementById("qwenTrainLoraDropout");
	        qwenTrainElements.loraTargetsInput = document.getElementById("qwenTrainLoraTargets");
	        qwenTrainElements.logStepsInput = document.getElementById("qwenTrainLogSteps");
	        qwenTrainElements.minPixelsInput = document.getElementById("qwenTrainMinPixels");
	        qwenTrainElements.maxPixelsInput = document.getElementById("qwenTrainMaxPixels");
	        qwenTrainElements.maxLengthInput = document.getElementById("qwenTrainMaxLength");
	        qwenTrainElements.datasetSelect = document.getElementById("qwenDatasetSelect");
	        qwenTrainElements.datasetRefresh = document.getElementById("qwenDatasetRefresh");
	        qwenTrainElements.datasetSummary = document.getElementById("qwenDatasetSummary");
	        qwenTrainElements.randomSplit = document.getElementById("qwenTrainRandomSplit");
        qwenTrainElements.valPercent = document.getElementById("qwenTrainValPercent");
        qwenTrainElements.splitSeed = document.getElementById("qwenTrainSplitSeed");
        qwenTrainElements.cacheInfo = document.getElementById("qwenCacheInfo");
        qwenTrainElements.cachePurge = document.getElementById("qwenCachePurge");
        qwenTrainElements.trainModeRadios = document.querySelectorAll('input[name="qwenTrainMode"]');
        qwenTrainElements.sampleButton = document.getElementById("qwenSampleBtn");
        qwenTrainElements.sampleCanvas = document.getElementById("qwenSampleCanvas");
        qwenTrainElements.samplePrompt = document.getElementById("qwenSamplePrompt");
        qwenTrainElements.sampleExpected = document.getElementById("qwenSampleExpected");
        qwenTrainElements.sampleMessage = document.getElementById("qwenSampleMessage");
        qwenTrainElements.sampleMeta = document.getElementById("qwenSampleMeta");
        qwenTrainElements.startButton = document.getElementById("qwenTrainStartBtn");
        qwenTrainElements.cancelButton = document.getElementById("qwenTrainCancelBtn");
        qwenTrainElements.progressFill = document.getElementById("qwenTrainProgressFill");
        qwenTrainElements.statusText = document.getElementById("qwenTrainStatusText");
        qwenTrainElements.epochDetail = document.getElementById("qwenTrainEpochDetail");
        qwenTrainElements.lossCanvas = document.getElementById("qwenTrainLossCanvas");
        qwenTrainElements.chartStatus = document.getElementById("qwenTrainChartStatus");
        qwenTrainElements.chartSmoothing = document.getElementById("qwenTrainChartSmoothing");
        qwenTrainElements.message = document.getElementById("qwenTrainMessage");
        qwenTrainElements.summary = document.getElementById("qwenTrainSummary");
        qwenTrainElements.log = document.getElementById("qwenTrainLog");
        qwenTrainElements.historyContainer = document.getElementById("qwenTrainHistory");
        if (qwenTrainElements.startButton) {
            qwenTrainElements.startButton.addEventListener("click", () => {
                handleStartQwenTraining().catch((error) => console.error("Qwen training start failed", error));
            });
        }
        if (qwenTrainElements.cancelButton) {
            qwenTrainElements.cancelButton.addEventListener("click", () => {
                cancelQwenTrainingJobRequest().catch((error) => console.error("Qwen cancel failed", error));
            });
            qwenTrainElements.cancelButton.disabled = true;
        }
        if (qwenTrainElements.sampleButton) {
            qwenTrainElements.sampleButton.addEventListener("click", () => {
                generateRandomQwenSample().catch((error) => console.error("Random Qwen sample failed", error));
            });
        }
        if (qwenTrainElements.modelSizeSelect) {
            qwenTrainElements.modelSizeSelect.addEventListener("change", updateQwenModelPreview);
        }
        if (qwenTrainElements.modelVariantSelect) {
            qwenTrainElements.modelVariantSelect.addEventListener("change", updateQwenModelPreview);
        }
        if (qwenTrainElements.trainModeRadios && qwenTrainElements.trainModeRadios.forEach) {
            qwenTrainElements.trainModeRadios.forEach((radio) => {
                radio.addEventListener("change", () => {
                    qwenTrainState.trainModeTouched = true;
                    updateQwenVramEstimate();
                });
            });
        }
        if (qwenTrainElements.batchSizeInput) {
            qwenTrainElements.batchSizeInput.addEventListener("input", updateQwenVramEstimate);
        }
        if (qwenTrainElements.maxPixelsInput) {
            qwenTrainElements.maxPixelsInput.addEventListener("input", updateQwenVramEstimate);
        }
        updateQwenModelPreview();
        refreshQwenGpuInfo().catch((error) => console.debug("Failed to refresh Qwen GPU info", error));
	        if (qwenTrainElements.datasetSelect) {
	            qwenTrainElements.datasetSelect.addEventListener("change", () => {
	                qwenDatasetState.selectedId = qwenTrainElements.datasetSelect.value || null;
	                updateQwenDatasetSummary();
            });
        }
        if (qwenTrainElements.randomSplit && qwenTrainElements.valPercent && qwenTrainElements.splitSeed) {
            const syncSplitInputs = () => {
                const enabled = !!qwenTrainElements.randomSplit.checked;
                qwenTrainElements.valPercent.disabled = !enabled;
                qwenTrainElements.splitSeed.disabled = !enabled;
            };
            qwenTrainElements.randomSplit.addEventListener("change", syncSplitInputs);
            syncSplitInputs();
        }
        if (qwenTrainElements.cachePurge) {
            qwenTrainElements.cachePurge.addEventListener("click", purgeQwenSplitCache);
        }
        refreshQwenSplitCache();
	        if (qwenTrainElements.datasetRefresh) {
	            qwenTrainElements.datasetRefresh.addEventListener("click", () => {
	                loadQwenDatasetList(true).catch((error) => console.error("Failed to refresh cached datasets", error));
	            });
	        }
	        if (qwenTrainElements.chartSmoothing) {
	            const initial = parseInt(qwenTrainElements.chartSmoothing.value, 10);
	            qwenTrainState.chartSmoothing = Number.isFinite(initial) && initial > 0 ? initial : 1;
            qwenTrainElements.chartSmoothing.addEventListener("change", () => {
                const nextValue = parseInt(qwenTrainElements.chartSmoothing.value, 10);
                qwenTrainState.chartSmoothing = Number.isFinite(nextValue) && nextValue > 0 ? nextValue : 1;
                updateQwenLossChart(qwenTrainState.lastJobSnapshot);
            });
        }
        loadQwenDatasetList().catch((error) => console.error("Failed to load cached datasets", error));
        setQwenDatasetModeState();
    }

    function renderYoloTrainingHistoryItem(container, job) {
        if (!container) {
            return;
        }
        const item = document.createElement("div");
        item.className = "training-history-item";
        const label = job?.config?.run_name || job?.config?.dataset?.label || job.job_id;
        const status = job.status || "unknown";
        const created = job.created_at ? new Date(job.created_at * 1000).toLocaleString() : "";
        const left = document.createElement("div");
        left.innerHTML = `<strong>${escapeHtml(label)}</strong><div class="training-help">${escapeHtml(status)} • ${escapeHtml(created)}</div>`;
        const right = document.createElement("div");
        const viewBtn = document.createElement("button");
        viewBtn.type = "button";
        viewBtn.className = "training-button";
        viewBtn.textContent = "View";
        viewBtn.addEventListener("click", () => {
            yoloTrainState.activeJobId = job.job_id;
            pollYoloTrainingJob(job.job_id, { force: true }).catch((error) => console.error("Poll YOLO job failed", error));
        });
        right.appendChild(viewBtn);
        item.append(left, right);
        container.appendChild(item);
    }

    async function refreshYoloTrainingHistory() {
        if (!yoloTrainElements.history) {
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/yolo/train/jobs`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const jobs = await resp.json();
            yoloTrainElements.history.innerHTML = "";
            if (!Array.isArray(jobs) || !jobs.length) {
                const empty = document.createElement("div");
                empty.className = "training-history-item";
                empty.textContent = "No YOLO jobs yet.";
                yoloTrainElements.history.appendChild(empty);
                return;
            }
            jobs.forEach((job) => renderYoloTrainingHistoryItem(yoloTrainElements.history, job));
        } catch (error) {
            console.error("Failed to load YOLO job history", error);
            yoloTrainElements.history.textContent = `Unable to load history: ${error.message || error}`;
        }
    }

    function scheduleYoloJobPoll(jobId, delayMs = 5000) {
        if (yoloTrainState.pollHandle) {
            clearTimeout(yoloTrainState.pollHandle);
        }
        yoloTrainState.pollHandle = window.setTimeout(() => {
            pollYoloTrainingJob(jobId, { force: true }).catch((error) => console.error("YOLO poll failed", error));
        }, delayMs);
    }

    async function pollYoloTrainingJob(jobId, { force = false } = {}) {
        if (!jobId) {
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/yolo/train/jobs/${jobId}`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const job = await resp.json();
            yoloTrainState.activeJobId = job.job_id;
            updateYoloTrainingUI(job);
            const terminalStates = new Set(["succeeded", "failed", "cancelled", "blocked"]);
            if (!terminalStates.has(job.status)) {
                scheduleYoloJobPoll(job.job_id);
            } else if (yoloTrainState.pollHandle) {
                clearTimeout(yoloTrainState.pollHandle);
                yoloTrainState.pollHandle = null;
            }
        } catch (error) {
            console.error("pollYoloTrainingJob error", error);
            setYoloTrainMessage(error.message || "Unable to load job", "error");
        }
    }

    function updateYoloTrainingUI(job) {
        if (!job) {
            return;
        }
        const previousStatus = yoloTrainState.lastJobSnapshot?.status;
        yoloTrainState.lastJobSnapshot = job;
        const pct = Math.round((job.progress || 0) * 100);
        if (yoloTrainElements.progressFill) {
            yoloTrainElements.progressFill.style.width = `${pct}%`;
        }
        if (yoloTrainElements.statusText) {
            const message = job.message ? ` • ${job.message}` : "";
            yoloTrainElements.statusText.textContent = `${job.status?.toUpperCase() || ""}${message}`;
        }
        if (yoloTrainElements.log) {
            const logs = Array.isArray(job.logs) ? job.logs : [];
            yoloTrainElements.log.textContent = logs
                .map((entry) => `[${formatTimestamp(entry.timestamp)}] ${entry.message}`)
                .join("\n");
        }
        if (yoloTrainElements.cancelButton) {
            const cancellable = job.status === "running" || job.status === "queued";
            yoloTrainElements.cancelButton.disabled = !cancellable;
        }
        updateYoloMetricChart(job.metrics);
        if (job.status && job.status !== previousStatus) {
            const terminalStates = new Set(["succeeded", "failed", "cancelled", "blocked"]);
            if (terminalStates.has(job.status)) {
                loadYoloRunList(true).catch((error) => console.error("Failed to refresh YOLO runs", error));
            }
        }
    }

    async function handleStartYoloTraining() {
        if (yoloTrainElements.startButton) {
            yoloTrainElements.startButton.disabled = true;
        }
        try {
            if (!yoloTrainElements.acceptTos?.checked) {
                setYoloTrainMessage("Please accept the Ultralytics terms to start training.", "warn");
                return;
            }
            const entry = getSelectedYoloDataset();
            if (!entry) {
                setYoloTrainMessage("Select a dataset first.", "error");
                return;
            }
            if (!entry.yolo_ready) {
                setYoloTrainMessage("Selected dataset needs YOLO conversion. Use Dataset Management to build YOLO labels.", "error");
                return;
            }
            const payload = buildYoloTrainingPayload();
            if (payload.error) {
                setYoloTrainMessage(payload.error, "error");
                return;
            }
            setYoloTrainMessage("Starting training job…");
            const resp = await fetch(`${API_ROOT}/yolo/train/jobs`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            const data = await resp.json();
            yoloTrainState.activeJobId = data.job_id;
            setYoloTrainMessage("Job started", "success");
            if (yoloTrainElements.cancelButton) {
                yoloTrainElements.cancelButton.disabled = false;
            }
            await pollYoloTrainingJob(data.job_id, { force: true });
            await refreshYoloTrainingHistory();
        } catch (error) {
            console.error("YOLO training submit failed", error);
            setYoloTrainMessage(error.message || "Failed to start training", "error");
        } finally {
            if (yoloTrainElements.startButton) {
                yoloTrainElements.startButton.disabled = false;
            }
        }
    }

    async function cancelYoloTrainingJobRequest() {
        if (!yoloTrainState.activeJobId) {
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/yolo/train/jobs/${yoloTrainState.activeJobId}/cancel`, { method: "POST" });
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            setYoloTrainMessage("Cancellation requested", "warn");
        } catch (error) {
            console.error("Cancel YOLO job failed", error);
            setYoloTrainMessage(error.message || "Failed to cancel job", "error");
        }
    }

    function initYoloTrainingTab() {
        if (yoloTrainElements.datasetSelect) {
            return;
        }
        yoloTrainElements.datasetSelect = document.getElementById("yoloDatasetSelect");
        yoloTrainElements.datasetRefresh = document.getElementById("yoloDatasetRefresh");
        yoloTrainElements.datasetSummary = document.getElementById("yoloDatasetSummary");
        yoloTrainElements.runNameInput = document.getElementById("yoloRunName");
        yoloTrainElements.taskSelect = document.getElementById("yoloTask");
        yoloTrainElements.headTypeSelect = document.getElementById("yoloHeadType");
        yoloTrainElements.scaleSelect = document.getElementById("yoloScale");
        yoloTrainElements.variantResolved = document.getElementById("yoloResolvedVariant");
        yoloTrainElements.variantHelp = document.getElementById("yoloVariantHelp");
        yoloTrainElements.fromScratchToggle = document.getElementById("yoloFromScratch");
        yoloTrainElements.baseWeightsInput = document.getElementById("yoloBaseWeights");
        yoloTrainElements.epochsInput = document.getElementById("yoloEpochs");
        yoloTrainElements.imgSizeInput = document.getElementById("yoloImgSize");
        yoloTrainElements.batchInput = document.getElementById("yoloBatch");
        yoloTrainElements.workersInput = document.getElementById("yoloWorkers");
        yoloTrainElements.devicesInput = document.getElementById("yoloDevices");
        yoloTrainElements.seedInput = document.getElementById("yoloSeed");
        yoloTrainElements.augFlipLR = document.getElementById("yoloAugFlipLR");
        yoloTrainElements.augFlipUD = document.getElementById("yoloAugFlipUD");
        yoloTrainElements.augHsvH = document.getElementById("yoloAugHsvH");
        yoloTrainElements.augHsvS = document.getElementById("yoloAugHsvS");
        yoloTrainElements.augHsvV = document.getElementById("yoloAugHsvV");
        yoloTrainElements.augMosaic = document.getElementById("yoloAugMosaic");
        yoloTrainElements.augMixup = document.getElementById("yoloAugMixup");
        yoloTrainElements.augCopyPaste = document.getElementById("yoloAugCopyPaste");
        yoloTrainElements.augScale = document.getElementById("yoloAugScale");
        yoloTrainElements.augTranslate = document.getElementById("yoloAugTranslate");
        yoloTrainElements.augDegrees = document.getElementById("yoloAugDegrees");
        yoloTrainElements.acceptTos = document.getElementById("yoloAcceptTos");
        yoloTrainElements.startButton = document.getElementById("yoloTrainStartBtn");
        yoloTrainElements.cancelButton = document.getElementById("yoloTrainCancelBtn");
        yoloTrainElements.refreshButton = document.getElementById("yoloTrainRefreshBtn");
        yoloTrainElements.progressFill = document.getElementById("yoloTrainProgressFill");
        yoloTrainElements.statusText = document.getElementById("yoloTrainStatusText");
        yoloTrainElements.message = document.getElementById("yoloTrainMessage");
        yoloTrainElements.metricCanvas = document.getElementById("yoloTrainMetricCanvas");
        yoloTrainElements.chartStatus = document.getElementById("yoloTrainChartStatus");
        yoloTrainElements.log = document.getElementById("yoloTrainLog");
        yoloTrainElements.history = document.getElementById("yoloTrainHistory");
        yoloTrainElements.runSelect = document.getElementById("yoloRunSelect");
        yoloTrainElements.runRefresh = document.getElementById("yoloRunsRefresh");
        yoloTrainElements.runActivate = document.getElementById("yoloRunActivate");
        yoloTrainElements.runDownload = document.getElementById("yoloRunDownload");
        yoloTrainElements.runDelete = document.getElementById("yoloRunDelete");
        yoloTrainElements.runSummary = document.getElementById("yoloRunSummary");
        if (yoloTrainElements.startButton) {
            yoloTrainElements.startButton.addEventListener("click", () => {
                handleStartYoloTraining().catch((error) => console.error("YOLO training start failed", error));
            });
        }
        if (yoloTrainElements.cancelButton) {
            yoloTrainElements.cancelButton.addEventListener("click", () => {
                cancelYoloTrainingJobRequest().catch((error) => console.error("YOLO cancel failed", error));
            });
            yoloTrainElements.cancelButton.disabled = true;
        }
        if (yoloTrainElements.refreshButton) {
            yoloTrainElements.refreshButton.addEventListener("click", () => {
                if (yoloTrainState.activeJobId) {
                    pollYoloTrainingJob(yoloTrainState.activeJobId, { force: true }).catch((error) => console.error("YOLO refresh failed", error));
                } else {
                    refreshYoloTrainingHistory();
                }
            });
        }
        if (yoloTrainElements.runSelect) {
            yoloTrainElements.runSelect.addEventListener("change", () => {
                yoloRunState.selectedId = yoloTrainElements.runSelect.value || null;
                updateYoloRunSummary();
            });
        }
        if (yoloTrainElements.runRefresh) {
            yoloTrainElements.runRefresh.addEventListener("click", () => {
                loadYoloRunList(true).catch((error) => console.error("Failed to refresh YOLO runs", error));
            });
        }
        if (yoloTrainElements.runActivate) {
            yoloTrainElements.runActivate.addEventListener("click", () => {
                setActiveYoloRun().catch((error) => console.error("Failed to activate YOLO run", error));
            });
        }
        if (yoloTrainElements.runDownload) {
            yoloTrainElements.runDownload.addEventListener("click", () => {
                downloadYoloRun().catch((error) => console.error("Failed to download YOLO run", error));
            });
        }
        if (yoloTrainElements.runDelete) {
            yoloTrainElements.runDelete.addEventListener("click", () => {
                deleteYoloRun().catch((error) => console.error("Failed to delete YOLO run", error));
            });
        }
        if (yoloTrainElements.datasetSelect) {
            yoloTrainElements.datasetSelect.addEventListener("change", () => {
                yoloDatasetState.selectedId = yoloTrainElements.datasetSelect.value || null;
                updateYoloDatasetSummary();
            });
        }
        if (yoloTrainElements.datasetRefresh) {
            yoloTrainElements.datasetRefresh.addEventListener("click", () => {
                loadYoloDatasetList(true).catch((error) => console.error("Failed to refresh YOLO datasets", error));
            });
        }
        if (yoloTrainElements.taskSelect) {
            yoloTrainElements.taskSelect.addEventListener("change", () => {
                updateYoloVariantSummary();
            });
        }
        if (yoloTrainElements.headTypeSelect) {
            yoloTrainElements.headTypeSelect.addEventListener("change", () => {
                yoloTrainState.lastHeadType = yoloTrainElements.headTypeSelect.value || yoloTrainState.lastHeadType;
                updateYoloVariantSummary();
            });
        }
        if (yoloTrainElements.scaleSelect) {
            yoloTrainElements.scaleSelect.addEventListener("change", () => {
                updateYoloVariantSummary();
            });
        }
        if (yoloTrainElements.fromScratchToggle) {
            yoloTrainElements.fromScratchToggle.addEventListener("change", () => {
                updateYoloVariantSummary();
            });
        }
        if (yoloTrainElements.baseWeightsInput) {
            yoloTrainElements.baseWeightsInput.addEventListener("input", () => {
                updateYoloVariantSummary();
            });
        }
        if (yoloTrainElements.acceptTos) {
            const stored = window.localStorage.getItem(YOLO_TOS_STORAGE_KEY);
            if (stored === "true") {
                yoloTrainElements.acceptTos.checked = true;
            }
            yoloTrainElements.acceptTos.addEventListener("change", () => {
                window.localStorage.setItem(YOLO_TOS_STORAGE_KEY, yoloTrainElements.acceptTos.checked ? "true" : "false");
            });
        }
        loadYoloDatasetList().catch((error) => console.error("Failed to load YOLO datasets", error));
        loadYoloRunList().catch((error) => console.error("Failed to load YOLO runs", error));
        updateYoloDatasetSummary();
        updateYoloVariantSummary();
    }

    function renderRfDetrTrainingHistoryItem(container, job) {
        if (!container) {
            return;
        }
        const item = document.createElement("div");
        item.className = "training-history-item";
        const label = job?.config?.run_name || job?.config?.dataset?.label || job.job_id;
        const status = job.status || "unknown";
        const created = job.created_at ? new Date(job.created_at * 1000).toLocaleString() : "";
        const left = document.createElement("div");
        left.innerHTML = `<strong>${escapeHtml(label)}</strong><div class="training-help">${escapeHtml(status)} • ${escapeHtml(created)}</div>`;
        const right = document.createElement("div");
        const viewBtn = document.createElement("button");
        viewBtn.type = "button";
        viewBtn.className = "training-button";
        viewBtn.textContent = "View";
        viewBtn.addEventListener("click", () => {
            rfdetrTrainState.activeJobId = job.job_id;
            pollRfDetrTrainingJob(job.job_id, { force: true }).catch((error) => console.error("Poll RF-DETR job failed", error));
        });
        right.appendChild(viewBtn);
        item.append(left, right);
        container.appendChild(item);
    }

    async function refreshRfDetrTrainingHistory() {
        if (!rfdetrTrainElements.history) {
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/rfdetr/train/jobs`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const jobs = await resp.json();
            rfdetrTrainElements.history.innerHTML = "";
            if (!Array.isArray(jobs) || !jobs.length) {
                const empty = document.createElement("div");
                empty.className = "training-history-item";
                empty.textContent = "No RF-DETR jobs yet.";
                rfdetrTrainElements.history.appendChild(empty);
                return;
            }
            jobs.forEach((job) => renderRfDetrTrainingHistoryItem(rfdetrTrainElements.history, job));
        } catch (error) {
            console.error("Failed to load RF-DETR job history", error);
            rfdetrTrainElements.history.textContent = `Unable to load history: ${error.message || error}`;
        }
    }

    function scheduleRfDetrJobPoll(jobId, delayMs = 5000) {
        if (rfdetrTrainState.pollHandle) {
            clearTimeout(rfdetrTrainState.pollHandle);
        }
        rfdetrTrainState.pollHandle = window.setTimeout(() => {
            pollRfDetrTrainingJob(jobId, { force: true }).catch((error) => console.error("RF-DETR poll failed", error));
        }, delayMs);
    }

    async function pollRfDetrTrainingJob(jobId, { force = false } = {}) {
        if (!jobId) {
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/rfdetr/train/jobs/${jobId}`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const job = await resp.json();
            rfdetrTrainState.activeJobId = job.job_id;
            updateRfDetrTrainingUI(job);
            const terminalStates = new Set(["succeeded", "failed", "cancelled"]);
            if (!terminalStates.has(job.status)) {
                scheduleRfDetrJobPoll(job.job_id);
            } else if (rfdetrTrainState.pollHandle) {
                clearTimeout(rfdetrTrainState.pollHandle);
                rfdetrTrainState.pollHandle = null;
            }
        } catch (error) {
            console.error("pollRfDetrTrainingJob error", error);
            setRfDetrTrainMessage(error.message || "Unable to load job", "error");
        }
    }

    function updateRfDetrTrainingUI(job) {
        if (!job) {
            return;
        }
        const previousStatus = rfdetrTrainState.lastJobSnapshot?.status;
        rfdetrTrainState.lastJobSnapshot = job;
        const pct = Math.round((job.progress || 0) * 100);
        if (rfdetrTrainElements.progressFill) {
            rfdetrTrainElements.progressFill.style.width = `${pct}%`;
        }
        if (rfdetrTrainElements.statusText) {
            const message = job.message ? ` • ${job.message}` : "";
            rfdetrTrainElements.statusText.textContent = `${job.status?.toUpperCase() || ""}${message}`;
        }
        if (rfdetrTrainElements.log) {
            const logs = Array.isArray(job.logs) ? job.logs : [];
            rfdetrTrainElements.log.textContent = logs
                .map((entry) => `[${formatTimestamp(entry.timestamp)}] ${entry.message}`)
                .join("\n");
        }
        if (rfdetrTrainElements.cancelButton) {
            const cancellable = job.status === "running" || job.status === "queued";
            rfdetrTrainElements.cancelButton.disabled = !cancellable;
        }
        updateRfDetrMetricChart(job.metrics);
        if (job.status && job.status !== previousStatus) {
            const terminalStates = new Set(["succeeded", "failed", "cancelled"]);
            if (terminalStates.has(job.status)) {
                loadRfDetrRunList(true).catch((error) => console.error("Failed to refresh RF-DETR runs", error));
            }
        }
    }

    async function handleStartRfDetrTraining() {
        if (rfdetrTrainElements.startButton) {
            rfdetrTrainElements.startButton.disabled = true;
        }
        try {
            if (!rfdetrTrainElements.acceptTos?.checked) {
                setRfDetrTrainMessage("Please accept the RF-DETR terms to start training.", "warn");
                return;
            }
            const entry = getSelectedRfDetrDataset();
            if (!entry) {
                setRfDetrTrainMessage("Select a dataset first.", "error");
                return;
            }
            if (rfdetrTrainElements.taskSelect?.value === "segment" && (entry.type || "bbox") !== "seg") {
                setRfDetrTrainMessage("Segmentation requires polygon datasets. Convert to YOLO-seg first.", "error");
                return;
            }
            const payload = buildRfDetrTrainingPayload();
            if (payload.error) {
                setRfDetrTrainMessage(payload.error, "error");
                return;
            }
            setRfDetrTrainMessage("Starting training job…");
            const resp = await fetch(`${API_ROOT}/rfdetr/train/jobs`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            const data = await resp.json();
            rfdetrTrainState.activeJobId = data.job_id;
            setRfDetrTrainMessage("Job started", "success");
            if (rfdetrTrainElements.cancelButton) {
                rfdetrTrainElements.cancelButton.disabled = false;
            }
            await pollRfDetrTrainingJob(data.job_id, { force: true });
            await refreshRfDetrTrainingHistory();
        } catch (error) {
            console.error("RF-DETR training submit failed", error);
            setRfDetrTrainMessage(error.message || "Failed to start training", "error");
        } finally {
            if (rfdetrTrainElements.startButton) {
                rfdetrTrainElements.startButton.disabled = false;
            }
        }
    }

    async function cancelRfDetrTrainingJobRequest() {
        if (!rfdetrTrainState.activeJobId) {
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/rfdetr/train/jobs/${rfdetrTrainState.activeJobId}/cancel`, { method: "POST" });
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            setRfDetrTrainMessage("Cancellation requested", "warn");
        } catch (error) {
            console.error("Cancel RF-DETR job failed", error);
            setRfDetrTrainMessage(error.message || "Failed to cancel job", "error");
        }
    }

    function initRfDetrTrainingTab() {
        if (rfdetrTrainElements.datasetSelect) {
            return;
        }
        rfdetrTrainElements.datasetSelect = document.getElementById("rfdetrDatasetSelect");
        rfdetrTrainElements.datasetRefresh = document.getElementById("rfdetrDatasetRefresh");
        rfdetrTrainElements.datasetSummary = document.getElementById("rfdetrDatasetSummary");
        rfdetrTrainElements.runNameInput = document.getElementById("rfdetrRunName");
        rfdetrTrainElements.taskSelect = document.getElementById("rfdetrTask");
        rfdetrTrainElements.variantSelect = document.getElementById("rfdetrVariant");
        rfdetrTrainElements.variantHelp = document.getElementById("rfdetrVariantHelp");
        rfdetrTrainElements.resolutionInput = document.getElementById("rfdetrResolution");
        rfdetrTrainElements.multiScaleToggle = document.getElementById("rfdetrMultiScale");
        rfdetrTrainElements.expandedScalesToggle = document.getElementById("rfdetrExpandedScales");
        rfdetrTrainElements.fromScratchToggle = document.getElementById("rfdetrFromScratch");
        rfdetrTrainElements.pretrainInput = document.getElementById("rfdetrPretrainWeights");
        rfdetrTrainElements.useEmaToggle = document.getElementById("rfdetrUseEma");
        rfdetrTrainElements.earlyStopToggle = document.getElementById("rfdetrEarlyStop");
        rfdetrTrainElements.earlyStopPatienceInput = document.getElementById("rfdetrEarlyStopPatience");
        rfdetrTrainElements.epochsInput = document.getElementById("rfdetrEpochs");
        rfdetrTrainElements.batchInput = document.getElementById("rfdetrBatch");
        rfdetrTrainElements.gradAccumInput = document.getElementById("rfdetrGradAccum");
        rfdetrTrainElements.workersInput = document.getElementById("rfdetrWorkers");
        rfdetrTrainElements.devicesInput = document.getElementById("rfdetrDevices");
        rfdetrTrainElements.seedInput = document.getElementById("rfdetrSeed");
        rfdetrTrainElements.augHsvH = document.getElementById("rfdetrAugHsvH");
        rfdetrTrainElements.augHsvS = document.getElementById("rfdetrAugHsvS");
        rfdetrTrainElements.augHsvV = document.getElementById("rfdetrAugHsvV");
        rfdetrTrainElements.augBlurProb = document.getElementById("rfdetrAugBlurProb");
        rfdetrTrainElements.augBlurKernel = document.getElementById("rfdetrAugBlurKernel");
        rfdetrTrainElements.augGrayProb = document.getElementById("rfdetrAugGrayProb");
        rfdetrTrainElements.acceptTos = document.getElementById("rfdetrAcceptTos");
        rfdetrTrainElements.startButton = document.getElementById("rfdetrTrainStartBtn");
        rfdetrTrainElements.cancelButton = document.getElementById("rfdetrTrainCancelBtn");
        rfdetrTrainElements.refreshButton = document.getElementById("rfdetrTrainRefreshBtn");
        rfdetrTrainElements.progressFill = document.getElementById("rfdetrTrainProgressFill");
        rfdetrTrainElements.statusText = document.getElementById("rfdetrTrainStatusText");
        rfdetrTrainElements.message = document.getElementById("rfdetrTrainMessage");
        rfdetrTrainElements.metricCanvas = document.getElementById("rfdetrTrainMetricCanvas");
        rfdetrTrainElements.chartStatus = document.getElementById("rfdetrTrainChartStatus");
        rfdetrTrainElements.log = document.getElementById("rfdetrTrainLog");
        rfdetrTrainElements.history = document.getElementById("rfdetrTrainHistory");
        rfdetrTrainElements.runSelect = document.getElementById("rfdetrRunSelect");
        rfdetrTrainElements.runRefresh = document.getElementById("rfdetrRunsRefresh");
        rfdetrTrainElements.runActivate = document.getElementById("rfdetrRunActivate");
        rfdetrTrainElements.runDownload = document.getElementById("rfdetrRunDownload");
        rfdetrTrainElements.runDelete = document.getElementById("rfdetrRunDelete");
        rfdetrTrainElements.runSummary = document.getElementById("rfdetrRunSummary");
        if (rfdetrTrainElements.multiScaleToggle) {
            rfdetrTrainElements.multiScaleToggle.addEventListener("change", updateRfDetrScaleToggles);
        }
        updateRfDetrScaleToggles();
        if (rfdetrTrainElements.startButton) {
            rfdetrTrainElements.startButton.addEventListener("click", () => {
                handleStartRfDetrTraining().catch((error) => console.error("RF-DETR training start failed", error));
            });
        }
        if (rfdetrTrainElements.cancelButton) {
            rfdetrTrainElements.cancelButton.addEventListener("click", () => {
                cancelRfDetrTrainingJobRequest().catch((error) => console.error("RF-DETR cancel failed", error));
            });
            rfdetrTrainElements.cancelButton.disabled = true;
        }
        if (rfdetrTrainElements.refreshButton) {
            rfdetrTrainElements.refreshButton.addEventListener("click", () => {
                if (rfdetrTrainState.activeJobId) {
                    pollRfDetrTrainingJob(rfdetrTrainState.activeJobId, { force: true }).catch((error) => console.error("RF-DETR refresh failed", error));
                } else {
                    refreshRfDetrTrainingHistory();
                }
            });
        }
        if (rfdetrTrainElements.runSelect) {
            rfdetrTrainElements.runSelect.addEventListener("change", () => {
                rfdetrRunState.selectedId = rfdetrTrainElements.runSelect.value || null;
                updateRfDetrRunSummary();
            });
        }
        if (rfdetrTrainElements.runRefresh) {
            rfdetrTrainElements.runRefresh.addEventListener("click", () => {
                loadRfDetrRunList(true).catch((error) => console.error("Failed to refresh RF-DETR runs", error));
            });
        }
        if (rfdetrTrainElements.runActivate) {
            rfdetrTrainElements.runActivate.addEventListener("click", () => {
                setActiveRfDetrRun().catch((error) => console.error("Failed to activate RF-DETR run", error));
            });
        }
        if (rfdetrTrainElements.runDownload) {
            rfdetrTrainElements.runDownload.addEventListener("click", () => {
                downloadRfDetrRun().catch((error) => console.error("Failed to download RF-DETR run", error));
            });
        }
        if (rfdetrTrainElements.runDelete) {
            rfdetrTrainElements.runDelete.addEventListener("click", () => {
                deleteRfDetrRun().catch((error) => console.error("Failed to delete RF-DETR run", error));
            });
        }
        if (rfdetrTrainElements.datasetSelect) {
            rfdetrTrainElements.datasetSelect.addEventListener("change", () => {
                rfdetrDatasetState.selectedId = rfdetrTrainElements.datasetSelect.value || null;
                updateRfDetrDatasetSummary();
            });
        }
        if (rfdetrTrainElements.datasetRefresh) {
            rfdetrTrainElements.datasetRefresh.addEventListener("click", () => {
                loadRfDetrDatasetList(true).catch((error) => console.error("Failed to refresh RF-DETR datasets", error));
            });
        }
        if (rfdetrTrainElements.taskSelect) {
            rfdetrTrainElements.taskSelect.addEventListener("change", () => {
                populateRfDetrVariantSelect();
            });
        }
        if (rfdetrTrainElements.fromScratchToggle && rfdetrTrainElements.pretrainInput) {
            const syncPretrain = () => {
                const disabled = !!rfdetrTrainElements.fromScratchToggle.checked;
                rfdetrTrainElements.pretrainInput.disabled = disabled;
                if (disabled) {
                    rfdetrTrainElements.pretrainInput.value = "";
                }
            };
            rfdetrTrainElements.fromScratchToggle.addEventListener("change", syncPretrain);
            syncPretrain();
        }
        if (rfdetrTrainElements.acceptTos) {
            const stored = window.localStorage.getItem(RFDETR_TOS_STORAGE_KEY);
            if (stored === "true") {
                rfdetrTrainElements.acceptTos.checked = true;
            }
            rfdetrTrainElements.acceptTos.addEventListener("change", () => {
                window.localStorage.setItem(RFDETR_TOS_STORAGE_KEY, rfdetrTrainElements.acceptTos.checked ? "true" : "false");
            });
        }
        if (rfdetrTrainElements.earlyStopToggle && rfdetrTrainElements.earlyStopPatienceInput) {
            const syncEarlyStop = () => {
                const enabled = !!rfdetrTrainElements.earlyStopToggle.checked;
                rfdetrTrainElements.earlyStopPatienceInput.disabled = !enabled;
            };
            rfdetrTrainElements.earlyStopToggle.addEventListener("change", syncEarlyStop);
            syncEarlyStop();
        }
        loadRfDetrVariants().catch((error) => console.error("Failed to load RF-DETR variants", error));
        loadRfDetrDatasetList().catch((error) => console.error("Failed to load RF-DETR datasets", error));
        loadRfDetrRunList().catch((error) => console.error("Failed to load RF-DETR runs", error));
        updateRfDetrDatasetSummary();
    }


    async function handleClassifierUploadChange(event) {
        const input = event.target;
        const file = input.files && input.files[0];
        input.value = "";
        if (!file) {
            return;
        }
        if (activeElements.classifierPath) {
            activeElements.classifierPath.value = file.name;
        }
        const formData = new FormData();
        formData.append('file', file);
        try {
            const resp = await fetch(`${API_ROOT}/fs/upload_classifier`, {
                method: 'POST',
                body: formData,
            });
            if (!resp.ok) {
                const textBody = await resp.text();
                throw new Error(textBody || `HTTP ${resp.status}`);
            }
            const data = await resp.json();
            const savedPath = data && data.path ? data.path : null;
            if (savedPath && activeElements.classifierPath) {
                activeElements.classifierPath.value = savedPath;
                setActiveMessage('Classifier uploaded and path updated.', 'success');
                loadActiveClipClassifiers(savedPath).catch((err) => console.warn("Active classifier list refresh failed", err));
                loadAgentClipClassifiers().catch((err) => console.warn("Agent CLIP classifier refresh failed", err));
            } else if (activeElements.classifierPath) {
                setActiveMessage('Classifier staged locally; enter the server path manually.', 'warn');
            }
        } catch (error) {
            console.error('Classifier upload failed', error);
            setActiveMessage(error.message || String(error), 'error');
        }
    }

    async function handleLabelmapUploadChange(event) {
        const input = event.target;
        const file = input.files && input.files[0];
        input.value = "";
        if (!file) {
            return;
        }
        if (activeElements.labelmapPath) {
            activeElements.labelmapPath.value = file.name;
        }
        const formData = new FormData();
        formData.append('file', file);
        try {
            const resp = await fetch(`${API_ROOT}/fs/upload_labelmap`, {
                method: 'POST',
                body: formData,
            });
            if (!resp.ok) {
                const textBody = await resp.text();
                throw new Error(textBody || `HTTP ${resp.status}`);
            }
            const data = await resp.json();
            const savedPath = data && data.path ? data.path : null;
            if (savedPath && activeElements.labelmapPath) {
                activeElements.labelmapPath.value = savedPath;
                setActiveMessage('Labelmap uploaded and path updated.', 'success');
                loadActiveLabelmaps(savedPath).catch((err) => console.warn("Active labelmap list refresh failed", err));
            } else if (activeElements.labelmapPath) {
                setActiveMessage('Labelmap staged locally; enter the server path manually.', 'warn');
            }
        } catch (error) {
            console.error('Labelmap upload failed', error);
            setActiveMessage(error.message || String(error), 'error');
        }
    }


    async function chooseOutputDirectory() {
        const fallback = window.prompt('Enter output directory path on the server', trainingState.outputDirPath || '.');
        if (fallback === null) {
            setTrainingMessage('Directory selection cancelled.', null);
            return;
        }
        const trimmed = fallback.trim() || '.';
        trainingState.outputDirPath = trimmed;
        if (trainingElements.outputDirSummary) {
            trainingElements.outputDirSummary.textContent = trimmed === '.' ? 'Server default (.)' : trimmed;
        }
        setTrainingMessage('Output directory updated.', 'success');
    }

    async function refreshTrainingHistory() {
        if (!trainingElements.historyContainer) {
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/clip/train`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const data = await resp.json();
            trainingElements.historyContainer.innerHTML = "";
            if (!Array.isArray(data) || !data.length) {
                const empty = document.createElement("div");
                empty.textContent = "No training jobs yet.";
                trainingElements.historyContainer.appendChild(empty);
                return;
            }
            data.forEach((job) => renderTrainingHistoryItem(trainingElements.historyContainer, job));
        } catch (error) {
            trainingElements.historyContainer.textContent = `Unable to load history: ${error.message || error}`;
        }
    }

    function renderTrainingStatus(status) {
        trainingState.jobs.set(status.job_id, status);
        const pct = Math.max(0, Math.min(100, Math.round((status.progress || 0) * 100)));
        if (trainingElements.progressFill) {
            trainingElements.progressFill.style.width = `${pct}%`;
        }
        if (trainingElements.cancelButton) {
            const cancellable = status.status === "running" || status.status === "queued";
            trainingElements.cancelButton.disabled = !cancellable;
        }
        if (trainingElements.statusText) {
            const message = status.message ? ` — ${status.message}` : "";
            trainingElements.statusText.textContent = `${status.status}${message}`;
        }
        if (trainingElements.log) {
            const logs = Array.isArray(status.logs) ? status.logs : [];
            const lines = logs.map((entry) => {
                const time = formatTimestamp(entry.timestamp);
                return time ? `[${time}] ${entry.message}` : entry.message;
            });
            trainingElements.log.textContent = lines.join("\n");
        }
        if (trainingElements.summary) {
            if (status.artifacts) {
                const art = status.artifacts;
                const accuracyPct = Number.isFinite(art.accuracy) ? `${(art.accuracy * 100).toFixed(1)}%` : "n/a";
                const iterationsInfo = Number.isFinite(art.iterations_run) ? art.iterations_run : "n/a";
                const convergedInfo = typeof art.converged === "boolean"
                    ? (art.converged ? "yes" : "no")
                    : "n/a";
                const bgCount = Number.isFinite(art.background_class_count)
                    ? art.background_class_count
                    : (Array.isArray(art.background_classes) ? art.background_classes.length : null);
                const augInfo = art.augmentation_policy ? "on (albumentations)" : "off";
                const classifierType = art.classifier_type ? String(art.classifier_type) : "logreg";
                const summaryLines = [
                    `Model: ${escapeHtml(art.model_path)}`,
                    `Labelmap: ${escapeHtml(art.labelmap_path)}`,
                    `Accuracy: ${accuracyPct}`,
                    `Train samples: ${art.samples_train}`,
                    `Test samples: ${art.samples_test}`,
                    `Classes seen: ${art.classes_seen}`,
                    ...(bgCount !== null ? [`Background classes: ${escapeHtml(String(bgCount))} (hidden negatives)`] : []),
                    `Augmentations: ${escapeHtml(augInfo)}`,
                    `Classifier head: ${escapeHtml(classifierType)}`,
                    `Class weight: ${escapeHtml(art.class_weight || 'none')}`,
                    ...(art.logit_adjustment_mode && String(art.logit_adjustment_mode).toLowerCase() !== "none"
                        ? [`Logit adjustment: ${escapeHtml(String(art.logit_adjustment_mode))}${art.logit_adjustment_inference ? " (infer on)" : ""}`]
                        : []),
                    `Solver: ${escapeHtml(art.solver || 'saga')}`,
                    `Iterations: ${escapeHtml(String(iterationsInfo))}`,
                    `Converged: ${escapeHtml(convergedInfo)}`,
                    `Hard mining: ${art.hard_example_mining ? 'yes' : 'no'}`,
                    `Hard W (misclass): ${escapeHtml(formatNumber(art.hard_mining_misclassified_weight, 2))}`,
                    `Hard W (low conf): ${escapeHtml(formatNumber(art.hard_mining_low_conf_weight, 2))}`,
                    `Low-conf threshold: ${escapeHtml(formatNumber(art.hard_mining_low_conf_threshold, 3))}`,
                    `Margin threshold: ${escapeHtml(formatNumber(art.hard_mining_margin_threshold, 3))}`,
                    `Convergence tol: ${escapeHtml(formatNumber(art.convergence_tol, 6))}`,
                ];
                if (classifierType === "mlp") {
                    const hidden = Array.isArray(art.mlp_hidden_sizes) ? art.mlp_hidden_sizes.join(",") : art.mlp_hidden_sizes;
                    summaryLines.push(`MLP hidden sizes: ${escapeHtml(String(hidden || "256"))}`);
                    summaryLines.push(`MLP dropout: ${escapeHtml(formatNumber(art.mlp_dropout, 3))}`);
                    summaryLines.push(`MLP epochs: ${escapeHtml(String(art.mlp_epochs ?? "n/a"))}`);
                    summaryLines.push(`MLP lr: ${escapeHtml(formatNumber(art.mlp_lr, 6))}`);
                    summaryLines.push(`MLP weight decay: ${escapeHtml(formatNumber(art.mlp_weight_decay, 6))}`);
                    summaryLines.push(`MLP label smoothing: ${escapeHtml(formatNumber(art.mlp_label_smoothing, 3))}`);
                    summaryLines.push(`MLP loss type: ${escapeHtml(art.mlp_loss_type || "ce")}`);
                    if (String(art.mlp_loss_type || "").toLowerCase() === "focal") {
                        summaryLines.push(`MLP focal gamma: ${escapeHtml(formatNumber(art.mlp_focal_gamma, 3))}`);
                        if (art.mlp_focal_alpha !== null && art.mlp_focal_alpha !== undefined) {
                            summaryLines.push(`MLP focal alpha: ${escapeHtml(formatNumber(art.mlp_focal_alpha, 3))}`);
                        }
                    }
                    summaryLines.push(`MLP sampler: ${escapeHtml(art.mlp_sampler || "balanced")}`);
                    summaryLines.push(`MLP mixup alpha: ${escapeHtml(formatNumber(art.mlp_mixup_alpha, 3))}`);
                    summaryLines.push(`MLP normalize emb: ${escapeHtml(art.mlp_normalize_embeddings ? "yes" : "no")}`);
                    summaryLines.push(`MLP patience: ${escapeHtml(String(art.mlp_patience ?? "n/a"))}`);
                }
                const summaryHtml = summaryLines.map((line) => `<div>${line}</div>`).join("");
                const perClassHtml = renderPerClassMetrics(art.per_class_metrics);
                const convergenceHtml = renderConvergenceTable(art.convergence_trace);
                trainingElements.summary.innerHTML = summaryHtml + perClassHtml + convergenceHtml;
                trainingState.latestArtifacts = art;
                updateClipTrainingChart(status.metrics && status.metrics.length ? status.metrics : art);
            } else if (status.status !== "succeeded") {
                trainingElements.summary.textContent = "";
                updateClipTrainingChart(status.metrics && status.metrics.length ? status.metrics : null);
            }
        }
        if (status.status === "succeeded" && status.artifacts) {
            setTrainingMessage("Training completed successfully.", "success");
            setActiveMessage("Training completed successfully. Activate it from the CLIP Model tab.", "success");
            stopTrainingPoll();
            if (trainingElements.cancelButton) {
                trainingElements.cancelButton.disabled = true;
            }
            if (trainingState.lastRefreshJobId !== status.job_id) {
                trainingState.lastRefreshJobId = status.job_id;
                loadAgentClipClassifiers().catch((err) => console.warn("Agent CLIP classifier refresh failed", err));
                loadActiveClipClassifiers().catch((err) => console.warn("Active classifier refresh failed", err));
                loadActiveLabelmaps().catch((err) => console.warn("Active labelmap refresh failed", err));
            }
        } else if (status.status === "failed") {
            const message = status.error || "Training failed.";
            setTrainingMessage(message, "error");
            setActiveMessage(message, "error");
            updateClipTrainingChart(status.metrics && status.metrics.length ? status.metrics : status.artifacts);
            stopTrainingPoll();
            if (trainingElements.cancelButton) {
                trainingElements.cancelButton.disabled = true;
            }
        } else if (status.status === "cancelled") {
            setTrainingMessage("Training cancelled.", "warn");
            setActiveMessage("Training cancelled.", "warn");
            updateClipTrainingChart(status.metrics && status.metrics.length ? status.metrics : status.artifacts);
            stopTrainingPoll();
            if (trainingElements.cancelButton) {
                trainingElements.cancelButton.disabled = true;
            }
        } else if (status.status === "cancelling") {
            setTrainingMessage("Cancellation in progress…", "warn");
            setActiveMessage("Cancellation in progress…", "warn");
            updateClipTrainingChart(status.metrics && status.metrics.length ? status.metrics : status.artifacts);
            trainingState.pollHandle = setTimeout(() => {
                pollTrainingJob(status.job_id).catch((err) => {
                    console.error("Training poll error", err);
                });
            }, 1500);
        } else if (status.status === "running" || status.status === "queued") {
            updateClipTrainingChart(status.metrics && status.metrics.length ? status.metrics : status.artifacts);
            trainingState.pollHandle = setTimeout(() => {
                pollTrainingJob(status.job_id).catch((err) => {
                    console.error("Training poll error", err);
                });
            }, 1500);
        }
    }

    async function pollTrainingJob(jobId) {
        if (trainingState.activeJobId !== jobId) {
            return;
        }
        trainingState.pollHandle = null;
        try {
            const resp = await fetch(`${API_ROOT}/clip/train/${jobId}`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const status = await resp.json();
            renderTrainingStatus(status);
        } catch (error) {
            console.warn("Polling training job failed", error);
            setTrainingMessage(`Error polling training job: ${error.message || error}`, "error");
            stopTrainingPoll();
        }
    }

    async function loadTrainingJob(jobId, { forcePoll = false } = {}) {
        trainingState.activeJobId = jobId;
        try {
            const resp = await fetch(`${API_ROOT}/clip/train/${jobId}`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const status = await resp.json();
            renderTrainingStatus(status);
            if (forcePoll || status.status === "running" || status.status === "queued") {
                startTrainingPoll(jobId, true);
            } else {
                stopTrainingPoll();
            }
        } catch (error) {
            setTrainingMessage(`Failed to load job ${jobId}: ${error.message || error}`, "error");
        }
    }

    const PACKAGING_REFERENCE_MBPS = 35;

    function computeDatasetStats(imageEntries, labelEntries) {
        const sumBytes = (entries) => entries.reduce((acc, entry) => acc + Math.max(0, entry.file?.size || 0), 0);
        const imageBytes = sumBytes(imageEntries);
        const labelBytes = sumBytes(labelEntries);
        const totalBytes = imageBytes + labelBytes;
        const totalFiles = imageEntries.length + labelEntries.length;
        const estimatedSeconds = totalBytes > 0
            ? totalBytes / (PACKAGING_REFERENCE_MBPS * 1024 * 1024)
            : null;
        return {
            imageCount: imageEntries.length,
            labelCount: labelEntries.length,
            totalFiles,
            imageBytes,
            labelBytes,
            totalBytes,
            estimatedSeconds,
        };
    }

    function replacePathLeaf(pathValue, replacement) {
        if (!pathValue) {
            return replacement;
        }
        const parts = pathValue.split(/[/\\]/);
        parts[parts.length - 1] = replacement;
        return parts.join("/");
    }

    function normaliseBaseName(entry) {
        if (!entry) {
            return null;
        }
        const source = entry.relativePath || entry.file?.name;
        if (!source) {
            return null;
        }
        const parts = source.split(/[/\\]/);
        return parts[parts.length - 1] || null;
    }

    function synthesiseLabelEntriesFromBboxes(imageEntries) {
        if (!Array.isArray(imageEntries) || !imageEntries.length) {
            return [];
        }
        const synthetic = [];
        imageEntries.forEach((entry) => {
            const baseName = normaliseBaseName(entry);
            if (!baseName) {
                return;
            }
            const bboxByClass = bboxes[baseName];
            const imageRecord = images[baseName];
            if (!bboxByClass || !imageRecord || !imageRecord.width || !imageRecord.height) {
                return;
            }
            const lines = [];
            Object.keys(bboxByClass).forEach((className) => {
                const classId = classes[className];
                if (classId === undefined || classId === null) {
                    return;
                }
                const records = bboxByClass[className] || [];
                records.forEach((bboxRecord) => {
                    const x = (bboxRecord.x + bboxRecord.width / 2) / imageRecord.width;
                    const y = (bboxRecord.y + bboxRecord.height / 2) / imageRecord.height;
                    const w = bboxRecord.width / imageRecord.width;
                    const h = bboxRecord.height / imageRecord.height;
                    lines.push(`${classId} ${x} ${y} ${w} ${h}`);
                });
            });
            if (!lines.length) {
                return;
            }
            const labelName = baseName.replace(/\.[^.]+$/, ".txt");
            const relativePath = entry.relativePath ? replacePathLeaf(entry.relativePath, labelName) : labelName;
            const blob = new Blob([lines.join("\n")], { type: "text/plain" });
            let syntheticFile;
            try {
                syntheticFile = new File([blob], labelName, { type: "text/plain" });
            } catch {
                syntheticFile = blob;
                syntheticFile.name = labelName;
            }
            synthetic.push({ file: syntheticFile, relativePath });
        });
        return synthetic;
    }

    function computeQwenDatasetStats(imageKeys) {
        let totalBytes = 0;
        imageKeys.forEach((key) => {
            const record = images[key];
            const file = record?.meta;
            if (file && typeof file.size === "number") {
                totalBytes += file.size;
            }
        });
        const estimatedSeconds = totalBytes > 0
            ? totalBytes / (PACKAGING_REFERENCE_MBPS * 1024 * 1024)
            : null;
        return {
            imageCount: imageKeys.length,
            labelCount: 0,
            totalFiles: imageKeys.length,
            imageBytes: totalBytes,
            labelBytes: 0,
            totalBytes,
            estimatedSeconds,
        };
    }

    function gatherTrainingFormData() {
        const usingNativeImages = Boolean(trainingState.nativeImagesPath);
        const usingNativeLabels = Boolean(trainingState.nativeLabelsPath);
        if (!usingNativeImages || !usingNativeLabels) {
            throw new Error("Select a cached dataset (or upload the current labeling dataset) before training.");
        }
        const formData = new FormData();
        formData.append("images_path_native", trainingState.nativeImagesPath);
        formData.append("labels_path_native", trainingState.nativeLabelsPath);
        if (trainingState.nativeLabelmapPath) {
            formData.append("labelmap_path_native", trainingState.nativeLabelmapPath);
        }
        const encoderType = getTrainingEncoderType();
        formData.append("encoder_type", encoderType);
        if (encoderType === "dinov3") {
            if (trainingElements.dinov3BackboneSelect) {
                formData.append("encoder_model", trainingElements.dinov3BackboneSelect.value);
            }
        } else if (trainingElements.clipBackboneSelect) {
            const clipModel = trainingElements.clipBackboneSelect.value;
            formData.append("clip_model_name", clipModel);
            formData.append("encoder_model", clipModel);
        }
        if (trainingElements.modelFilenameInput) {
            formData.append("model_filename", trainingElements.modelFilenameInput.value.trim() || "my_logreg_model.pkl");
        }
        if (trainingElements.labelmapFilenameInput) {
            formData.append("labelmap_filename", trainingElements.labelmapFilenameInput.value.trim() || "my_label_list.pkl");
        }
        if (trainingElements.testSizeInput) {
            formData.append("test_size", trainingElements.testSizeInput.value || "0.2");
        }
        if (trainingElements.randomSeedInput) {
            formData.append("random_seed", trainingElements.randomSeedInput.value || "42");
        }
        if (trainingElements.batchSizeInput) {
            formData.append("batch_size", trainingElements.batchSizeInput.value || "64");
        }
        if (trainingElements.maxIterInput) {
            formData.append("max_iter", trainingElements.maxIterInput.value || "1000");
        }
        if (trainingElements.minPerClassInput) {
            formData.append("min_per_class", trainingElements.minPerClassInput.value || "2");
        }
        if (trainingElements.regCInput) {
            formData.append("C", trainingElements.regCInput.value || "1.0");
        }
        if (trainingElements.classifierTypeSelect) {
            formData.append("classifier_type", trainingElements.classifierTypeSelect.value || "logreg");
        }
        if (trainingElements.mlpHiddenSizesInput) {
            formData.append("mlp_hidden_sizes", trainingElements.mlpHiddenSizesInput.value || "256");
        }
        if (trainingElements.mlpDropoutInput) {
            formData.append("mlp_dropout", trainingElements.mlpDropoutInput.value || "0.1");
        }
        if (trainingElements.mlpEpochsInput) {
            formData.append("mlp_epochs", trainingElements.mlpEpochsInput.value || "50");
        }
        if (trainingElements.mlpLrInput) {
            formData.append("mlp_lr", trainingElements.mlpLrInput.value || "0.001");
        }
        if (trainingElements.mlpWeightDecayInput) {
            formData.append("mlp_weight_decay", trainingElements.mlpWeightDecayInput.value || "0.0001");
        }
        if (trainingElements.mlpLabelSmoothingInput) {
            formData.append("mlp_label_smoothing", trainingElements.mlpLabelSmoothingInput.value || "0.05");
        }
        if (trainingElements.mlpLossTypeSelect) {
            formData.append("mlp_loss_type", trainingElements.mlpLossTypeSelect.value || "ce");
        }
        if (trainingElements.mlpActivationSelect) {
            formData.append("mlp_activation", trainingElements.mlpActivationSelect.value || "relu");
        }
        if (trainingElements.mlpLayerNormCheckbox) {
            formData.append(
                "mlp_layer_norm",
                trainingElements.mlpLayerNormCheckbox.checked ? "true" : "false",
            );
        }
        if (trainingElements.mlpFocalGammaInput) {
            formData.append("mlp_focal_gamma", trainingElements.mlpFocalGammaInput.value || "2.0");
        }
        if (trainingElements.mlpFocalAlphaInput) {
            formData.append("mlp_focal_alpha", trainingElements.mlpFocalAlphaInput.value || "-1.0");
        }
        if (trainingElements.mlpSamplerSelect) {
            formData.append("mlp_sampler", trainingElements.mlpSamplerSelect.value || "balanced");
        }
        if (trainingElements.mlpMixupAlphaInput) {
            formData.append("mlp_mixup_alpha", trainingElements.mlpMixupAlphaInput.value || "0.1");
        }
        if (trainingElements.mlpNormalizeEmbeddingsCheckbox) {
            formData.append(
                "mlp_normalize_embeddings",
                trainingElements.mlpNormalizeEmbeddingsCheckbox.checked ? "true" : "false",
            );
        }
        if (trainingElements.embeddingCenterCheckbox) {
            formData.append(
                "embedding_center",
                trainingElements.embeddingCenterCheckbox.checked ? "true" : "false",
            );
        }
        if (trainingElements.embeddingStandardizeCheckbox) {
            formData.append(
                "embedding_standardize",
                trainingElements.embeddingStandardizeCheckbox.checked ? "true" : "false",
            );
        }
        if (trainingElements.mlpPatienceInput) {
            formData.append("mlp_patience", trainingElements.mlpPatienceInput.value || "6");
        }
        if (trainingElements.mlpHardMiningEpochsInput) {
            formData.append("mlp_hard_mining_epochs", trainingElements.mlpHardMiningEpochsInput.value || "5");
        }
        if (trainingElements.classWeightSelect) {
            formData.append("class_weight", trainingElements.classWeightSelect.value || "none");
        }
        if (trainingElements.effectiveBetaInput) {
            formData.append("effective_beta", trainingElements.effectiveBetaInput.value || "0.9999");
        }
        if (trainingElements.logitAdjustmentToggle) {
            const enabled = trainingElements.logitAdjustmentToggle.checked;
            const classifierType = trainingElements.classifierTypeSelect
                ? String(trainingElements.classifierTypeSelect.value || "logreg").toLowerCase().trim()
                : "logreg";
            const mode = enabled ? (classifierType === "mlp" ? "both" : "infer") : "none";
            formData.append("logit_adjustment_mode", mode);
            formData.append("logit_adjustment_inference", enabled ? "true" : "false");
        }
        if (trainingElements.hardMisWeightInput) {
            formData.append("hard_mis_weight", trainingElements.hardMisWeightInput.value || "3.0");
        }
        if (trainingElements.hardLowConfWeightInput) {
            formData.append("hard_low_conf_weight", trainingElements.hardLowConfWeightInput.value || "2.0");
        }
        if (trainingElements.hardLowConfThresholdInput) {
            formData.append("hard_low_conf_threshold", trainingElements.hardLowConfThresholdInput.value || "0.65");
        }
        if (trainingElements.hardMarginThresholdInput) {
            formData.append("hard_margin_threshold", trainingElements.hardMarginThresholdInput.value || "0.15");
        }
        if (trainingElements.convergenceTolInput) {
            formData.append("convergence_tol", trainingElements.convergenceTolInput.value || "0.0001");
        }
        if (trainingElements.bgClassCountInput) {
            const bgValue = String(trainingElements.bgClassCountInput.value || "").trim();
            formData.append("bg_class_count", bgValue || "2");
        }
        if (trainingElements.deviceOverrideInput && trainingElements.deviceOverrideInput.value.trim()) {
            formData.append("device_override", trainingElements.deviceOverrideInput.value.trim());
        }
        if (trainingElements.calibrationModeSelect) {
            formData.append("calibration_mode", trainingElements.calibrationModeSelect.value || "none");
        }
        if (trainingElements.solverSelect) {
            formData.append("solver", trainingElements.solverSelect.value || "saga");
        }
        if (trainingElements.reuseEmbeddingsCheckbox && trainingElements.reuseEmbeddingsCheckbox.checked) {
            formData.append("reuse_embeddings", "true");
        }
        if (trainingElements.hardMiningCheckbox && trainingElements.hardMiningCheckbox.checked) {
            formData.append("hard_example_mining", "true");
        }
        return { formData };
    }

    async function stageClipDatasetUploads(imageEntries, labelEntries) {
        if (!Array.isArray(imageEntries) || !imageEntries.length) {
            throw new Error("No images available for upload.");
        }
        if (!Array.isArray(labelEntries) || !labelEntries.length) {
            throw new Error("No label files found for upload.");
        }

        const normalizeRelPath = (value) => {
            const raw = value || "";
            // Drop the leading folder component (common when picking a folder) so
            // images/labels align even if their top-level folder names differ.
            const parts = raw.split(/[/\\\\]+/).filter(Boolean);
            if (parts.length > 1) {
                return parts.slice(1).join("/");
            }
            return raw;
        };

        const initResp = await fetch(`${API_ROOT}/clip/dataset/init`, { method: "POST" });
        if (!initResp.ok) {
            const text = await initResp.text();
            throw new Error(text || "Failed to initialize dataset upload.");
        }
        const initData = await initResp.json();
        const jobId = initData?.job_id;
        if (!jobId) {
            throw new Error("Dataset upload job id missing.");
        }
        const totalItems = imageEntries.length + labelEntries.length;
        let completedItems = 0;

        const uploadEntry = async (entry, kind) => {
            const uploadForm = new FormData();
            uploadForm.append("job_id", jobId);
            uploadForm.append("kind", kind);
            const relPathRaw = entry.relativePath || entry.file?.name || `${kind}_${completedItems}`;
            const relPath = normalizeRelPath(relPathRaw);
            uploadForm.append("relative_path", relPath);
            uploadForm.append("file", entry.file, entry.file?.name || relPath);
            const resp = await fetch(`${API_ROOT}/clip/dataset/chunk`, {
                method: "POST",
                body: uploadForm,
            });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `Failed to upload ${kind}`);
            }
            completedItems += 1;
            if (totalItems > 0) {
                const percent = Math.min(100, Math.round((completedItems / totalItems) * 100));
                const stageLabel = kind === "image" ? "images" : "labels";
                updateTrainingPackagingProgress(percent, `Uploading ${stageLabel}… ${percent}%`);
            }
        };

        try {
            for (const entry of imageEntries) {
                await uploadEntry(entry, "image");
            }
            for (const entry of labelEntries) {
                await uploadEntry(entry, "label");
            }
            const finalizeForm = new FormData();
            finalizeForm.append("job_id", jobId);
            const finalizeResp = await fetch(`${API_ROOT}/clip/dataset/finalize`, {
                method: "POST",
                body: finalizeForm,
            });
            if (!finalizeResp.ok) {
                const detail = await finalizeResp.text();
                throw new Error(detail || "Failed to finalize dataset upload.");
            }
            return finalizeResp.json();
        } catch (error) {
            const cancelForm = new FormData();
            cancelForm.append("job_id", jobId);
            try {
                await fetch(`${API_ROOT}/clip/dataset/cancel`, { method: "POST", body: cancelForm });
            } catch (cancelError) {
                console.debug("Failed to cancel dataset upload job", cancelError);
            }
            throw error;
        }
    }

    async function handleStartTrainingClick() {
        if (!trainingElements.startButton) {
            return;
        }
        try {
            const { formData } = gatherTrainingFormData();
            trainingElements.startButton.disabled = true;
            const preppingMessage = "Submitting training job…";
            setTrainingMessage(preppingMessage, null);
            setActiveMessage(preppingMessage, null);
            if (trainingElements.summary) {
                trainingElements.summary.textContent = "";
            }
            if (trainingElements.log) {
                trainingElements.log.textContent = "";
            }
            updateClipTrainingChart(null);
            if (trainingElements.progressFill) {
                trainingElements.progressFill.style.width = "0%";
            }
            if (trainingElements.statusText) {
                trainingElements.statusText.textContent = "queued";
            }
            if (trainingElements.cancelButton) {
                trainingElements.cancelButton.disabled = true;
            }
            stopTrainingPoll();
            const resp = await fetch(`${API_ROOT}/clip/train`, {
                method: "POST",
                body: formData,
            });
            if (!resp.ok) {
                const text = await resp.text();
                throw new Error(text || `HTTP ${resp.status}`);
            }
            const data = await resp.json();
            const jobId = data.job_id;
            if (!jobId) {
                throw new Error("Training job id missing in response.");
            }
            trainingState.latestArtifacts = null;
            setTrainingMessage(`Training job ${jobId} started.`, "success");
            setActiveMessage(`Training job ${jobId} started.`, "success");
            startTrainingPoll(jobId, true);
            refreshTrainingHistory();
            if (trainingElements.cancelButton) {
                trainingElements.cancelButton.disabled = false;
            }
        } catch (error) {
            console.error("Failed to start training", error);
            const msg = error.message || String(error);
            setTrainingMessage(msg, "error");
            setActiveMessage(msg, "error");
        } finally {
            if (trainingElements.startButton) {
                trainingElements.startButton.disabled = false;
            }
        }
    }

    async function cancelActiveTrainingJob() {
        if (!trainingState.activeJobId) {
            setTrainingMessage("No active training job to cancel.", "warn");
            return;
        }
        if (trainingElements.cancelButton) {
            trainingElements.cancelButton.disabled = true;
        }
        try {
            setTrainingMessage("Requesting cancellation…", "warn");
            setActiveMessage("Requesting cancellation…", "warn");
            const resp = await fetch(`${API_ROOT}/clip/train/${trainingState.activeJobId}/cancel`, {
                method: "POST",
            });
            if (!resp.ok) {
                const text = await resp.text();
                throw new Error(text || `HTTP ${resp.status}`);
            }
        } catch (error) {
            console.error("Failed to cancel training", error);
            const msg = error.message || String(error);
            setTrainingMessage(msg, "error");
            setActiveMessage(msg, "error");
            if (trainingElements.cancelButton) {
                trainingElements.cancelButton.disabled = false;
            }
        }
    }

    async function handleActivateLatestModel() {
        const art = trainingState.latestArtifacts;
        if (!art) {
            setActiveMessage("No completed training artifacts available.", "error");
            return;
        }
        try {
            const encoderType = String(art.encoder_type || "clip").toLowerCase().trim();
            const payload = {
                classifier_path: art.model_path,
                labelmap_path: art.labelmap_path,
                clip_model: encoderType === "clip" ? (art.clip_model || (activeElements.clipSelect ? activeElements.clipSelect.value : null)) : null,
            };
            if (activeElements.clipSelect) {
                if (encoderType === "clip" && art.clip_model) {
                    activeElements.clipSelect.value = art.clip_model;
                    activeElements.clipSelect.disabled = false;
                } else if (encoderType !== "clip") {
                    activeElements.clipSelect.value = "";
                    activeElements.clipSelect.disabled = true;
                }
            }
            const resp = await fetch(`${API_ROOT}/clip/active_model`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) {
                const text = await resp.text();
                throw new Error(text || `HTTP ${resp.status}`);
            }
            setActiveMessage("Activated trained model for labeling.", "success");
            await refreshActiveModelPanel();
            await populateClipBackbones();
        } catch (error) {
            console.error("Failed to activate trained model", error);
            setActiveMessage(`Activation failed: ${error.message || error}`, "error");
        }
    }

    async function handleApplyActiveModel() {
        if (!activeElements.classifierPath || !activeElements.clipSelect) {
            return;
        }
        const selected = getSelectedActiveClassifier();
        const encoderType = selected ? String(selected.encoder_type || "clip").toLowerCase().trim() : "clip";
        let clipModel = activeElements.clipSelect.value || null;
        if (selected) {
            if (encoderType !== "clip") {
                clipModel = null;
            } else if (selected.clip_model) {
                clipModel = selected.clip_model;
            }
        }
        const payload = {
            classifier_path: activeElements.classifierPath.value.trim() || null,
            labelmap_path: activeElements.labelmapPath ? activeElements.labelmapPath.value.trim() || null : null,
            clip_model: clipModel,
        };
        if (!payload.classifier_path && !payload.clip_model) {
            setActiveMessage("Provide a classifier path or choose a backbone to apply.", "error");
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/clip/active_model`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) {
                const text = await resp.text();
                throw new Error(text || `HTTP ${resp.status}`);
            }
            setActiveMessage("Updated active model configuration.", "success");
            await refreshActiveModelPanel();
            await populateClipBackbones();
        } catch (error) {
            console.error("Failed to update active model", error);
            setActiveMessage(`Failed to update active model: ${error.message || error}`, "error");
        }
    }

    function setupTabNavigation() {
        tabElements.labelingButton = document.getElementById("tabLabelingButton");
        tabElements.trainingButton = document.getElementById("tabTrainingButton");
        tabElements.qwenTrainButton = document.getElementById("tabQwenTrainButton");
        tabElements.sam3TrainButton = document.getElementById("tabSam3TrainButton");
        tabElements.yoloTrainButton = document.getElementById("tabYoloTrainButton");
        tabElements.rfdetrTrainButton = document.getElementById("tabRfDetrTrainButton");
        tabElements.agentMiningButton = document.getElementById("tabAgentMiningButton");
        tabElements.promptHelperButton = document.getElementById("tabPromptHelperButton");
        tabElements.sam3PromptModelsButton = document.getElementById("tabSam3PromptModelsButton");
        tabElements.detectorsButton = document.getElementById("tabDetectorsButton");
        tabElements.datasetsButton = document.getElementById("tabDatasetsButton");
        tabElements.activeButton = document.getElementById("tabActiveButton");
        tabElements.qwenButton = document.getElementById("tabQwenButton");
        tabElements.predictorsButton = document.getElementById("tabPredictorsButton");
        tabElements.settingsButton = document.getElementById("tabSettingsButton");
        tabElements.labelingPanel = document.getElementById("tabLabeling");
        tabElements.trainingPanel = document.getElementById("tabTraining");
        tabElements.qwenTrainPanel = document.getElementById("tabQwenTrain");
        tabElements.sam3TrainPanel = document.getElementById("tabSam3Train");
        tabElements.yoloTrainPanel = document.getElementById("tabYoloTrain");
        tabElements.rfdetrTrainPanel = document.getElementById("tabRfDetrTrain");
        tabElements.agentMiningPanel = document.getElementById("tabAgentMining");
        tabElements.promptHelperPanel = document.getElementById("tabPromptHelper");
        tabElements.sam3PromptModelsPanel = document.getElementById("tabSam3PromptModels");
        tabElements.detectorsPanel = document.getElementById("tabDetectors");
        tabElements.datasetsPanel = document.getElementById("tabDatasets");
        tabElements.activePanel = document.getElementById("tabActive");
        tabElements.qwenPanel = document.getElementById("tabQwen");
        tabElements.predictorsPanel = document.getElementById("tabPredictors");
        tabElements.settingsPanel = document.getElementById("tabSettings");
        if (tabElements.labelingButton) {
            tabElements.labelingButton.addEventListener("click", () => setActiveTab(TAB_LABELING));
        }
        if (tabElements.trainingButton) {
            tabElements.trainingButton.addEventListener("click", () => setActiveTab(TAB_TRAINING));
        }
        if (tabElements.qwenTrainButton) {
            tabElements.qwenTrainButton.addEventListener("click", () => setActiveTab(TAB_QWEN_TRAIN));
        }
        if (tabElements.sam3TrainButton) {
            tabElements.sam3TrainButton.addEventListener("click", () => setActiveTab(TAB_SAM3_TRAIN));
        }
        if (tabElements.yoloTrainButton) {
            tabElements.yoloTrainButton.addEventListener("click", () => setActiveTab(TAB_YOLO_TRAIN));
        }
        if (tabElements.rfdetrTrainButton) {
            tabElements.rfdetrTrainButton.addEventListener("click", () => setActiveTab(TAB_RFDETR_TRAIN));
        }
        if (tabElements.agentMiningButton) {
            tabElements.agentMiningButton.addEventListener("click", () => setActiveTab(TAB_AGENT_MINING));
        }
        if (tabElements.promptHelperButton) {
            tabElements.promptHelperButton.addEventListener("click", () => setActiveTab(TAB_PROMPT_HELPER));
        }
        if (tabElements.sam3PromptModelsButton) {
            tabElements.sam3PromptModelsButton.addEventListener("click", () => setActiveTab(TAB_SAM3_PROMPT_MODELS));
        }
        if (tabElements.detectorsButton) {
            tabElements.detectorsButton.addEventListener("click", () => setActiveTab(TAB_DETECTORS));
        }
        if (tabElements.datasetsButton) {
            tabElements.datasetsButton.addEventListener("click", () => setActiveTab(TAB_DATASETS));
        }
        if (tabElements.activeButton) {
            tabElements.activeButton.addEventListener("click", () => setActiveTab(TAB_ACTIVE));
        }
        if (tabElements.qwenButton) {
            tabElements.qwenButton.addEventListener("click", () => setActiveTab(TAB_QWEN));
        }
        if (tabElements.predictorsButton) {
            tabElements.predictorsButton.addEventListener("click", () => setActiveTab(TAB_PREDICTORS));
        }
        if (tabElements.settingsButton) {
            tabElements.settingsButton.addEventListener("click", () => setActiveTab(TAB_SETTINGS));
        }
        setActiveTab(activeTab);
    }

    function setActiveTab(tabName) {
        const previous = activeTab;
        activeTab = tabName;
        if (tabElements.labelingButton) {
            tabElements.labelingButton.classList.toggle("active", tabName === TAB_LABELING);
        }
        if (tabElements.trainingButton) {
            tabElements.trainingButton.classList.toggle("active", tabName === TAB_TRAINING);
        }
        if (tabElements.qwenTrainButton) {
            tabElements.qwenTrainButton.classList.toggle("active", tabName === TAB_QWEN_TRAIN);
        }
        if (tabElements.sam3TrainButton) {
            tabElements.sam3TrainButton.classList.toggle("active", tabName === TAB_SAM3_TRAIN);
        }
        if (tabElements.yoloTrainButton) {
            tabElements.yoloTrainButton.classList.toggle("active", tabName === TAB_YOLO_TRAIN);
        }
        if (tabElements.rfdetrTrainButton) {
            tabElements.rfdetrTrainButton.classList.toggle("active", tabName === TAB_RFDETR_TRAIN);
        }
        if (tabElements.agentMiningButton) {
            tabElements.agentMiningButton.classList.toggle("active", tabName === TAB_AGENT_MINING);
        }
        if (tabElements.promptHelperButton) {
            tabElements.promptHelperButton.classList.toggle("active", tabName === TAB_PROMPT_HELPER);
        }
        if (tabElements.sam3PromptModelsButton) {
            tabElements.sam3PromptModelsButton.classList.toggle("active", tabName === TAB_SAM3_PROMPT_MODELS);
        }
        if (tabElements.detectorsButton) {
            tabElements.detectorsButton.classList.toggle("active", tabName === TAB_DETECTORS);
        }
        if (tabElements.datasetsButton) {
            tabElements.datasetsButton.classList.toggle("active", tabName === TAB_DATASETS);
        }
        if (tabElements.activeButton) {
            tabElements.activeButton.classList.toggle("active", tabName === TAB_ACTIVE);
        }
        if (tabElements.qwenButton) {
            tabElements.qwenButton.classList.toggle("active", tabName === TAB_QWEN);
        }
        if (tabElements.predictorsButton) {
            tabElements.predictorsButton.classList.toggle("active", tabName === TAB_PREDICTORS);
        }
        if (tabElements.settingsButton) {
            tabElements.settingsButton.classList.toggle("active", tabName === TAB_SETTINGS);
        }
        if (tabElements.labelingPanel) {
            tabElements.labelingPanel.classList.toggle("active", tabName === TAB_LABELING);
        }
        if (tabElements.trainingPanel) {
            tabElements.trainingPanel.classList.toggle("active", tabName === TAB_TRAINING);
        }
        if (tabElements.qwenTrainPanel) {
            tabElements.qwenTrainPanel.classList.toggle("active", tabName === TAB_QWEN_TRAIN);
        }
        if (tabElements.sam3TrainPanel) {
            tabElements.sam3TrainPanel.classList.toggle("active", tabName === TAB_SAM3_TRAIN);
        }
        if (tabElements.yoloTrainPanel) {
            tabElements.yoloTrainPanel.classList.toggle("active", tabName === TAB_YOLO_TRAIN);
        }
        if (tabElements.rfdetrTrainPanel) {
            tabElements.rfdetrTrainPanel.classList.toggle("active", tabName === TAB_RFDETR_TRAIN);
        }
        if (tabElements.agentMiningPanel) {
            tabElements.agentMiningPanel.classList.toggle("active", tabName === TAB_AGENT_MINING);
        }
        if (tabElements.promptHelperPanel) {
            tabElements.promptHelperPanel.classList.toggle("active", tabName === TAB_PROMPT_HELPER);
        }
        if (tabElements.sam3PromptModelsPanel) {
            tabElements.sam3PromptModelsPanel.classList.toggle("active", tabName === TAB_SAM3_PROMPT_MODELS);
        }
        if (tabElements.detectorsPanel) {
            tabElements.detectorsPanel.classList.toggle("active", tabName === TAB_DETECTORS);
        }
        if (tabElements.datasetsPanel) {
            tabElements.datasetsPanel.classList.toggle("active", tabName === TAB_DATASETS);
        }
        if (tabElements.activePanel) {
            tabElements.activePanel.classList.toggle("active", tabName === TAB_ACTIVE);
        }
        if (tabElements.qwenPanel) {
            tabElements.qwenPanel.classList.toggle("active", tabName === TAB_QWEN);
        }
        if (tabElements.predictorsPanel) {
            tabElements.predictorsPanel.classList.toggle("active", tabName === TAB_PREDICTORS);
        }
        if (tabElements.settingsPanel) {
            tabElements.settingsPanel.classList.toggle("active", tabName === TAB_SETTINGS);
        }
        if (tabName === TAB_TRAINING && previous !== TAB_TRAINING) {
            initializeTrainingUi();
            refreshTrainingHistory();
            populateClipBackbones();
            if (trainingState.activeJobId) {
                loadTrainingJob(trainingState.activeJobId, { forcePoll: true });
            }
        }
        if (tabName === TAB_DETECTORS && previous !== TAB_DETECTORS) {
            refreshDetectorStatus()
                .then(() => maybeAutoSelectDetectorRun())
                .catch((err) => console.warn("Detector status refresh failed", err));
        }
        if (tabName === TAB_QWEN_TRAIN && previous !== TAB_QWEN_TRAIN) {
            initQwenTrainingTab();
            refreshQwenTrainingHistory();
            if (qwenTrainState.activeJobId) {
                pollQwenTrainingJob(qwenTrainState.activeJobId, { force: true }).catch((error) => console.error("Qwen job poll failed", error));
            }
        }
        if (tabName === TAB_SAM3_TRAIN && previous !== TAB_SAM3_TRAIN) {
            initSam3TrainUi().catch((err) => console.error("SAM3 UI init failed", err));
        }
        if (tabName === TAB_YOLO_TRAIN && previous !== TAB_YOLO_TRAIN) {
            initYoloTrainingTab();
            refreshYoloTrainingHistory();
            if (yoloTrainState.activeJobId) {
                pollYoloTrainingJob(yoloTrainState.activeJobId, { force: true }).catch((error) => console.error("YOLO job poll failed", error));
            }
        }
        if (tabName === TAB_RFDETR_TRAIN && previous !== TAB_RFDETR_TRAIN) {
            initRfDetrTrainingTab();
            refreshRfDetrTrainingHistory();
            if (rfdetrTrainState.activeJobId) {
                pollRfDetrTrainingJob(rfdetrTrainState.activeJobId, { force: true }).catch((error) => console.error("RF-DETR job poll failed", error));
            }
        }
        if (tabName === TAB_AGENT_MINING && previous !== TAB_AGENT_MINING) {
            initAgentMiningUi();
        }
        if (tabName === TAB_PROMPT_HELPER && previous !== TAB_PROMPT_HELPER) {
            initPromptHelperUi().catch((err) => console.error("Prompt helper init failed", err));
        }
        if (tabName === TAB_SAM3_PROMPT_MODELS && previous !== TAB_SAM3_PROMPT_MODELS) {
            initSam3PromptModelsUi();
        }
        if (tabName === TAB_DATASETS && previous !== TAB_DATASETS) {
            initDatasetManagerTab().catch((err) => console.error("Dataset manager init failed", err));
        }
        if (tabName === TAB_ACTIVE && previous !== TAB_ACTIVE) {
            initializeActiveModelUi();
            populateClipBackbones();
            refreshActiveModelPanel();
        }
        if (tabName === TAB_QWEN && previous !== TAB_QWEN) {
            initQwenModelTab();
        }
        if (tabName === TAB_PREDICTORS && previous !== TAB_PREDICTORS) {
            initializePredictorTab();
            startPredictorRefresh(true);
        } else if (previous === TAB_PREDICTORS && tabName !== TAB_PREDICTORS) {
            stopPredictorRefresh();
        }
        if (tabName === TAB_SETTINGS && !settingsUiInitialized) {
            initializeSettingsUi();
        }
        if (tabName === TAB_LABELING) {
            ensureCanvasDimensions();
            if (currentImage && fittedZoom) {
                fitZoom(currentImage, { preservePan: true });
            }
        }
        if (tabName !== TAB_TRAINING && previous === TAB_TRAINING) {
            stopTrainingPoll();
        }
    }

    function initializeTrainingUi() {
        if (trainingUiInitialized) {
            return;
        }
        trainingUiInitialized = true;
        trainingElements.encoderTypeSelect = document.getElementById("trainEncoderType");
        trainingElements.clipBackboneSelect = document.getElementById("clipBackboneSelect");
        trainingElements.dinov3BackboneSelect = document.getElementById("dinov3BackboneSelect");
        trainingElements.clipBackboneRow = document.getElementById("clipBackboneRow");
        trainingElements.dinov3BackboneRow = document.getElementById("dinov3BackboneRow");
        trainingElements.solverSelect = document.getElementById("trainSolver");
        trainingElements.classifierTypeSelect = document.getElementById("trainClassifierType");
        trainingElements.datasetSelect = document.getElementById("trainDatasetSelect");
        trainingElements.datasetRefresh = document.getElementById("trainDatasetRefresh");
        trainingElements.datasetSummary = document.getElementById("trainDatasetSummary");
        trainingElements.imagesInput = document.getElementById("trainImages");
        trainingElements.imagesBtn = document.getElementById("trainImagesBtn");
        trainingElements.imagesSummary = document.getElementById("trainImagesSummary");
        trainingElements.labelsInput = document.getElementById("trainLabels");
        trainingElements.labelsBtn = document.getElementById("trainLabelsBtn");
        trainingElements.labelsSummary = document.getElementById("trainLabelsSummary");
        trainingElements.labelmapInput = document.getElementById("trainLabelmap");
        trainingElements.labelmapSummary = document.getElementById("trainLabelmapSummary");
        trainingElements.outputDirBtn = document.getElementById("trainOutputDirBtn");
        trainingElements.outputDirSummary = document.getElementById("trainOutputDirSummary");
        trainingElements.modelFilenameInput = document.getElementById("trainModelFilename");
        trainingElements.labelmapFilenameInput = document.getElementById("trainLabelmapFilename");
        trainingElements.testSizeInput = document.getElementById("trainTestSize");
        trainingElements.randomSeedInput = document.getElementById("trainRandomSeed");
        trainingElements.batchSizeInput = document.getElementById("trainBatchSize");
        trainingElements.maxIterInput = document.getElementById("trainMaxIter");
        trainingElements.minPerClassInput = document.getElementById("trainMinPerClass");
        trainingElements.regCInput = document.getElementById("trainRegC");
        trainingElements.mlpHiddenSizesInput = document.getElementById("trainMlpHiddenSizes");
        trainingElements.mlpHiddenSizesAutoBtn = document.getElementById("trainMlpHiddenSizesAuto");
        trainingElements.mlpDropoutInput = document.getElementById("trainMlpDropout");
        trainingElements.mlpEpochsInput = document.getElementById("trainMlpEpochs");
        trainingElements.mlpLrInput = document.getElementById("trainMlpLr");
        trainingElements.mlpWeightDecayInput = document.getElementById("trainMlpWeightDecay");
        trainingElements.mlpLabelSmoothingInput = document.getElementById("trainMlpLabelSmoothing");
        trainingElements.mlpLossTypeSelect = document.getElementById("trainMlpLossType");
        trainingElements.mlpActivationSelect = document.getElementById("trainMlpActivation");
        trainingElements.mlpFocalGammaInput = document.getElementById("trainMlpFocalGamma");
        trainingElements.mlpFocalAlphaInput = document.getElementById("trainMlpFocalAlpha");
        trainingElements.mlpSamplerSelect = document.getElementById("trainMlpSampler");
        trainingElements.mlpMixupAlphaInput = document.getElementById("trainMlpMixupAlpha");
        trainingElements.mlpNormalizeEmbeddingsCheckbox = document.getElementById("trainMlpNormalizeEmbeddings");
        trainingElements.mlpPatienceInput = document.getElementById("trainMlpPatience");
        trainingElements.mlpLayerNormCheckbox = document.getElementById("trainMlpLayerNorm");
        trainingElements.mlpHardMiningEpochsInput = document.getElementById("trainMlpHardMiningEpochs");
        trainingElements.classWeightSelect = document.getElementById("trainClassWeight");
        trainingElements.effectiveBetaInput = document.getElementById("trainEffectiveBeta");
        trainingElements.logitAdjustmentToggle = document.getElementById("trainLogitAdjustmentMode");
        trainingElements.deviceOverrideInput = document.getElementById("trainDeviceOverride");
        trainingElements.calibrationModeSelect = document.getElementById("trainCalibrationMode");
        trainingElements.embeddingCenterCheckbox = document.getElementById("trainEmbeddingCenter");
        trainingElements.embeddingStandardizeCheckbox = document.getElementById("trainEmbeddingStandardize");
        trainingElements.hardMisWeightInput = document.getElementById("trainHardMisWeight");
        trainingElements.hardLowConfWeightInput = document.getElementById("trainHardLowConfWeight");
        trainingElements.hardLowConfThresholdInput = document.getElementById("trainHardLowConfThreshold");
        trainingElements.hardMarginThresholdInput = document.getElementById("trainHardMarginThreshold");
        trainingElements.convergenceTolInput = document.getElementById("trainConvergenceTol");
        trainingElements.bgClassCountInput = document.getElementById("trainBgClassCount");
        trainingElements.startButton = document.getElementById("startTrainingBtn");
        trainingElements.cancelButton = document.getElementById("cancelTrainingBtn");
        trainingElements.progressFill = document.getElementById("trainingProgressFill");
        trainingElements.statusText = document.getElementById("trainingStatusText");
        trainingElements.message = document.getElementById("trainingMessage");
        trainingElements.summary = document.getElementById("trainingSummary");
        trainingElements.log = document.getElementById("trainingLog");
        trainingElements.metricCanvas = document.getElementById("trainingMetricCanvas");
        trainingElements.chartStatus = document.getElementById("trainingChartStatus");
        trainingElements.historyContainer = document.getElementById("trainingHistory");
        trainingElements.reuseEmbeddingsCheckbox = document.getElementById("trainReuseEmbeddings");
        trainingElements.hardMiningCheckbox = document.getElementById("trainHardMining");
        if (trainingElements.encoderTypeSelect) {
            trainingElements.encoderTypeSelect.addEventListener("change", () => {
                updateTrainingEncoderControls();
                applyRecommendedMlpHiddenSizes(false);
            });
        }
        if (trainingElements.classifierTypeSelect) {
            trainingElements.classifierTypeSelect.addEventListener("change", updateTrainingClassifierControls);
        }
        if (trainingElements.mlpLossTypeSelect) {
            trainingElements.mlpLossTypeSelect.addEventListener("change", updateTrainingClassifierControls);
        }
        if (trainingElements.classWeightSelect) {
            trainingElements.classWeightSelect.addEventListener("change", updateTrainingClassWeightControls);
        }
        if (trainingElements.hardMiningCheckbox) {
            trainingElements.hardMiningCheckbox.addEventListener("change", updateTrainingHardMiningControls);
        }
        if (trainingElements.embeddingStandardizeCheckbox) {
            trainingElements.embeddingStandardizeCheckbox.addEventListener("change", updateEmbeddingStandardizeControls);
        }
        if (trainingElements.embeddingCenterCheckbox) {
            trainingElements.embeddingCenterCheckbox.addEventListener("change", updateEmbeddingStandardizeControls);
        }
        if (trainingElements.clipBackboneSelect) {
            trainingElements.clipBackboneSelect.addEventListener("change", () => applyRecommendedMlpHiddenSizes(false));
        }
        if (trainingElements.dinov3BackboneSelect) {
            trainingElements.dinov3BackboneSelect.addEventListener("change", () => applyRecommendedMlpHiddenSizes(false));
        }
        if (trainingElements.mlpHiddenSizesInput) {
            trainingElements.mlpHiddenSizesInput.addEventListener("input", () => {
                const current = String(trainingElements.mlpHiddenSizesInput.value || "").trim();
                mlpHiddenSizesTouched = current.length > 0;
                if (current && current === mlpHiddenSizesAutoValue) {
                    mlpHiddenSizesTouched = false;
                }
            });
        }
        if (trainingElements.mlpHiddenSizesAutoBtn) {
            trainingElements.mlpHiddenSizesAutoBtn.addEventListener("click", () => applyRecommendedMlpHiddenSizes(true));
        }
        populateDinov3Backbones();
        updateTrainingClassifierControls();
        updateTrainingHardMiningControls();
        updateTrainingClassWeightControls();
        updateEmbeddingStandardizeControls();

        const applyDatasetSelection = (datasetId) => {
            const item = clipDatasetState.items.find((d) => d.id === datasetId);
            if (!item) {
                trainingState.nativeImagesPath = null;
                trainingState.nativeLabelsPath = null;
                trainingState.nativeLabelmapPath = null;
                trainingState.imagesFolderName = null;
                trainingState.labelsFolderName = null;
                if (trainingElements.datasetSummary) {
                    trainingElements.datasetSummary.textContent = "Pick a cached dataset or upload the current labeling dataset.";
                }
                return;
            }
            const root = item.dataset_root;
            trainingState.nativeImagesPath = item.yolo_images_dir || `${root}/train/images`;
            trainingState.nativeLabelsPath = item.yolo_labels_dir || `${root}/train/labels`;
            trainingState.nativeLabelmapPath = item.yolo_labelmap_path || `${root}/labelmap.txt`;
            trainingState.imagesFolderName = item.label || item.id;
            trainingState.labelsFolderName = item.label || item.id;
            trainingState.imageEntries = [];
            trainingState.labelEntries = [];
            trainingState.imageTotalCount = 0;
            trainingState.labelTotalCount = 0;
            if (trainingElements.datasetSummary) {
                trainingElements.datasetSummary.textContent = `Using dataset: ${item.label || item.id}`;
            }
            updateFileSummary(null, trainingElements.imagesSummary, { mode: "path", path: trainingState.nativeImagesPath, emptyText: "No folder selected" });
            updateFileSummary(null, trainingElements.labelsSummary, { mode: "path", path: trainingState.nativeLabelsPath, emptyText: "No folder selected" });
            if (trainingElements.labelmapSummary && trainingState.nativeLabelmapPath) {
                trainingElements.labelmapSummary.textContent = trainingState.nativeLabelmapPath;
                trainingElements.labelmapSummary.title = trainingState.nativeLabelmapPath;
            }
            if (trainingElements.imagesInput) trainingElements.imagesInput.value = "";
            if (trainingElements.labelsInput) trainingElements.labelsInput.value = "";
            if (trainingElements.labelmapInput) trainingElements.labelmapInput.value = "";
            setTrainingMessage(`Using cached dataset ${item.label || item.id}`, "success");
        };

        const refreshClipDatasets = async (selectedId) => {
            if (!trainingElements.datasetSelect) {
                return;
            }
            try {
                const resp = await fetch(`${API_ROOT}/datasets`);
                if (!resp.ok) {
                    throw new Error(`HTTP ${resp.status}`);
                }
                const data = await resp.json();
                clipDatasetState.items = Array.isArray(data)
                    ? data.filter((d) => {
                        const root = d.dataset_root;
                        if (!root) return false;
                        const typeVal = String(d.type || "bbox").toLowerCase();
                        const typeOk = typeVal === "bbox" || typeVal === "seg";
                        if (!typeOk) return false;
                        return Boolean(d.yolo_ready);
                    })
                    : [];
                trainingElements.datasetSelect.innerHTML = "";
                const emptyOpt = document.createElement("option");
                emptyOpt.value = "";
                emptyOpt.textContent = "Select a dataset…";
                trainingElements.datasetSelect.appendChild(emptyOpt);
                clipDatasetState.items.forEach((item) => {
                    const opt = document.createElement("option");
                    opt.value = item.id;
                    opt.textContent = item.label || item.id;
                    if (selectedId && selectedId === item.id) {
                        opt.selected = true;
                    }
                    trainingElements.datasetSelect.appendChild(opt);
                });
                if (selectedId) {
                    applyDatasetSelection(selectedId);
                }
            } catch (err) {
                console.error("Failed to refresh datasets", err);
                setTrainingMessage(`Unable to load cached datasets: ${err.message || err}`, "error");
            }
        };

        if (trainingElements.uploadCurrentDatasetBtn) {
            trainingElements.uploadCurrentDatasetBtn.addEventListener("click", async () => {
                try {
                    await initDatasetManagerTab();
                    const result = await uploadCurrentDatasetToCache();
                    const datasetId = result?.id || result?.dataset_id || result?.label || "";
                    await refreshClipDatasets(datasetId || trainingElements.datasetSelect?.value || "");
                } catch (err) {
                    setTrainingMessage(err.message || "Failed to upload current dataset.", "error");
                }
            });
        }
        if (trainingElements.openDatasetManagerBtn) {
            trainingElements.openDatasetManagerBtn.addEventListener("click", () => setActiveTab(TAB_DATASETS));
        }
        if (trainingElements.outputDirBtn) {
            trainingElements.outputDirBtn.addEventListener("click", () => {
                chooseOutputDirectory().catch((err) => console.error("Directory picker error", err));
            });
        }
        if (trainingElements.startButton) {
            trainingElements.startButton.addEventListener("click", () => {
                handleStartTrainingClick().catch((err) => {
                    console.error("Training submit error", err);
                });
            });
        }
        if (trainingElements.cancelButton) {
            trainingElements.cancelButton.addEventListener("click", () => {
                cancelActiveTrainingJob().catch((err) => {
                    console.error("Cancel training error", err);
                });
            });
        }
        if (trainingElements.datasetRefresh) {
            trainingElements.datasetRefresh.addEventListener("click", () => {
                refreshClipDatasets(trainingElements.datasetSelect?.value || null);
            });
        }
        if (trainingElements.datasetSelect) {
            trainingElements.datasetSelect.addEventListener("change", (event) => {
                applyDatasetSelection(event.target.value || "");
            });
        }

        if (trainingElements.outputDirSummary) {
            trainingElements.outputDirSummary.textContent = trainingState.outputDirPath && trainingState.outputDirPath !== '.' ? trainingState.outputDirPath : 'Server default (.)';
        }

        populateClipBackbones();
        refreshClipDatasets(null).catch((err) => console.warn("Dataset list init failed", err));
    }

    function initializeActiveModelUi() {
        if (activeUiInitialized) {
            return;
        }
        activeUiInitialized = true;
        activeElements.message = document.getElementById("activeMessage");
        activeElements.info = document.getElementById("activeModelInfo");
        activeElements.clipSelect = document.getElementById("activeClipSelect");
        activeElements.classifierPath = document.getElementById("activeClassifierPath");
        activeElements.classifierUpload = document.getElementById("activeClassifierUpload");
        activeElements.classifierBrowse = document.getElementById("activeClassifierBrowse");
        activeElements.classifierSelect = document.getElementById("activeClassifierSelect");
        activeElements.classifierRefresh = document.getElementById("activeClassifierRefresh");
        activeElements.classifierUse = document.getElementById("activeClassifierUse");
        activeElements.classifierDownload = document.getElementById("activeClassifierDownload");
        activeElements.classifierDelete = document.getElementById("activeClassifierDelete");
        activeElements.labelmapPath = document.getElementById("activeLabelmapPath");
        activeElements.labelmapUpload = document.getElementById("activeLabelmapUpload");
        activeElements.labelmapBrowse = document.getElementById("activeLabelmapBrowse");
        activeElements.labelmapSelect = document.getElementById("activeLabelmapSelect");
        activeElements.labelmapRefresh = document.getElementById("activeLabelmapRefresh");
        activeElements.labelmapUse = document.getElementById("activeLabelmapUse");
        activeElements.labelmapDownload = document.getElementById("activeLabelmapDownload");
        activeElements.labelmapDelete = document.getElementById("activeLabelmapDelete");
        activeElements.activateLatestButton = document.getElementById("activateLatestModelBtn");
        activeElements.applyButton = document.getElementById("applyActiveModelBtn");
        activeElements.refreshButton = document.getElementById("refreshActiveModelBtn");

        if (activeElements.activateLatestButton) {
            activeElements.activateLatestButton.addEventListener("click", () => {
                handleActivateLatestModel().catch((err) => {
                    console.error("Activate latest model error", err);
                });
            });
        }
        if (activeElements.applyButton) {
            activeElements.applyButton.addEventListener("click", () => {
                handleApplyActiveModel().catch((err) => {
                    console.error("Apply active model error", err);
                });
            });
        }
        if (activeElements.classifierPath) {
            activeElements.classifierPath.addEventListener("input", syncActiveApplyAvailability);
        }
        if (activeElements.refreshButton) {
            activeElements.refreshButton.addEventListener("click", () => {
                refreshActiveModelPanel();
                populateClipBackbones();
                loadActiveClipClassifiers(activeElements.classifierSelect?.value || "");
                loadActiveLabelmaps(activeElements.labelmapSelect?.value || "");
            });
        }
        if (activeElements.classifierRefresh) {
            activeElements.classifierRefresh.addEventListener("click", () => {
                loadActiveClipClassifiers(activeElements.classifierSelect?.value || "");
            });
        }
        if (activeElements.classifierSelect) {
            activeElements.classifierSelect.addEventListener("change", applyActiveClassifierSelection);
        }
        if (activeElements.classifierUse) {
            activeElements.classifierUse.addEventListener("click", applyActiveClassifierSelection);
        }
        if (activeElements.classifierDownload) {
            activeElements.classifierDownload.addEventListener("click", () => {
                const entry = getSelectedActiveClassifier();
                if (!entry || !entry.rel_path) {
                    alert("Select a classifier to download.");
                    return;
                }
                const url = `${API_ROOT}/clip/classifiers/download_zip?rel_path=${encodeURIComponent(entry.rel_path)}`;
                const baseName = entry.filename ? entry.filename.replace(/\\.pkl$/i, "") : "clip_head";
                downloadClipAsset(url, `${baseName}_clip_head.zip`);
            });
        }
        if (activeElements.classifierDelete) {
            activeElements.classifierDelete.addEventListener("click", async () => {
                const entry = getSelectedActiveClassifier();
                if (!entry || !entry.rel_path) {
                    alert("Select a classifier to delete.");
                    return;
                }
                if (!confirm(`Delete classifier ${entry.filename || entry.rel_path}?`)) return;
                try {
                    const resp = await fetch(`${API_ROOT}/clip/classifiers?rel_path=${encodeURIComponent(entry.rel_path)}`, { method: "DELETE" });
                    if (!resp.ok) throw new Error(await resp.text());
                    await loadActiveClipClassifiers("");
                } catch (err) {
                    alert(`Delete failed: ${err.message || err}`);
                }
            });
        }
        if (activeElements.labelmapRefresh) {
            activeElements.labelmapRefresh.addEventListener("click", () => {
                loadActiveLabelmaps(activeElements.labelmapSelect?.value || "");
            });
        }
        if (activeElements.labelmapSelect) {
            activeElements.labelmapSelect.addEventListener("change", applyActiveLabelmapSelection);
        }
        if (activeElements.labelmapUse) {
            activeElements.labelmapUse.addEventListener("click", applyActiveLabelmapSelection);
        }
        if (activeElements.labelmapDownload) {
            activeElements.labelmapDownload.addEventListener("click", () => {
                const entry = getSelectedActiveLabelmap();
                if (!entry || !entry.rel_path) {
                    alert("Select a labelmap to download.");
                    return;
                }
                const url = `${API_ROOT}/clip/labelmaps/download?rel_path=${encodeURIComponent(entry.rel_path)}&root=${encodeURIComponent(entry.root || "labelmaps")}`;
                downloadClipAsset(url, entry.filename || "labelmap.pkl");
            });
        }
        if (activeElements.labelmapDelete) {
            activeElements.labelmapDelete.addEventListener("click", async () => {
                const entry = getSelectedActiveLabelmap();
                if (!entry || !entry.rel_path) {
                    alert("Select a labelmap to delete.");
                    return;
                }
                if (!confirm(`Delete labelmap ${entry.filename || entry.rel_path}?`)) return;
                try {
                    const url = `${API_ROOT}/clip/labelmaps?rel_path=${encodeURIComponent(entry.rel_path)}&root=${encodeURIComponent(entry.root || "labelmaps")}`;
                    const resp = await fetch(url, { method: "DELETE" });
                    if (!resp.ok) throw new Error(await resp.text());
                    await loadActiveLabelmaps("");
                } catch (err) {
                    alert(`Delete failed: ${err.message || err}`);
                }
            });
        }
        if (activeElements.classifierBrowse && activeElements.classifierUpload) {
            activeElements.classifierBrowse.addEventListener("click", (event) => {
                event.preventDefault();
                activeElements.classifierUpload.click();
            });
        }
        if (activeElements.classifierUpload) {
            activeElements.classifierUpload.addEventListener("change", (event) => {
                handleClassifierUploadChange(event).catch((err) => console.error('Classifier upload error', err));
            });
        }
        if (activeElements.labelmapBrowse && activeElements.labelmapUpload) {
            activeElements.labelmapBrowse.addEventListener("click", (event) => {
                event.preventDefault();
                activeElements.labelmapUpload.click();
            });
        }
        if (activeElements.labelmapUpload) {
            activeElements.labelmapUpload.addEventListener("change", (event) => {
                handleLabelmapUploadChange(event).catch((err) => console.error('Labelmap upload error', err));
            });
        }
        loadActiveClipClassifiers().catch((err) => console.warn("Active classifier list load failed", err));
        loadActiveLabelmaps().catch((err) => console.warn("Active labelmap list load failed", err));
    }


    function removePendingBbox(context) {
        const info = context || multiPointPendingBboxInfo;
        if (!info) {
            return;
        }
        const { uuid, imageName } = info;
        if (uuid) {
            delete pendingApiBboxes[uuid];
        }
        if (currentBbox && currentBbox.bbox && currentBbox.bbox.uuid === uuid) {
            currentBbox = null;
        }
        const preserveExisting = uuid && tweakPreserveSet.has(uuid);
        if (preserveExisting) {
            tweakPreserveSet.delete(uuid);
        } else if (imageName && bboxes[imageName]) {
            const classBuckets = bboxes[imageName];
            for (const className of Object.keys(classBuckets)) {
                const bucket = classBuckets[className];
                const idx = bucket.findIndex((bbox) => bbox.uuid === uuid);
                if (idx !== -1) {
                    bucket.splice(idx, 1);
                    break;
                }
            }
        }
        if (!context || (multiPointPendingBboxInfo && multiPointPendingBboxInfo.uuid === uuid && multiPointPendingBboxInfo.imageName === imageName)) {
            multiPointPendingBboxInfo = null;
        }
    }

    function clearMultiPointAnnotations() {
        multiPointPoints = [];
    }

    function cancelPendingMultiPoint({ clearMarkers = false, removePendingBbox: removePendingBboxFlag = false } = {}) {
        multiPointPending = false;
        multiPointPendingToken = null;
        multiPointPendingBboxInfo = null;
        if (removePendingBboxFlag) {
            removePendingBbox();
        }
        if (multiPointQueue.length > 0 && removePendingBboxFlag) {
            while (multiPointQueue.length) {
                const job = multiPointQueue.shift();
                if (job?.placeholderContext) {
                    removePendingBbox(job.placeholderContext);
                }
            }
        } else {
            multiPointQueue.length = 0;
        }
        if (clearMarkers) {
            clearMultiPointAnnotations();
        }
        multiPointWaitingForPreload = false;
    }

    function setButtonDisabled(button, disabled) {
        if (!button) {
            return;
        }
        if ("disabled" in button) {
            button.disabled = !!disabled;
        }
        if (disabled) {
            button.classList.add("button-disabled");
            button.setAttribute("aria-disabled", "true");
            button.setAttribute("tabindex", "-1");
        } else {
            button.classList.remove("button-disabled");
            button.removeAttribute("aria-disabled");
            button.setAttribute("tabindex", "0");
        }
    }

    function registerFileLabel(label, input) {
        if (!label || !input) {
            return;
        }
        label.addEventListener("click", (event) => {
            if (input.disabled) {
                event.preventDefault();
                return;
            }
            event.preventDefault();
            input.value = "";
            input.click();
        });
        label.addEventListener("keydown", (event) => {
            if ((event.key === "Enter" || event.key === " ") && !input.disabled) {
                event.preventDefault();
                input.value = "";
                input.click();
            }
        });
    }

    function setBboxImportEnabled(enabled) {
        const bboxFileInput = document.getElementById("bboxes");
        const bboxFolderInput = document.getElementById("bboxesFolder");
        if (bboxFileInput) {
            bboxFileInput.disabled = !enabled;
        }
        if (bboxFolderInput) {
            bboxFolderInput.disabled = !enabled;
        }
        const bboxFileButton = document.getElementById("bboxesSelect");
        const bboxFolderButton = document.getElementById("bboxesSelectFolder");
        setButtonDisabled(bboxFileButton, !enabled);
        setButtonDisabled(bboxFolderButton, !enabled);
    }

    function setSamStatus(text, { variant = null, duration = 4000 } = {}) {
        if (!samStatusEl) {
            samStatusMessageToken++;
            return samStatusMessageToken;
        }
        if (samStatusTimer) {
            clearTimeout(samStatusTimer);
            samStatusTimer = null;
        }
        const token = ++samStatusMessageToken;
        samStatusEl.textContent = text || "";
        samStatusEl.classList.remove("warn", "error", "success");
        if (variant) {
            samStatusEl.classList.add(variant);
        }
        if (text && duration !== 0) {
            const timeout = typeof duration === "number" ? duration : 4000;
            samStatusTimer = setTimeout(() => {
                if (samStatusMessageToken !== token) {
                    return;
                }
                samStatusEl.textContent = "";
                samStatusEl.classList.remove("warn", "error", "success");
                samStatusTimer = null;
                hideSamPreloadProgress();
            }, timeout);
        } else if (!text) {
            hideSamPreloadProgress();
        }
        return token;
    }

    function showSamPreloadProgress() {
        if (!samStatusProgressEl) {
            return;
        }
        samStatusProgressEl.classList.add("active");
        samStatusProgressEl.setAttribute("aria-hidden", "false");
    }

    function hideSamPreloadProgress() {
        if (!samStatusProgressEl) {
            return;
        }
        samStatusProgressEl.classList.remove("active");
        samStatusProgressEl.setAttribute("aria-hidden", "true");
    }

    function beginSamActionStatus(message, { variant = "info" } = {}) {
        const token = setSamStatus(message, { variant, duration: 0 });
        showSamPreloadProgress();
        return token;
    }

    function endSamActionStatus(token, options = {}) {
        if (samStatusMessageToken !== token) {
            return;
        }
        const { message = "", variant = null, duration = 0 } = options;
        if (message) {
            setSamStatus(message, { variant, duration });
        } else {
            setSamStatus("", { duration: 0 });
        }
        hideSamPreloadProgress();
    }

    function registerSamPreloadWatcher(imageName, variant) {
        return new Promise((resolve) => {
            const key = getSamTokenKey(imageName, variant);
            const entry = { resolver: resolve, timeoutId: null };
            const bucket = samPreloadWatchers.get(key) || [];
            entry.timeoutId = window.setTimeout(() => {
                const current = samPreloadWatchers.get(key);
                if (current) {
                    const idx = current.indexOf(entry);
                    if (idx !== -1) {
                        current.splice(idx, 1);
                        if (current.length === 0) {
                            samPreloadWatchers.delete(key);
                        }
                    }
                }
                resolve(null);
            }, SAM_PRELOAD_WAIT_TIMEOUT_MS);
            bucket.push(entry);
            samPreloadWatchers.set(key, bucket);
        });
    }

    function notifySamPreloadWatchers(imageName, variant) {
        if (!imageName) {
            return;
        }
        const key = getSamTokenKey(imageName, variant);
        const listeners = samPreloadWatchers.get(key);
        if (!listeners) {
            return;
        }
        samPreloadWatchers.delete(key);
        const token = getSamToken(imageName, variant) || null;
        listeners.forEach(({ resolver, timeoutId }) => {
            if (timeoutId) {
                clearTimeout(timeoutId);
            }
            try {
                resolver(token);
            } catch (error) {
                console.warn("SAM preload watcher resolution failed", error);
            }
        });
    }

    function waitForSamPreloadIfActive(imageName, variant) {
        if (!imageName) {
            return Promise.resolve(getSamToken(imageName, variant) || null);
        }
        if (!currentImage || currentImage.name !== imageName) {
            return Promise.resolve(getSamToken(imageName, variant) || null);
        }
        const effectiveVariant = variant || samVariant;
        const immediateToken = getSamToken(imageName, effectiveVariant);
        if (immediateToken) {
            return Promise.resolve(immediateToken);
        }
        if (!samPreloadEnabled) {
            return Promise.resolve(null);
        }
        if (!samPreloadCurrentImageName) {
            return Promise.resolve(null);
        }
        if (samPreloadCurrentImageName !== imageName) {
            return Promise.resolve(null);
        }
        const activeVariant = samPreloadCurrentVariant || samVariant;
        const watchVariant = activeVariant || effectiveVariant;

        return (async () => {
            let attempts = 0;
            while (attempts < 3) {
                const awaitedToken = await registerSamPreloadWatcher(imageName, watchVariant);
                const candidateVariant = awaitedToken ? watchVariant : (samPreloadCurrentVariant || samVariant || effectiveVariant);
                const candidateToken = awaitedToken || getSamToken(imageName, candidateVariant);
                if (candidateToken) {
                    return candidateToken;
                }
                if (!samPreloadEnabled || !samPreloadCurrentImageName || samPreloadCurrentImageName !== imageName) {
                    break;
                }
                attempts += 1;
            }
            return getSamToken(imageName, effectiveVariant) || null;
        })();
    }

    function abortSlotPreload(slotName, options = {}) {
        const existing = slotPreloadControllers[slotName];
        if (!existing) {
            return;
        }
        const preserveSet = options?.preserveImages instanceof Set
            ? options.preserveImages
            : toImageNameSet(options?.preserveImages);
        if (preserveSet && existing.imageName && preserveSet.has(existing.imageName)) {
            return;
        }
        try {
            existing.controller?.abort();
        } catch (err) {
            console.debug(`Slot preload abort (${slotName}) failed`, err);
        }
        if (typeof existing.releaseLoading === "function") {
            existing.releaseLoading();
        }
        if (existing.imageName) {
            slotPreloadPromises.delete(existing.imageName);
            slotLoadingIndicators.delete(existing.imageName);
        }
        slotPreloadControllers[slotName] = null;
        scheduleSamSlotStatusRefresh(true);
    }

    function getNeighborSlots(currentName) {
        const listEl = document.getElementById("imageList");
        if (!listEl || !currentName) {
            return { nextName: null, previousName: null };
        }
        const options = Array.from(listEl.options);
        const idx = options.findIndex((opt) => getOptionImageName(opt) === currentName);
        if (idx === -1) {
            return { nextName: null, previousName: null };
        }
        const nextOpt = idx < options.length - 1 ? options[idx + 1] : null;
        const prevOpt = idx > 0 ? options[idx - 1] : null;
        return {
            nextName: getOptionImageName(nextOpt),
            previousName: getOptionImageName(prevOpt),
        };
    }

    function getOptionImageName(option) {
        if (!option) {
            return null;
        }
        return option.value || option.text || option.innerHTML || null;
    }

    function isSlotRoleEnabled(slotRole) {
        if (!slotRole || slotRole === "current") {
            return true;
        }
        if (slotRole === "next") {
            return samPredictorBudget >= 2;
        }
        if (slotRole === "previous") {
            return samPredictorBudget >= 3;
        }
        return true;
    }

    function ensureImageListVisibility(targetIndex) {
        const listEl = document.getElementById("imageList");
        if (!listEl || typeof targetIndex !== "number" || targetIndex < 0) {
            return;
        }
        const option = listEl.options[targetIndex];
        if (!option) {
            return;
        }
        const optionHeight = option.offsetHeight || parseInt(window.getComputedStyle(option).lineHeight || "0", 10) || 18;
        const listHeight = listEl.clientHeight || (optionHeight * listEl.size) || optionHeight;
        const visibleCount = optionHeight ? Math.max(1, Math.floor(listHeight / optionHeight)) : listEl.options.length;
        if (visibleCount >= listEl.options.length) {
            listEl.scrollTop = 0;
            return;
        }
        const halfWindow = Math.max(1, Math.floor(visibleCount / 2));
        const lastIndex = listEl.options.length - 1;
        const maxStart = Math.max(0, listEl.options.length - visibleCount);
        let firstIndex;
        if (targetIndex <= halfWindow) {
            firstIndex = 0;
        } else if (targetIndex >= lastIndex - halfWindow) {
            firstIndex = maxStart;
        } else {
            firstIndex = targetIndex - halfWindow;
        }
        const desiredScroll = firstIndex * optionHeight;
        if (Math.abs(listEl.scrollTop - desiredScroll) > 1) {
            listEl.scrollTop = desiredScroll;
        }
    }

    function syncImageSelectionToName(imageName, options = {}) {
        const listEl = document.getElementById("imageList");
        if (!listEl || !imageName) {
            return;
        }
        const opts = Array.from(listEl.options);
        const targetIndex = opts.findIndex((opt) => getOptionImageName(opt) === imageName);
        if (targetIndex === -1) {
            return;
        }
        const releaseLock = lockImageSelection();
        opts.forEach((opt, idx) => {
            opt.selected = idx === targetIndex;
        });
        listEl.selectedIndex = targetIndex;
        imageListIndex = targetIndex;
        if (options.ensureVisible) {
            ensureImageListVisibility(targetIndex);
        }
        releaseLock();
    }

    function lockImageSelection() {
        imageListSelectionLock++;
        let released = false;
        return () => {
            if (released) {
                return;
            }
            released = true;
            imageListSelectionLock = Math.max(0, imageListSelectionLock - 1);
        };
    }

    function toImageNameSet(values) {
        if (!values) {
            return null;
        }
        if (values instanceof Set) {
            return values;
        }
        if (!Array.isArray(values)) {
            return new Set(values ? [values] : []);
        }
        const filtered = values.filter(Boolean);
        return filtered.length ? new Set(filtered) : null;
    }

    function triggerNeighborSlotPreloads(currentName) {
        if (!samPreloadEnabled || !samSlotsEnabled || !currentName) {
            abortSlotPreload("next");
            abortSlotPreload("previous");
            return;
        }
        const { nextName, previousName } = getNeighborSlots(currentName);
        if (!isSlotRoleEnabled("next")) {
            abortSlotPreload("next");
        } else {
            if (nextName && shouldPreloadNeighborImage(nextName, "next")) {
                preloadSlotForImage(nextName, "next").catch((err) => {
                    console.debug("Next-slot preload failure", err);
                });
            } else if (!nextName) {
                abortSlotPreload("next");
            }
        }
        if (!isSlotRoleEnabled("previous")) {
            abortSlotPreload("previous");
        } else {
            if (previousName && shouldPreloadNeighborImage(previousName, "previous")) {
                preloadSlotForImage(previousName, "previous").catch((err) => {
                    console.debug("Previous-slot preload failure", err);
                });
            } else if (!previousName) {
                abortSlotPreload("previous");
            }
        }
    }

    async function activateImageSlot(imageName) {
        if (!samPreloadEnabled || !imageName) {
            return false;
        }
        if (!samSlotsEnabled) {
            const supported = await ensureSamSlotsSupport();
            if (!supported) {
                return false;
            }
        }
        const taskId = enqueueTask({ kind: "sam-activate", imageName });
        try {
            const resp = await fetch(`${API_ROOT}/sam_activate_slot`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ image_name: imageName, sam_variant: samVariant }),
            });
            if (!resp.ok) {
                completeTask(taskId);
                return false;
            }
            await resp.json();
            scheduleSamSlotStatusRefresh(true);
            completeTask(taskId);
            return true;
        } catch (error) {
            console.debug("activateImageSlot failed", error);
            completeTask(taskId);
            return false;
        }
    }

    async function prepareSamForCurrentImage(options = {}) {
        if (!samPreloadEnabled || !currentImage || !currentImage.name) {
            return;
        }
        const targetName = currentImage.name;
        const { messagePrefix = null, immediate = false } = options;
        const variantSnapshot = samVariant;
        const preloadAlreadyRunning = isSamPreloadActiveFor(targetName, variantSnapshot);
        if (samSlotsEnabled || await ensureSamSlotsSupport()) {
            let activated = await activateImageSlot(targetName);
            if (!activated && samSlotsEnabled) {
                const waited = await waitForSlotPreload(targetName);
                if (waited && currentImage && currentImage.name === targetName) {
                    activated = await activateImageSlot(targetName);
                }
            }
            if (activated) {
                if (!currentImage || currentImage.name !== targetName) {
                    return;
                }
                clearImageSlotLoading(targetName);
                setSamStatus(`SAM ready for ${targetName}`, { variant: "success", duration: 2000 });
                resolveSamPreloadWaiters(targetName, samVariant);
                hideSamPreloadProgress();
                triggerNeighborSlotPreloads(targetName);
                scheduleSamSlotStatusRefresh(true);
                return;
            }
        }
        scheduleSamPreload({
            force: !preloadAlreadyRunning,
            delayMs: immediate ? 0 : SAM_PRELOAD_IMAGE_SWITCH_DELAY_MS,
            messagePrefix,
            slot: samSlotsEnabled ? "current" : undefined,
            variant: variantSnapshot,
        });
    }

    async function ensureImageRecordReady(imageRecord) {
        if (!imageRecord) {
            return false;
        }
        if (imageRecord.object) {
            imageRecord.width = imageRecord.width || imageRecord.object.naturalWidth || imageRecord.object.width || imageRecord.width || 0;
            imageRecord.height = imageRecord.height || imageRecord.object.naturalHeight || imageRecord.object.height || imageRecord.height || 0;
            return true;
        }
        if (!imageRecord.meta) {
            return false;
        }
        try {
            await loadImageObject(imageRecord);
            imageRecord.width = imageRecord.width || imageRecord.object?.naturalWidth || imageRecord.object?.width || imageRecord.width || 0;
            imageRecord.height = imageRecord.height || imageRecord.object?.naturalHeight || imageRecord.object?.height || imageRecord.height || 0;
            return Boolean(imageRecord.object);
        } catch (err) {
            console.warn("Failed to load image record", imageRecord?.meta?.name, err);
            return false;
        }
    }

    async function getBase64ForImageRecord(imageRecord) {
        if (!imageRecord) {
            return null;
        }
        if (imageRecord.dataUrl && imageRecord.dataUrl.includes(',')) {
            return imageRecord.dataUrl.split(',')[1];
        }
        const ready = await ensureImageRecordReady(imageRecord);
        if (!ready || !imageRecord.object) {
            return null;
        }
        const offCanvas = document.createElement("canvas");
        offCanvas.width = imageRecord.width || imageRecord.object.naturalWidth || imageRecord.object.width || 0;
        offCanvas.height = imageRecord.height || imageRecord.object.naturalHeight || imageRecord.object.height || 0;
        if (!offCanvas.width || !offCanvas.height) {
            return null;
        }
        const ctx = offCanvas.getContext("2d");
        ctx.drawImage(imageRecord.object, 0, 0, offCanvas.width, offCanvas.height);
        const dataUrl = offCanvas.toDataURL("image/jpeg");
        imageRecord.dataUrl = dataUrl;
        return dataUrl.split(',')[1];
    }

    async function preloadSlotForImage(imageName, slotName) {
        if (!samPreloadEnabled || !imageName) {
            return null;
        }
        if (!samSlotsEnabled) {
            const supported = await ensureSamSlotsSupport();
            if (!supported) {
                return null;
            }
        }
        const imageRecord = images[imageName];
        if (!imageRecord) {
            return null;
        }
        const existingPromise = slotPreloadPromises.get(imageName);
        if (existingPromise) {
            return existingPromise;
        }
        const existingTask = slotPreloadControllers[slotName];
        if (existingTask && existingTask.imageName === imageName) {
            const promise = slotPreloadPromises.get(imageName);
            if (promise) {
                return promise;
            }
        }
        abortSlotPreload(slotName);

        const runPromise = (async () => {
            const controller = new AbortController();
            const slotTask = { controller, releaseLoading: null, imageName };
            slotPreloadControllers[slotName] = slotTask;
            try {
                const requestBody = { slot: slotName, sam_variant: samVariant, image_name: imageName };
                const cachedToken = getSamToken(imageName, samVariant);
                if (cachedToken) {
                    requestBody.image_token = cachedToken;
                } else {
                    const base64Img = await getBase64ForImageRecord(imageRecord);
                    if (!base64Img) {
                        if (slotPreloadControllers[slotName] === slotTask) {
                            if (typeof slotTask.releaseLoading === "function") {
                                slotTask.releaseLoading();
                            }
                            slotPreloadControllers[slotName] = null;
                        }
                        return null;
                    }
                    requestBody.image_base64 = base64Img;
                }

                slotTask.releaseLoading = beginImageSlotLoading(imageName, slotName);
                const resp = await fetch(`${API_ROOT}/sam_preload`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(requestBody),
                    signal: controller.signal,
                });
                if (!resp.ok) {
                    const detail = await resp.text();
                    throw new Error(detail || `HTTP ${resp.status}`);
                }
                const result = await resp.json();
                if (result?.token) {
                    rememberSamToken(imageName, samVariant, result.token);
                }
                return result;
            } catch (error) {
                if (!error || error.name !== "AbortError") {
                    console.warn(`Background SAM preload failed for ${imageName} (${slotName})`, error);
                }
                throw error;
            } finally {
                const activeTask = slotPreloadControllers[slotName];
                if (activeTask === slotTask) {
                    if (typeof slotTask.releaseLoading === "function") {
                        slotTask.releaseLoading();
                    }
                    slotPreloadControllers[slotName] = null;
                }
                slotPreloadPromises.delete(imageName);
                scheduleSamSlotStatusRefresh();
            }
        })();

        slotPreloadPromises.set(imageName, runPromise);
        runPromise.catch(() => null);
        return runPromise;
    }

    async function ensureSamSlotsSupport() {
        if (samSlotsSupportChecked) {
            return samSlotsEnabled;
        }
        samSlotsSupportChecked = true;
        try {
            const resp = await fetch(`${API_ROOT}/sam_slots`);
            if (!resp.ok) {
                throw new Error(await resp.text());
            }
            const data = await resp.json();
            samSlotsEnabled = Array.isArray(data);
            if (samSlotsEnabled) {
                updateSlotHighlights(Array.isArray(data) ? data : []);
            }
        } catch (error) {
            samSlotsEnabled = false;
        }
        return samSlotsEnabled;
    }

    function scheduleSamSlotStatusRefresh(immediate = false) {
        if (!samSlotsEnabled || !samPreloadEnabled) {
            if (samSlotStatusTimer) {
                clearTimeout(samSlotStatusTimer);
                samSlotStatusTimer = null;
            }
            updateSlotHighlights([]);
            return;
        }
        if (samSlotStatusTimer) {
            clearTimeout(samSlotStatusTimer);
            samSlotStatusTimer = null;
        }
        if (immediate) {
            if (samSlotStatusPending) {
                samSlotStatusNeedsRefresh = true;
            } else {
                refreshSamSlotStatus();
            }
            return;
        }
        samSlotStatusTimer = setTimeout(() => {
            samSlotStatusTimer = null;
            if (samSlotStatusPending) {
                samSlotStatusNeedsRefresh = true;
            } else {
                refreshSamSlotStatus();
            }
        }, SAM_SLOT_STATUS_DEBOUNCE_MS);
    }

    async function refreshSamSlotStatus() {
        if (!samSlotsEnabled || !samPreloadEnabled) {
            return;
        }
        if (samSlotStatusPending) {
            samSlotStatusNeedsRefresh = true;
            return;
        }
        samSlotStatusPending = true;
        try {
            const resp = await fetch(`${API_ROOT}/sam_slots`);
            if (!resp.ok) {
                if (resp.status === 404) {
                    samSlotsEnabled = false;
                    updateSlotHighlights([]);
                    return;
                }
                throw new Error(await resp.text());
            }
            const data = await resp.json();
            updateSlotHighlights(Array.isArray(data) ? data : []);
        } catch (error) {
            console.debug("SAM slot status refresh failed", error);
        } finally {
            samSlotStatusPending = false;
            if (samSlotStatusNeedsRefresh) {
                samSlotStatusNeedsRefresh = false;
                refreshSamSlotStatus();
            }
        }
    }

    function beginImageSlotLoading(imageName, slotName = "current") {
        if (!imageName) {
            return () => {};
        }
        const normalizedSlot = slotName || "current";
        let entry = slotLoadingIndicators.get(imageName);
        if (!entry) {
            entry = { slots: new Map() };
            slotLoadingIndicators.set(imageName, entry);
        }
        const currentCount = entry.slots.get(normalizedSlot) || 0;
        entry.slots.set(normalizedSlot, currentCount + 1);
        applySlotStatusClasses();
        let released = false;
        return () => {
            if (released) {
                return;
            }
            released = true;
            const activeEntry = slotLoadingIndicators.get(imageName);
            if (!activeEntry) {
                applySlotStatusClasses();
                return;
            }
            const remaining = (activeEntry.slots.get(normalizedSlot) || 1) - 1;
            if (remaining <= 0) {
                activeEntry.slots.delete(normalizedSlot);
            } else {
                activeEntry.slots.set(normalizedSlot, remaining);
            }
            if (activeEntry.slots.size === 0) {
                slotLoadingIndicators.delete(imageName);
            }
            applySlotStatusClasses();
        };
    }

    function clearImageSlotLoading(imageName) {
        if (!imageName) {
            return;
        }
        if (slotLoadingIndicators.delete(imageName)) {
            applySlotStatusClasses();
        }
    }

    function applySlotStatusClasses(options = {}) {
        const imageList = document.getElementById("imageList");
        if (!imageList) {
            return;
        }
        const slotStatusMap = new Map();
        latestSlotStatuses.forEach((entry) => {
            if (entry?.image_name) {
                const existing = slotStatusMap.get(entry.image_name) || [];
                existing.push(entry);
                slotStatusMap.set(entry.image_name, existing);
            }
        });
        const optionsArray = Array.from(imageList.options);
        let needsSelectionFix = false;
        optionsArray.forEach((option) => {
            option.classList.remove(
                "sam-slot-current",
                "sam-slot-next",
                "sam-slot-previous",
                "sam-slot-loaded",
                "sam-slot-loading"
            );
            const name = getOptionImageName(option);
            const entries = slotStatusMap.get(name) || [];
            const slotEntry = entries.find((entry) => entry?.variant === samVariant)
                || entries.find((entry) => entry?.variant === "sam3")
                || entries[0];
            const loadingEntry = slotLoadingIndicators.get(name);
            const tokenLoaded = !loadingEntry && (
                getSamToken(name, slotEntry?.variant || samVariant)
                || getSamToken(name, "sam3")
                || getSamToken(name, "sam1")
            );
            if (slotEntry?.slot) {
                option.classList.add(`sam-slot-${slotEntry.slot}`);
            }
            if (loadingEntry?.slots?.size) {
                loadingEntry.slots.forEach((count, slotName) => {
                    if (slotName && count > 0) {
                        option.classList.add(`sam-slot-${slotName}`);
                    }
                });
                option.classList.add("sam-slot-loading");
            } else if (slotEntry?.slot || tokenLoaded) {
                option.classList.add("sam-slot-loaded");
            }
            if (
                !needsSelectionFix &&
                currentImage &&
                currentImage.name === name &&
                !option.selected
            ) {
                needsSelectionFix = true;
            }
        });
        if (needsSelectionFix && imageListSelectionLock === 0) {
            syncImageSelectionToName(currentImage.name, { ensureVisible: false });
        }
    }

    function clearSelectedBboxes({ keepCurrent = false } = {}) {
        selectedBboxes.clear();
        negativeBboxes.clear();
        if (!keepCurrent && currentBbox && currentBbox.bbox) {
            currentBbox.bbox.marked = false;
        }
    }

    function selectBboxRecord(bboxRecord, { additive = false, negative = false } = {}) {
        if (!bboxRecord) {
            return;
        }
        if (!additive) {
            selectedBboxes.clear();
            negativeBboxes.clear();
        }
        if (!bboxRecord.uuid) {
            bboxRecord.uuid = generateUUID();
        }
        const uuid = bboxRecord.uuid;
        if (!uuid) {
            return;
        }
        if (negative) {
            if (additive && negativeBboxes.has(uuid)) {
                negativeBboxes.delete(uuid);
            } else {
                negativeBboxes.add(uuid);
                selectedBboxes.delete(uuid);
            }
        } else {
            if (additive && selectedBboxes.has(uuid)) {
                selectedBboxes.delete(uuid);
            } else {
                selectedBboxes.add(uuid);
                negativeBboxes.delete(uuid);
            }
        }
    }

    function getSelectedBboxRecords({ negative = false } = {}) {
        if (!currentImage || !bboxes[currentImage.name]) {
            return [];
        }
        const records = [];
        const buckets = bboxes[currentImage.name];
        Object.keys(buckets).forEach((className) => {
            (buckets[className] || []).forEach((bboxRecord) => {
                if (!bboxRecord || !bboxRecord.uuid) {
                    return;
                }
                if (negative ? negativeBboxes.has(bboxRecord.uuid) : selectedBboxes.has(bboxRecord.uuid)) {
                    records.push(bboxRecord);
                }
            });
        });
        return records;
    }

    function deleteSelectedBboxes() {
        if (!currentImage || !bboxes[currentImage.name]) {
            return 0;
        }
        const records = [...getSelectedBboxRecords({ negative: false }), ...getSelectedBboxRecords({ negative: true })];
        if (!records.length) {
            return 0;
        }
        const byClass = new Map();
        records.forEach((rec) => {
            if (!rec || !rec.class || !rec.uuid) {
                return;
            }
            if (!byClass.has(rec.class)) {
                byClass.set(rec.class, new Set());
            }
            byClass.get(rec.class).add(rec.uuid);
        });
        let removed = 0;
        byClass.forEach((uuidSet, className) => {
            const bucket = bboxes[currentImage.name][className];
            if (!bucket) {
                return;
            }
            const remaining = bucket.filter((bx) => !bx.uuid || !uuidSet.has(bx.uuid));
            removed += bucket.length - remaining.length;
            if (remaining.length) {
                bboxes[currentImage.name][className] = remaining;
            } else {
                delete bboxes[currentImage.name][className];
            }
        });
        if (
            currentBbox &&
            currentBbox.bbox &&
            currentBbox.bbox.uuid &&
            (selectedBboxes.has(currentBbox.bbox.uuid) || negativeBboxes.has(currentBbox.bbox.uuid))
        ) {
            currentBbox = null;
            document.body.style.cursor = "default";
        }
        clearSelectedBboxes();
        return removed;
    }

    function selectBboxesInRect(rect, { additive = true, negative = false } = {}) {
        if (!currentImage || !bboxes[currentImage.name]) {
            return 0;
        }
        if (!additive) {
            clearSelectedBboxes();
        }
        const { x, y, width, height } = rect;
        const rectX2 = x + width;
        const rectY2 = y + height;
        const currentBxs = bboxes[currentImage.name];
        let selectedCount = 0;
        let firstSelected = null;
        Object.keys(currentBxs).forEach((className) => {
            currentBxs[className].forEach((bx, i) => {
                if (!bx) return;
                const isPoly = bx.type === "polygon" || (Array.isArray(bx.points) && bx.points.length >= 3);
                let bxRect = null;
                let centroid = null;
                if (isPoly) {
                    const xs = bx.points.map((p) => p.x);
                    const ys = bx.points.map((p) => p.y);
                    const minX = Math.min(...xs);
                    const maxX = Math.max(...xs);
                    const minY = Math.min(...ys);
                    const maxY = Math.max(...ys);
                    bxRect = { x: minX, y: minY, width: maxX - minX, height: maxY - minY };
                    centroid = polygonCentroid(bx.points);
                } else {
                    bxRect = { x: bx.x, y: bx.y, width: bx.width, height: bx.height };
                }
                const center = centroid || {
                    x: bxRect.x + bxRect.width / 2,
                    y: bxRect.y + bxRect.height / 2,
                };
                const inside =
                    center.x >= rect.x &&
                    center.x <= rectX2 &&
                    center.y >= rect.y &&
                    center.y <= rectY2;
                if (!inside) {
                    return;
                }
                selectBboxRecord(bx, { additive: true, negative });
                selectedCount += 1;
                if (!firstSelected) {
                    firstSelected = { bbox: bx, index: i };
                }
            });
        });
        if (!negative && !currentBbox && firstSelected) {
            currentBbox = {
                bbox: firstSelected.bbox,
                index: firstSelected.index,
                originalX: firstSelected.bbox.x,
                originalY: firstSelected.bbox.y,
                originalWidth: firstSelected.bbox.width,
                originalHeight: firstSelected.bbox.height,
                moving: false,
                resizing: null
            };
        }
        return selectedCount;
    }

    function polygonCentroid(points) {
        if (!Array.isArray(points) || points.length < 3) {
            return null;
        }
        let area = 0;
        let cx = 0;
        let cy = 0;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            const p1 = points[j];
            const p2 = points[i];
            const cross = (p1.x * p2.y) - (p2.x * p1.y);
            area += cross;
            cx += (p1.x + p2.x) * cross;
            cy += (p1.y + p2.y) * cross;
        }
        area *= 0.5;
        if (Math.abs(area) < 1e-6) {
            return null;
        }
        const factor = 1 / (6 * area);
        return { x: cx * factor, y: cy * factor };
    }

    function updateSlotHighlights(statusList) {
        latestSlotStatuses = Array.isArray(statusList) ? statusList : [];
        applySlotStatusClasses();
    }

    function findSlotStatusForImage(imageName, variant = samVariant) {
        if (!imageName) {
            return null;
        }
        return latestSlotStatuses.find((entry) => {
            if (!entry || entry.image_name !== imageName) {
                return false;
            }
            if (!entry.variant || !variant) {
                return true;
            }
            return entry.variant === variant;
        }) || null;
    }

    function isImageCurrentlyLoading(imageName) {
        if (!imageName) {
            return false;
        }
        return slotLoadingIndicators.has(imageName);
    }

    function shouldPreloadNeighborImage(imageName, slotRole = "current", variant = samVariant) {
        if (!imageName) {
            return false;
        }
        if (currentImage && currentImage.name === imageName) {
            return false;
        }
        if (!isSlotRoleEnabled(slotRole)) {
            return false;
        }
        if (isImageCurrentlyLoading(imageName)) {
            return false;
        }
        const entry = findSlotStatusForImage(imageName, variant);
        return !entry;
    }

    function waitForSlotPreload(imageName) {
        if (!imageName) {
            return Promise.resolve(false);
        }
        const promise = slotPreloadPromises.get(imageName);
        if (!promise) {
            return Promise.resolve(false);
        }
        return promise.then(() => true).catch(() => false);
    }

    function setPredictorMessage(text, variant = "info") {
        if (!predictorElements.message) {
            return;
        }
        predictorElements.message.textContent = text || "";
        predictorElements.message.className = `predictor-message ${variant}`;
    }

    function coerceNumber(value, fallback) {
        if (value === null || typeof value === "undefined") {
            return fallback;
        }
        const parsed = Number(value);
        return Number.isNaN(parsed) ? fallback : parsed;
    }

    function applyPredictorState(data) {
        if (!data) {
            return;
        }
        predictorSettings = {
            maxPredictors: coerceNumber(data.max_predictors, predictorSettings.maxPredictors),
            minPredictors: coerceNumber(data.min_predictors, predictorSettings.minPredictors),
            maxSupportedPredictors: coerceNumber(data.max_supported_predictors, predictorSettings.maxSupportedPredictors),
            activePredictors: coerceNumber(data.active_predictors, predictorSettings.activePredictors),
            loadedPredictors: coerceNumber(data.loaded_predictors, predictorSettings.loadedPredictors),
            processRamMb: coerceNumber(data.process_ram_mb, 0),
            totalRamMb: coerceNumber(data.total_ram_mb, 0),
            availableRamMb: coerceNumber(data.available_ram_mb, 0),
            imageRamMb: coerceNumber(data.image_ram_mb, 0),
            gpuTotalMb: coerceNumber(data.gpu_total_mb, 0),
            gpuFreeMb: coerceNumber(data.gpu_free_mb, 0),
            gpuComputeCapability: data.gpu_compute_capability || null,
        };
        samPredictorBudget = predictorSettings.maxPredictors;
        if (predictorElements.countInput) {
            predictorElements.countInput.min = predictorSettings.minPredictors || 1;
            predictorElements.countInput.max = predictorSettings.maxSupportedPredictors || predictorElements.countInput.max || 3;
            predictorElements.countInput.value = predictorSettings.maxPredictors;
        }
        renderPredictorStats();
    }

    function renderPredictorStats() {
        if (predictorElements.activeCount) {
            predictorElements.activeCount.textContent = `${predictorSettings.activePredictors} / ${predictorSettings.maxSupportedPredictors}`;
        }
        if (predictorElements.loadedCount) {
            predictorElements.loadedCount.textContent = `${predictorSettings.loadedPredictors}`;
        }
        if (predictorElements.processRam) {
            predictorElements.processRam.textContent = formatMb(predictorSettings.processRamMb);
        }
        if (predictorElements.imageRam) {
            predictorElements.imageRam.textContent = formatMb(predictorSettings.imageRamMb);
        }
        if (predictorElements.systemFreeRam) {
            const useGpu = predictorSettings.gpuTotalMb > 0;
            const free = useGpu ? predictorSettings.gpuFreeMb : predictorSettings.availableRamMb;
            const total = useGpu ? predictorSettings.gpuTotalMb : predictorSettings.totalRamMb;
            predictorElements.systemFreeRam.textContent = total
                ? `${formatMb(free)} / ${formatMb(total)}`
                : formatMb(free);
        }
    }

    function formatMb(value) {
        if (typeof value !== "number" || Number.isNaN(value)) {
            return "--";
        }
        return `${value.toFixed(1)} MB`;
    }

    function warnIfFp8Unsupported(modelId) {
        if (!modelId || !modelId.includes("FP8")) {
            return;
        }
        const ccRaw = predictorSettings.gpuComputeCapability;
        const cc = ccRaw ? Number.parseFloat(ccRaw) : null;
        if (!cc || Number.isNaN(cc)) {
            setSamStatus("FP8 models require GPU compute capability ≥ 8.9 (e.g., 4090/H100). Current GPU capability unknown.", { variant: "warn", duration: 4500 });
            return;
        }
        if (cc < 8.9) {
            setSamStatus(`FP8 models require GPU compute capability ≥ 8.9 (e.g., 4090/H100). Current: ${ccRaw}.`, { variant: "warn", duration: 4500 });
        }
    }

    async function refreshPredictorMetrics(options = {}) {
        if (predictorRefreshInFlight) {
            return;
        }
        predictorRefreshInFlight = true;
        try {
            const resp = await fetch(`${API_ROOT}/predictor_settings`);
            if (!resp.ok) {
                throw new Error(await resp.text() || `HTTP ${resp.status}`);
            }
            const data = await resp.json();
            applyPredictorState(data);
            if (!options.silent) {
                setPredictorMessage("Predictor stats updated.", "success");
            }
        } catch (error) {
            if (!options.silent) {
                setPredictorMessage(`Unable to fetch predictor stats: ${error.message || error}`, "error");
            }
        } finally {
            predictorRefreshInFlight = false;
        }
    }

    async function submitPredictorSettings(desiredCount) {
        const min = predictorSettings.minPredictors || 1;
        const max = predictorSettings.maxSupportedPredictors || 3;
        const normalized = Math.max(min, Math.min(max, Number(desiredCount) || min));
        setPredictorMessage("Updating predictor budget…", "info");
        try {
            const resp = await fetch(`${API_ROOT}/predictor_settings`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ max_predictors: normalized }),
            });
            if (!resp.ok) {
                throw new Error(await resp.text() || `HTTP ${resp.status}`);
            }
            const data = await resp.json();
            applyPredictorState(data);
            setPredictorMessage("Predictor budget updated.", "success");
        } catch (error) {
            setPredictorMessage(`Failed to update predictor budget: ${error.message || error}`, "error");
        }
    }

    function startPredictorRefresh(immediate = false) {
        if (predictorRefreshTimer) {
            clearInterval(predictorRefreshTimer);
            predictorRefreshTimer = null;
        }
        if (immediate) {
            refreshPredictorMetrics({ silent: true });
        }
        predictorRefreshTimer = setInterval(() => {
            refreshPredictorMetrics({ silent: true });
        }, PREDICTOR_REFRESH_INTERVAL_MS);
    }

    function stopPredictorRefresh() {
        if (predictorRefreshTimer) {
            clearInterval(predictorRefreshTimer);
            predictorRefreshTimer = null;
        }
    }

    function initializePredictorTab() {
        if (predictorTabInitialized) {
            return;
        }
        predictorTabInitialized = true;
        refreshPredictorMetrics({ silent: true });
    }

    function initializeSettingsUi() {
        if (settingsUiInitialized) {
            return;
        }
        settingsUiInitialized = true;
        settingsElements.apiInput = document.getElementById("settingsApiRoot");
        settingsElements.applyButton = document.getElementById("settingsApply");
        settingsElements.testButton = document.getElementById("settingsTest");
        settingsElements.status = document.getElementById("settingsStatus");
        qwenSettingsElements.trustRemoteCode = document.getElementById("qwenTrustRemoteCode");
        qwenSettingsElements.applyButton = document.getElementById("qwenSettingsApply");
        qwenSettingsElements.status = document.getElementById("qwenSettingsStatus");
    backendFuzzerElements.runButton = document.getElementById("runBackendFuzzer");
    backendFuzzerElements.status = document.getElementById("backendFuzzerStatus");
    backendFuzzerElements.log = document.getElementById("backendFuzzerLog");
    backendFuzzerElements.includeQwen = document.getElementById("fuzzerIncludeQwen");
    backendFuzzerElements.includeSam3 = document.getElementById("fuzzerIncludeSam3");
    backendFuzzerElements.includeClip = document.getElementById("fuzzerIncludeClip");
    backendFuzzerElements.includeAgent = document.getElementById("fuzzerIncludeAgent");
        if (settingsElements.apiInput) {
            settingsElements.apiInput.value = API_ROOT;
        }
        setSettingsStatus(`Current backend: ${API_ROOT}`, "info");
        if (settingsElements.applyButton) {
            settingsElements.applyButton.addEventListener("click", () => applyApiRootValue(settingsElements.apiInput?.value || ""));
        }
        if (settingsElements.testButton) {
            settingsElements.testButton.addEventListener("click", () => testApiRootCandidate(settingsElements.apiInput?.value || API_ROOT));
        }
        if (qwenSettingsElements.applyButton) {
            qwenSettingsElements.applyButton.addEventListener("click", () => {
                applyQwenSettings().catch((err) => console.error("Failed to apply Qwen settings", err));
            });
        }
        if (backendFuzzerElements.runButton) {
            backendFuzzerElements.runButton.addEventListener("click", () => {
                runBackendFuzzer().catch((err) => console.error("Backend fuzzer failed", err));
            });
        }
        refreshQwenSettings().catch(() => {});
    }

    function setSettingsStatus(message, variant = "info") {
        if (!settingsElements.status) {
            return;
        }
        settingsElements.status.textContent = message || "";
        settingsElements.status.className = variant ? `settings-status ${variant}` : "settings-status";
    }

    function setQwenSettingsStatus(message, variant = "info") {
        if (!qwenSettingsElements.status) {
            return;
        }
        qwenSettingsElements.status.textContent = message || "";
        qwenSettingsElements.status.className = variant ? `settings-status ${variant}` : "settings-status";
    }

    async function refreshQwenSettings() {
        if (!qwenSettingsElements.trustRemoteCode || !qwenSettingsElements.applyButton) {
            return;
        }
        qwenSettingsElements.applyButton.disabled = true;
        setQwenSettingsStatus("Loading Qwen settings…", "info");
        try {
            const resp = await fetch(`${API_ROOT}/qwen/settings`);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const payload = await resp.json();
            qwenSettingsElements.trustRemoteCode.checked = Boolean(payload?.trust_remote_code);
            setQwenSettingsStatus("Qwen settings loaded.", "success");
        } catch (err) {
            console.warn("Qwen settings unavailable", err);
            qwenSettingsElements.trustRemoteCode.checked = false;
            qwenSettingsElements.trustRemoteCode.disabled = true;
            qwenSettingsElements.applyButton.disabled = true;
            setQwenSettingsStatus("Qwen settings not available on this backend.", "warn");
            return;
        }
        qwenSettingsElements.trustRemoteCode.disabled = false;
        qwenSettingsElements.applyButton.disabled = false;
    }

    async function applyQwenSettings() {
        if (!qwenSettingsElements.trustRemoteCode || !qwenSettingsElements.applyButton) {
            return;
        }
        qwenSettingsElements.applyButton.disabled = true;
        setQwenSettingsStatus("Applying Qwen settings…", "info");
        try {
            const resp = await fetch(`${API_ROOT}/qwen/settings`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    trust_remote_code: Boolean(qwenSettingsElements.trustRemoteCode.checked),
                }),
            });
            if (!resp.ok) {
                const text = await resp.text();
                throw new Error(text || `HTTP ${resp.status}`);
            }
            const payload = await resp.json();
            qwenSettingsElements.trustRemoteCode.checked = Boolean(payload?.trust_remote_code);
            setQwenSettingsStatus("Qwen settings updated (models unloaded).", "success");
        } catch (err) {
            console.error("Failed to update Qwen settings", err);
            setQwenSettingsStatus("Failed to update Qwen settings.", "warn");
        } finally {
            qwenSettingsElements.applyButton.disabled = false;
        }
    }

    async function runBackendFuzzer() {
        if (!backendFuzzerElements.runButton || !backendFuzzerElements.status || !backendFuzzerElements.log) {
            return;
        }
        backendFuzzerElements.runButton.disabled = true;
        backendFuzzerElements.status.textContent = "Running fuzzer…";
        backendFuzzerElements.log.textContent = "";
        const includeQwen = Boolean(backendFuzzerElements.includeQwen?.checked);
        const includeSam3 = Boolean(backendFuzzerElements.includeSam3?.checked);
        const includeClip = Boolean(backendFuzzerElements.includeClip?.checked);
        const includeAgent = Boolean(backendFuzzerElements.includeAgent?.checked);
        const tests = [];
        const addLog = (line) => {
            backendFuzzerElements.log.textContent += `${line}\n`;
        };
        const randomImage = () => {
            const canvasEl = document.createElement("canvas");
            canvasEl.width = 96;
            canvasEl.height = 96;
            const ctx = canvasEl.getContext("2d");
            ctx.fillStyle = "#fff";
            ctx.fillRect(0, 0, 96, 96);
            for (let i = 0; i < 20; i++) {
                ctx.fillStyle = `hsl(${Math.random() * 360},80%,60%)`;
                ctx.fillRect(Math.random() * 80, Math.random() * 80, 8 + Math.random() * 8, 8 + Math.random() * 8);
            }
            const dataUrl = canvasEl.toDataURL("image/png");
            return dataUrl.split(",")[1];
        };
        const baseImage = randomImage();
        const addTest = (name, fn) => tests.push({ name, fn });
        addTest("Settings ping", async () => {
            await testApiRootCandidate(API_ROOT);
        });
        if (includeClip) {
            addTest("CLIP backbones list", async () => {
                const resp = await fetch(`${API_ROOT}/clip/backbones`);
                if (!resp.ok) throw new Error(await resp.text());
            });
        }
        addTest("SAM point (sam1)", async () => {
            const payload = {
                point_x: 32,
                point_y: 32,
                image_base64: baseImage,
                sam_variant: "sam1",
            };
            const resp = await fetch(`${API_ROOT}/sam_point`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) throw new Error(await resp.text());
        });
        addTest("SAM point multi (sam1)", async () => {
            const payload = {
                positive_points: [[20, 20], [60, 60]],
                negative_points: [],
                image_base64: baseImage,
                sam_variant: "sam1",
            };
            const resp = await fetch(`${API_ROOT}/sam_point_multi`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) throw new Error(await resp.text());
        });
        if (includeQwen) {
            addTest("Qwen infer (bbox)", async () => {
                const payload = {
                    prompt: "a colorful object",
                    image_base64: baseImage,
                    prompt_type: "bbox",
                    max_results: 3,
                };
                const resp = await fetch(`${API_ROOT}/qwen/infer`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                });
                if (!resp.ok) throw new Error(await resp.text());
            });
        }
        if (includeSam3) {
            addTest("SAM3 text prompt", async () => {
                const payload = {
                    text_prompt: "object",
                    threshold: 0.3,
                    mask_threshold: 0.5,
                    max_results: 5,
                    min_size: 0,
                    simplify_epsilon: 1.0,
                    image_base64: baseImage,
                    sam_variant: "sam3",
                };
                const resp = await fetch(`${API_ROOT}/sam3/text_prompt`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(payload),
                });
                if (!resp.ok) throw new Error(await resp.text());
            });
        }
        if (includeAgent) {
            addTest("Agent Mining cache size", async () => {
                const resp = await fetch(`${API_ROOT}/agent_mining/cache_size`);
                if (!resp.ok) throw new Error(await resp.text());
            });
            addTest("Agent recipes list", async () => {
                const resp = await fetch(`${API_ROOT}/agent_mining/recipes`);
                if (!resp.ok) throw new Error(await resp.text());
            });
            if (includeSam3) {
                addTest("Agent apply_image (minimal recipe)", async () => {
                    const payload = {
                        image_base64: baseImage,
                        sam_variant: "sam3",
                        recipe: {
                            mode: "sam3_greedy",
                            text_prompts: ["object"],
                            params: { use_clip_fp_guard: false, seed_threshold: 0.2, expand_threshold: 0.2, max_visual_seeds: 3 },
                        },
                        mask_threshold: 0.5,
                        min_size: 0,
                        simplify_epsilon: 1.0,
                        max_results: 10,
                    };
                    const resp = await fetch(`${API_ROOT}/agent_mining/apply_image`, {
                        method: "POST",
                        headers: { "Content-Type": "application/json" },
                        body: JSON.stringify(payload),
                    });
                    if (!resp.ok) throw new Error(await resp.text());
                });
            }
        }
        let failures = 0;
        for (const test of tests) {
            addLog(`▶ ${test.name}`);
            try {
                await test.fn();
                addLog(`✔ ${test.name}`);
            } catch (err) {
                failures += 1;
                addLog(`✖ ${test.name}: ${err?.message || err}`);
            }
        }
        backendFuzzerElements.status.textContent = failures === 0 ? "Fuzzer finished: all tests passed" : `Fuzzer finished: ${failures} failed`;
        backendFuzzerElements.status.className = failures === 0 ? "settings-status success" : "settings-status warn";
        backendFuzzerElements.runButton.disabled = false;
    }

    function initQwenPanel() {
        qwenElements.statusLabel = document.getElementById("qwenStatusLabel");
        qwenElements.itemsInput = document.getElementById("qwenItems");
        qwenElements.manualPrompt = document.getElementById("qwenCustomPrompt");
        qwenElements.imageTypeInput = document.getElementById("qwenImageType");
        qwenElements.extraContextInput = document.getElementById("qwenExtraContext");
        qwenElements.advancedToggle = document.getElementById("qwenAdvancedToggle");
        qwenElements.advancedPanel = document.getElementById("qwenAdvancedPanel");
        qwenElements.classSelect = document.getElementById("qwenClassSelect");
        qwenElements.promptType = document.getElementById("qwenPromptType");
        qwenElements.maxResults = document.getElementById("qwenMaxResults");
        qwenElements.runButton = document.getElementById("qwenRunButton");
        qwenElements.captionHint = document.getElementById("qwenCaptionHint");
        qwenElements.captionPreset = document.getElementById("qwenCaptionPreset");
        qwenElements.captionPresetApply = document.getElementById("qwenCaptionPresetApply");
        qwenElements.captionPresetRandom = document.getElementById("qwenCaptionPresetRandom");
        qwenElements.captionStyleList = document.getElementById("qwenCaptionStyleList");
        qwenElements.captionStyleInspiration = document.getElementById("qwenCaptionStyleInspiration");
        qwenElements.captionVaryOpening = document.getElementById("qwenCaptionVaryOpening");
        qwenElements.captionOpeningList = document.getElementById("qwenCaptionOpeningList");
        qwenElements.captionMode = document.getElementById("qwenCaptionMode");
        qwenElements.captionWindowSize = document.getElementById("qwenCaptionWindowSize");
        qwenElements.captionWindowOverlap = document.getElementById("qwenCaptionWindowOverlap");
        qwenElements.captionModel = document.getElementById("qwenCaptionModel");
        qwenElements.captionVariant = document.getElementById("qwenCaptionVariant");
        qwenElements.captionMaxTokens = document.getElementById("qwenCaptionMaxTokens");
        qwenElements.captionMaxBoxes = document.getElementById("qwenCaptionMaxBoxes");
        qwenElements.captionIncludeCounts = document.getElementById("qwenCaptionIncludeCounts");
        qwenElements.captionIncludeCoords = document.getElementById("qwenCaptionIncludeCoords");
        qwenElements.captionFinalOnly = document.getElementById("qwenCaptionFinalOnly");
        qwenElements.captionTwoStage = document.getElementById("qwenCaptionTwoStage");
        qwenElements.captionHighVram = document.getElementById("qwenCaptionHighVram");
        qwenElements.captionSaveText = document.getElementById("qwenCaptionSaveText");
        qwenElements.captionRunButton = document.getElementById("qwenCaptionRunButton");
        qwenElements.captionOutput = document.getElementById("qwenCaptionOutput");
        qwenElements.captionCopyButton = document.getElementById("qwenCaptionCopy");
        qwenElements.captionMeta = document.getElementById("qwenCaptionMeta");
        qwenElements.captionStatus = document.getElementById("qwenCaptionStatus");
        qwenElements.captionBatchCount = document.getElementById("qwenCaptionBatchCount");
        qwenElements.captionBatchIncludeCurrent = document.getElementById("qwenCaptionBatchIncludeCurrent");
        qwenElements.captionBatchOverwrite = document.getElementById("qwenCaptionBatchOverwrite");
        qwenElements.captionBatchRun = document.getElementById("qwenCaptionBatchRun");
        qwenElements.captionBatchRunAll = document.getElementById("qwenCaptionBatchRunAll");
        qwenElements.captionBatchCancel = document.getElementById("qwenCaptionBatchCancel");
        qwenElements.captionDownloadJsonl = document.getElementById("qwenCaptionDownloadJsonl");
        qwenElements.unloadOthers = document.getElementById("qwenUnloadOthers");
        if (qwenElements.captionModel) {
            qwenElements.captionModel.addEventListener("change", () => {
                const selected = qwenElements.captionModel.value;
                if (selected && selected !== "active") {
                    warnIfFp8Unsupported(selected);
                }
            });
        }
        if (qwenElements.captionPreset) {
            qwenElements.captionPreset.innerHTML = "";
            CAPTION_PRESETS.forEach((preset) => {
                const option = document.createElement("option");
                option.value = preset.id;
                option.textContent = preset.label;
                qwenElements.captionPreset.appendChild(option);
            });
            qwenElements.captionPreset.value = CAPTION_PRESETS[0].id;
        }
        if (qwenElements.captionStyleList && !qwenElements.captionStyleList.value.trim()) {
            qwenElements.captionStyleList.value = DEFAULT_CAPTION_STYLE_LINES.join("\n");
        }
        if (qwenElements.captionOpeningList && !qwenElements.captionOpeningList.value.trim()) {
            qwenElements.captionOpeningList.value = JSON.stringify(DEFAULT_CAPTION_OPENERS, null, 2);
        }
        if (qwenElements.captionWindowSize && !qwenElements.captionWindowSize.value.trim()) {
            qwenElements.captionWindowSize.value = DEFAULT_CAPTION_WINDOW_SIZE;
        }
        if (qwenElements.captionWindowOverlap && !qwenElements.captionWindowOverlap.value.trim()) {
            qwenElements.captionWindowOverlap.value = DEFAULT_CAPTION_WINDOW_OVERLAP;
        }
        if (qwenElements.captionMode) {
            qwenElements.captionMode.addEventListener("change", () => {
                updateCaptionWindowMode();
            });
            updateCaptionWindowMode();
        }
        if (qwenElements.captionPresetApply) {
            qwenElements.captionPresetApply.addEventListener("click", () => {
                applyCaptionPreset({ randomize: false });
            });
        }
        if (qwenElements.captionPresetRandom) {
            qwenElements.captionPresetRandom.addEventListener("click", () => {
                applyCaptionPreset({ randomize: true });
            });
        }
        if (qwenElements.runButton) {
            qwenElements.runButton.addEventListener("click", () => {
                handleQwenRun().catch((error) => {
                    console.error("Qwen request failed", error);
                });
            });
        }
        if (qwenElements.captionRunButton) {
            qwenElements.captionRunButton.addEventListener("click", () => {
                handleQwenCaption().catch((error) => {
                    console.error("Qwen caption request failed", error);
                });
            });
        }
        if (qwenElements.captionCopyButton) {
            qwenElements.captionCopyButton.addEventListener("click", async () => {
                const caption = qwenElements.captionOutput?.value || "";
                if (!caption) {
                    setSamStatus("No caption to copy yet.", { variant: "warn", duration: 2500 });
                    return;
                }
                try {
                    await navigator.clipboard.writeText(caption);
                    setSamStatus("Caption copied to clipboard.", { variant: "success", duration: 2500 });
                } catch (error) {
                    setSamStatus("Unable to copy caption.", { variant: "warn", duration: 2500 });
                }
            });
        }
        if (qwenElements.captionBatchRun) {
            qwenElements.captionBatchRun.addEventListener("click", () => {
                const count = parseInt(qwenElements.captionBatchCount?.value || "0", 10);
                if (!count || count <= 0) {
                    setSamStatus("Enter how many images to caption.", { variant: "warn", duration: 3000 });
                    return;
                }
                const imageNames = getCaptionImageList();
                const startIndex = imageListIndex >= 0 ? imageListIndex : 0;
                const includeCurrent = !!qwenElements.captionBatchIncludeCurrent?.checked;
                const sliceStart = includeCurrent ? startIndex : startIndex + 1;
                const batch = imageNames.slice(sliceStart, sliceStart + count);
                runQwenCaptionBatch(batch, {
                    includeCurrent,
                    overwrite: !!qwenElements.captionBatchOverwrite?.checked,
                });
            });
        }
        if (qwenElements.captionBatchRunAll) {
            qwenElements.captionBatchRunAll.addEventListener("click", () => {
                const imageNames = getCaptionImageList();
                if (!imageNames.length) {
                    setSamStatus("No images loaded.", { variant: "warn", duration: 3000 });
                    return;
                }
                if (!confirm(`Caption all ${imageNames.length} images? This can take a while.`)) {
                    return;
                }
                runQwenCaptionBatch(imageNames, {
                    includeCurrent: true,
                    overwrite: !!qwenElements.captionBatchOverwrite?.checked,
                });
            });
        }
        if (qwenElements.captionBatchCancel) {
            qwenElements.captionBatchCancel.addEventListener("click", () => {
                qwenCaptionBatchCancel = true;
                setQwenCaptionStatus("Batch cancel requested");
            });
        }
        if (qwenElements.captionDownloadJsonl) {
            qwenElements.captionDownloadJsonl.addEventListener("click", () => {
                downloadCaptionJsonl();
            });
        }
        if (qwenElements.classSelect) {
            qwenElements.classSelect.addEventListener("change", () => {
                qwenClassOverride = true;
            });
        }
        if (qwenElements.advancedToggle) {
            qwenElements.advancedToggle.addEventListener("click", () => toggleQwenAdvanced());
        }
        toggleQwenAdvanced(false);
        applyActiveQwenMetadata(qwenModelState.activeMetadata);
        updateQwenRunButton();
        updateQwenCaptionButton();
        setQwenCaptionStatus("Idle");
        updateQwenClassOptions({ resetOverride: true });
        initSam3TextUi();
        updateSam3TextButtons();
        refreshQwenStatus({ silent: true }).catch((error) => {
            console.debug("Unable to query Qwen status", error);
        });
    }

    function setQwenStatusLabel(message, state = "info") {
        if (!qwenElements.statusLabel) {
            return;
        }
        qwenElements.statusLabel.textContent = message;
        qwenElements.statusLabel.classList.remove("qwen-status-label--ready", "qwen-status-label--error");
        if (state === "ready") {
            qwenElements.statusLabel.classList.add("qwen-status-label--ready");
        } else if (state === "error") {
            qwenElements.statusLabel.classList.add("qwen-status-label--error");
        }
    }

    function initSam3TextUi() {
        if (sam3TextUiInitialized) {
            return;
        }
        sam3TextUiInitialized = true;
        sam3TextElements.panel = document.getElementById("sam3TextPanel");
        sam3TextElements.promptInput = document.getElementById("sam3TextPrompt");
        sam3TextElements.thresholdInput = document.getElementById("sam3Threshold");
        sam3TextElements.maskThresholdInput = document.getElementById("sam3MaskThreshold");
        sam3TextElements.maxResultsInput = document.getElementById("sam3MaxResults");
        sam3TextElements.minSizeInput = document.getElementById("sam3MinSize");
        sam3TextElements.maxPointsInput = document.getElementById("sam3MaxPoints");
        sam3TextElements.epsilonInput = document.getElementById("sam3SimplifyEpsilon");
        sam3TextElements.classSelect = document.getElementById("sam3ClassSelect");
        sam3TextElements.runButton = document.getElementById("sam3RunButton");
        sam3TextElements.cascadeToggleButton = document.getElementById("sam3TextCascadeToggle");
        sam3TextElements.cascadePanel = document.getElementById("sam3TextCascadePanel");
        sam3TextElements.cascadeSteps = document.getElementById("sam3TextCascadeSteps");
        sam3TextElements.cascadeAddButton = document.getElementById("sam3TextCascadeAdd");
        sam3TextElements.cascadeRunButton = document.getElementById("sam3TextCascadeRun");
        sam3TextElements.cascadeStopButton = document.getElementById("sam3TextCascadeStop");
        sam3TextElements.cascadeClearButton = document.getElementById("sam3TextCascadeClear");
        sam3TextElements.batchCountInput = document.getElementById("sam3BatchCount");
        sam3TextElements.batchIncludeCurrentToggle = document.getElementById("sam3BatchIncludeCurrent");
        sam3TextElements.batchRunButton = document.getElementById("sam3BatchRunButton");
        sam3TextElements.batchStopButton = document.getElementById("sam3BatchStopButton");
        sam3TextElements.similarityButton = document.getElementById("sam3SimilarityButton");
        sam3TextElements.similarityRow = document.getElementById("sam3SimilarityRow");
        sam3TextElements.similarityThresholdInput = document.getElementById("sam3SimilarityThreshold");
        sam3TextElements.status = document.getElementById("sam3TextStatus");
        sam3RecipeElements.fileInput = document.getElementById("sam3RecipeFile");
        sam3RecipeElements.status = document.getElementById("sam3RecipeStatus");
        sam3RecipeElements.recipeRefreshButton = document.getElementById("sam3RecipePresetRefresh");
        sam3RecipeElements.cascadeSteps = document.getElementById("sam3CascadeSteps");
        sam3RecipeElements.cascadeAddStepButton = document.getElementById("sam3CascadeAddStep");
        sam3RecipeElements.perClassIouInput = document.getElementById("sam3CascadePerClassIou");
        sam3RecipeElements.crossDedupeToggle = document.getElementById("sam3CascadeCrossDedupeToggle");
        sam3RecipeElements.crossScopeSelect = document.getElementById("sam3CascadeCrossScope");
        sam3RecipeElements.crossIouInput = document.getElementById("sam3CascadeCrossIou");
        sam3RecipeElements.confidenceSelect = document.getElementById("sam3CascadeConfidence");
        sam3RecipeElements.clipHeadSourceSelect = document.getElementById("sam3CascadeClipHeadSource");
        sam3RecipeElements.cascadePresetSelect = document.getElementById("sam3CascadePresetSelect");
        sam3RecipeElements.cascadePresetNameInput = document.getElementById("sam3CascadePresetName");
        sam3RecipeElements.cascadePresetRefreshButton = document.getElementById("sam3CascadePresetRefresh");
        sam3RecipeElements.cascadePresetSaveButton = document.getElementById("sam3CascadePresetSave");
        sam3RecipeElements.cascadePresetLoadButton = document.getElementById("sam3CascadePresetLoad");
        sam3RecipeElements.cascadePresetDeleteButton = document.getElementById("sam3CascadePresetDelete");
        sam3RecipeElements.cascadePresetExportButton = document.getElementById("sam3CascadePresetExport");
        sam3RecipeElements.cascadeFileInput = document.getElementById("sam3CascadeFile");
        sam3RecipeElements.cascadeApplyButton = document.getElementById("sam3CascadeApplyButton");
        if (sam3TextElements.runButton) {
            sam3TextElements.runButton.addEventListener("click", () => handleSam3TextRequest());
        }
        if (sam3TextElements.cascadeToggleButton) {
            sam3TextElements.cascadeToggleButton.addEventListener("click", () => toggleSam3TextCascade());
        }
        if (sam3TextElements.cascadeAddButton) {
            sam3TextElements.cascadeAddButton.addEventListener("click", () => addSam3TextCascadeStep());
        }
        if (sam3TextElements.cascadeRunButton) {
            sam3TextElements.cascadeRunButton.addEventListener("click", () => runSam3TextCascade());
        }
        if (sam3TextElements.cascadeStopButton) {
            sam3TextElements.cascadeStopButton.addEventListener("click", () => stopSam3TextCascade());
        }
        if (sam3TextElements.cascadeClearButton) {
            sam3TextElements.cascadeClearButton.addEventListener("click", () => clearSam3TextCascade());
        }
        if (sam3TextElements.batchRunButton) {
            sam3TextElements.batchRunButton.addEventListener("click", () => startSam3TextBatch());
        }
        if (sam3TextElements.batchStopButton) {
            sam3TextElements.batchStopButton.addEventListener("click", () => stopSam3TextBatch());
        }
        if (sam3TextElements.similarityButton) {
            sam3TextElements.similarityButton.addEventListener("click", handleSam3SimilarityPrompt);
        }
        setSam3TextCascadeEnabled(false);
        if (sam3RecipeElements.fileInput) {
            sam3RecipeElements.fileInput.addEventListener("change", handleSam3RecipeFile);
        }
        if (sam3RecipeElements.recipeRefreshButton) {
            sam3RecipeElements.recipeRefreshButton.addEventListener("click", () => {
                loadSam3RecipePresets().catch((err) => console.error("Refresh recipes failed", err));
            });
        }
        if (sam3RecipeElements.cascadeAddStepButton) {
            sam3RecipeElements.cascadeAddStepButton.addEventListener("click", () => {
                addSam3CascadeStep();
            });
        }
        if (sam3RecipeElements.cascadePresetRefreshButton) {
            sam3RecipeElements.cascadePresetRefreshButton.addEventListener("click", () => {
                loadSam3CascadePresets().catch((err) => console.error("Refresh cascades failed", err));
            });
        }
        if (sam3RecipeElements.cascadePresetSaveButton) {
            sam3RecipeElements.cascadePresetSaveButton.addEventListener("click", saveSam3CascadePreset);
        }
        if (sam3RecipeElements.cascadePresetLoadButton) {
            sam3RecipeElements.cascadePresetLoadButton.addEventListener("click", loadSam3CascadePreset);
        }
        if (sam3RecipeElements.cascadePresetDeleteButton) {
            sam3RecipeElements.cascadePresetDeleteButton.addEventListener("click", deleteSam3CascadePreset);
        }
        if (sam3RecipeElements.cascadePresetExportButton) {
            sam3RecipeElements.cascadePresetExportButton.addEventListener("click", exportSam3CascadePreset);
        }
        if (sam3RecipeElements.cascadePresetSelect) {
            sam3RecipeElements.cascadePresetSelect.addEventListener("change", refreshSam3CascadeControls);
        }
        if (sam3RecipeElements.cascadeFileInput) {
            sam3RecipeElements.cascadeFileInput.addEventListener("change", handleSam3CascadeFile);
        }
        if (sam3RecipeElements.cascadeApplyButton) {
            sam3RecipeElements.cascadeApplyButton.addEventListener("click", runSam3CascadeOnImage);
        }
        for (const el of [
            sam3RecipeElements.perClassIouInput,
            sam3RecipeElements.crossDedupeToggle,
            sam3RecipeElements.crossScopeSelect,
            sam3RecipeElements.crossIouInput,
            sam3RecipeElements.confidenceSelect,
            sam3RecipeElements.clipHeadSourceSelect,
        ]) {
            if (el) {
                el.addEventListener("change", refreshSam3CascadeControls);
            }
        }
        updateSam3ClassOptions({ resetOverride: true });
        updateSam3TextButtons();
        if (!Array.isArray(sam3CascadeState.steps) || sam3CascadeState.steps.length === 0) {
            sam3CascadeState.steps = [createSam3CascadeStep({})];
        }
        renderSam3CascadeSteps();
        refreshSam3CascadeControls();
        loadSam3RecipePresets().catch((err) => console.error("Load recipes failed", err));
        loadSam3CascadePresets().catch((err) => console.error("Load cascades failed", err));
        loadSam3ClipClassifiers().catch((err) => console.error("Load CLIP classifiers failed", err));
    }

    function setSam3TextStatus(message, variant = "info") {
        const statusEl = sam3TextElements.status;
        if (!statusEl) {
            return;
        }
        statusEl.textContent = message || "";
        statusEl.classList.remove("warn", "error", "success");
        if (!message) {
            return;
        }
        if (variant === "warn" || variant === "error" || variant === "success") {
            statusEl.classList.add(variant);
        }
    }

	    function setSam3RecipeStatus(message, variant = "info") {
	        const statusEl = sam3RecipeElements.status;
	        if (!statusEl) return;
	        statusEl.textContent = message || "";
	        statusEl.classList.remove("warn", "error", "success");
	        if (variant === "warn" || variant === "error" || variant === "success") {
	            statusEl.classList.add(variant);
	        }
	    }

		    function createSam3CascadeStep({ recipeId = null } = {}) {
		        return {
		            uid: generateUUID(),
		            enabled: true,
		            recipe_id: recipeId || null,
		            dedupe_group: "",
		            participate_cross_class_dedupe: true,
		            override_enabled: false,
		            override_class_name: null,
		            clip_head_min_prob_override: null,
		            clip_head_margin_override: null,
		            extra_clip_classifier_path: null,
		            extra_clip_min_prob: 0.9,
		            extra_clip_margin: 0.0,
		        };
		    }

	    function ensureAtLeastOneCascadeStep() {
	        if (!Array.isArray(sam3CascadeState.steps)) {
	            sam3CascadeState.steps = [];
	        }
	        if (sam3CascadeState.steps.length === 0) {
	            sam3CascadeState.steps.push(createSam3CascadeStep({}));
	        }
	    }

	    function addSam3CascadeStep({ recipeId = null } = {}) {
	        ensureAtLeastOneCascadeStep();
	        let chosen = recipeId;
	        if (!chosen && Array.isArray(sam3CascadeState.recipePresets) && sam3CascadeState.recipePresets.length) {
	            chosen = sam3CascadeState.recipePresets[0].id;
	        }
	        sam3CascadeState.steps.push(createSam3CascadeStep({ recipeId: chosen }));
	        renderSam3CascadeSteps();
	        refreshSam3CascadeControls();
	    }

	    function removeSam3CascadeStep(uid) {
	        if (!Array.isArray(sam3CascadeState.steps)) {
	            return;
	        }
	        sam3CascadeState.steps = sam3CascadeState.steps.filter((s) => s && s.uid !== uid);
	        ensureAtLeastOneCascadeStep();
	        renderSam3CascadeSteps();
	        refreshSam3CascadeControls();
	    }

	    function moveSam3CascadeStep(uid, direction) {
	        if (!Array.isArray(sam3CascadeState.steps) || sam3CascadeState.steps.length < 2) {
	            return;
	        }
	        const idx = sam3CascadeState.steps.findIndex((s) => s && s.uid === uid);
	        if (idx < 0) return;
	        const next = idx + direction;
	        if (next < 0 || next >= sam3CascadeState.steps.length) return;
	        const copy = [...sam3CascadeState.steps];
	        const tmp = copy[idx];
	        copy[idx] = copy[next];
	        copy[next] = tmp;
	        sam3CascadeState.steps = copy;
	        renderSam3CascadeSteps();
	        refreshSam3CascadeControls();
	    }

	    function recipeHasClipHeadConfig(recipe) {
	        const raw = recipe?.raw;
	        if (!raw || typeof raw !== "object") {
	            return false;
	        }
	        if (raw.clip_head && typeof raw.clip_head === "object") {
	            return true;
	        }
	        if (raw.recipe && typeof raw.recipe === "object" && raw.recipe.clip_head && typeof raw.recipe.clip_head === "object") {
	            return true;
	        }
	        return false;
	    }

	    function refreshSam3CascadeClipHeadSourceOptions({ preserveSelection = false } = {}) {
	        const select = sam3RecipeElements.clipHeadSourceSelect;
	        if (!select) return;
	        const previous = preserveSelection ? select.value : "";
	        select.innerHTML = "";
	        const autoOpt = document.createElement("option");
	        autoOpt.value = "";
	        autoOpt.textContent = "Auto (first recipe with head)";
	        select.appendChild(autoOpt);
	        (Array.isArray(sam3CascadeState.recipePresets) ? sam3CascadeState.recipePresets : []).forEach((r) => {
	            if (!r?.id) return;
	            const opt = document.createElement("option");
	            opt.value = r.id;
	            const cls = r.class_name ? ` • ${r.class_name}` : "";
	            const head = recipeHasClipHeadConfig(r) ? " • head" : "";
	            opt.textContent = `${r.label || r.id}${cls}${head}`;
	            select.appendChild(opt);
	        });
	        if (preserveSelection) {
	            const values = Array.from(select.options).map((o) => o.value);
	            if (values.includes(previous)) {
	                select.value = previous;
	            }
	        }
	    }

	    function findClassNameById(id) {
	        if (typeof id !== "number" || !Number.isFinite(id)) {
	            return null;
	        }
	        for (const [name, cid] of Object.entries(classes || {})) {
	            if (cid === id) {
	                return name;
	            }
	        }
	        return null;
	    }

	    function populateSelectOptions(select, options, value, placeholder) {
	        if (!select) return;
	        select.innerHTML = "";
	        if (placeholder) {
	            const opt = document.createElement("option");
	            opt.value = "";
	            opt.textContent = placeholder;
	            select.appendChild(opt);
	        }
	        (options || []).forEach((entry) => {
	            const opt = document.createElement("option");
	            opt.value = entry.value;
	            opt.textContent = entry.label;
	            select.appendChild(opt);
	        });
	        if (typeof value === "string") {
	            select.value = value;
	        }
	    }

		    function renderSam3CascadeSteps() {
		        const root = sam3RecipeElements.cascadeSteps;
		        if (!root) return;
		        ensureAtLeastOneCascadeStep();
		        root.innerHTML = "";

	        const recipes = Array.isArray(sam3CascadeState.recipePresets) ? sam3CascadeState.recipePresets : [];
	        const recipeOptions = recipes.map((r) => ({
	            value: r.id,
	            label: `${r.label || r.id}${r.class_name ? ` • ${r.class_name}` : ""}`,
	        }));
	        const classNames = orderedClassNames();
	        const classOptions = classNames.map((n) => ({ value: n, label: n }));
        const clipClassifiers = Array.isArray(sam3CascadeState.clipClassifiers) ? sam3CascadeState.clipClassifiers : [];
        const clipClassifierOptions = clipClassifiers
            .filter((entry) => entry && entry.rel_path)
            .map((entry) => {
                const bits = [];
                bits.push(entry.filename || entry.rel_path);
                if (entry.n_classes) bits.push(`${entry.n_classes} classes`);
                if (entry.clip_model) bits.push(entry.clip_model);
                return { value: entry.rel_path, label: bits.join(" • ") };
            });

	        sam3CascadeState.steps.forEach((step, index) => {
	            if (!step) return;
	            const card = document.createElement("div");
	            card.className = "training-subsection";
	            card.style.marginTop = index === 0 ? "10px" : "12px";

	            const headerRow = document.createElement("div");
	            headerRow.style.display = "flex";
	            headerRow.style.alignItems = "center";
	            headerRow.style.justifyContent = "space-between";
	            headerRow.style.gap = "10px";

	            const title = document.createElement("div");
	            title.className = "training-subsection__title";
	            title.textContent = `Step ${index + 1}`;

	            const headerActions = document.createElement("div");
	            headerActions.style.display = "flex";
	            headerActions.style.flexWrap = "wrap";
	            headerActions.style.gap = "8px";
	            headerActions.style.alignItems = "center";

		            const enabledLabel = document.createElement("label");
		            enabledLabel.style.display = "inline-flex";
		            enabledLabel.style.alignItems = "center";
		            enabledLabel.style.gap = "6px";
		            enabledLabel.title = "Turn this step on/off without deleting it.";
		            const enabledToggle = document.createElement("input");
		            enabledToggle.type = "checkbox";
		            enabledToggle.checked = Boolean(step.enabled);
		            enabledToggle.addEventListener("change", () => {
		                step.enabled = enabledToggle.checked;
		                refreshSam3CascadeControls();
	            });
	            enabledLabel.appendChild(enabledToggle);
	            enabledLabel.appendChild(document.createTextNode("Enabled"));

	            const upBtn = document.createElement("button");
	            upBtn.type = "button";
	            upBtn.className = "training-button secondary";
	            upBtn.textContent = "↑";
	            upBtn.title = "Move step up";
	            upBtn.disabled = index === 0;
	            upBtn.addEventListener("click", () => moveSam3CascadeStep(step.uid, -1));

	            const downBtn = document.createElement("button");
	            downBtn.type = "button";
	            downBtn.className = "training-button secondary";
	            downBtn.textContent = "↓";
	            downBtn.title = "Move step down";
	            downBtn.disabled = index === sam3CascadeState.steps.length - 1;
	            downBtn.addEventListener("click", () => moveSam3CascadeStep(step.uid, 1));

		            const removeBtn = document.createElement("button");
		            removeBtn.type = "button";
		            removeBtn.className = "training-button danger";
		            removeBtn.textContent = "Remove";
		            removeBtn.title = "Remove this step from the cascade.";
		            removeBtn.addEventListener("click", () => removeSam3CascadeStep(step.uid));

	            headerActions.appendChild(enabledLabel);
	            headerActions.appendChild(upBtn);
	            headerActions.appendChild(downBtn);
	            headerActions.appendChild(removeBtn);
	            headerRow.appendChild(title);
	            headerRow.appendChild(headerActions);
	            card.appendChild(headerRow);

	            const grid = document.createElement("div");
	            grid.className = "training-grid agent-recipe-controls";
	            grid.style.marginTop = "8px";

	            const recipeWrap = document.createElement("div");
		            const recipeLabel = document.createElement("label");
		            recipeLabel.textContent = "Recipe";
		            recipeLabel.title = "Choose which saved recipe runs in this step.";
		            const recipeSelect = document.createElement("select");
		            recipeSelect.title = "Pick a recipe. You can chain multiple recipes and de-dupe the results.";
		            populateSelectOptions(recipeSelect, recipeOptions, step.recipe_id || "", recipes.length ? "Select recipe…" : "No recipes loaded");
		            recipeSelect.disabled = recipes.length === 0;
		            recipeSelect.addEventListener("change", () => {
		                step.recipe_id = recipeSelect.value || null;
		                refreshSam3CascadeControls();
	            });
	            recipeWrap.appendChild(recipeLabel);
	            recipeWrap.appendChild(recipeSelect);

		            const groupWrap = document.createElement("div");
		            const groupLabel = document.createElement("label");
		            groupLabel.textContent = "Dedupe group";
		            groupLabel.title =
		                "Used for cross-class de-dupe: overlapping detections in the same group can suppress each other (e.g. car/truck/bus = vehicles).";
		            const groupInput = document.createElement("input");
		            groupInput.type = "text";
		            groupInput.placeholder = "e.g. vehicles";
		            groupInput.title =
		                "Optional. Only affects cross-class de-dupe. Use different groups to prevent suppressing valid overlaps (e.g. person vs bike).";
		            groupInput.value = step.dedupe_group || "";
		            groupInput.addEventListener("input", () => {
		                step.dedupe_group = groupInput.value;
		            });
	            groupWrap.appendChild(groupLabel);
	            groupWrap.appendChild(groupInput);

	            const crossWrap = document.createElement("div");
		            const crossLabel = document.createElement("label");
		            crossLabel.style.display = "inline-flex";
		            crossLabel.style.alignItems = "center";
		            crossLabel.style.gap = "6px";
		            crossLabel.title =
		                "If cross-class de-dupe is enabled, steps that participate can suppress overlaps within the same group. Turn this off for classes that should overlap (e.g. person on bike).";
		            const crossToggle = document.createElement("input");
		            crossToggle.type = "checkbox";
		            crossToggle.checked = step.participate_cross_class_dedupe !== false;
		            crossToggle.addEventListener("change", () => {
		                step.participate_cross_class_dedupe = crossToggle.checked;
		            });
		            crossLabel.appendChild(crossToggle);
		            crossLabel.appendChild(document.createTextNode("Allow cross-class de-dupe"));
		            crossWrap.appendChild(crossLabel);

		            const overrideWrap = document.createElement("div");
		            const overrideLabel = document.createElement("label");
		            overrideLabel.style.display = "inline-flex";
		            overrideLabel.style.alignItems = "center";
		            overrideLabel.style.gap = "6px";
		            overrideLabel.title =
		                "Relabel outputs from this step. This does not change what the recipe detects; it only changes which class the detections are assigned to.";
		            const overrideToggle = document.createElement("input");
		            overrideToggle.type = "checkbox";
		            overrideToggle.checked = Boolean(step.override_enabled);
		            const overrideSelect = document.createElement("select");
		            overrideSelect.title = "Pick the class to assign detections to when override is enabled.";
		            populateSelectOptions(
		                overrideSelect,
		                classOptions,
		                step.override_class_name || "",
	                classOptions.length ? "Select class…" : "Load classes first",
	            );
	            overrideSelect.disabled = !overrideToggle.checked || classOptions.length === 0;
	            overrideToggle.addEventListener("change", () => {
	                step.override_enabled = overrideToggle.checked;
	                if (!step.override_enabled) {
	                    step.override_class_name = null;
	                } else if (!step.override_class_name) {
	                    step.override_class_name = overrideSelect.value || (classOptions[0] ? classOptions[0].value : null);
	                    if (step.override_class_name) {
	                        overrideSelect.value = step.override_class_name;
	                    }
	                }
	                overrideSelect.disabled = !step.override_enabled || classOptions.length === 0;
	            });
	            overrideSelect.addEventListener("change", () => {
	                step.override_class_name = overrideSelect.value || null;
	            });
	            overrideLabel.appendChild(overrideToggle);
		            overrideLabel.appendChild(document.createTextNode("Override output class"));
		            overrideWrap.appendChild(overrideLabel);
		            overrideWrap.appendChild(overrideSelect);

		            const clipMinWrap = document.createElement("div");
		            const clipMinLabel = document.createElement("label");
		            clipMinLabel.textContent = "Extra CLIP min prob";
		            clipMinLabel.title =
		                "Optional: apply an extra CLIP-head probability check for this step.\n" +
		                "This is cumulative with the recipe's baked-in CLIP head thresholds.\n" +
		                "Effective min prob = max(recipe min prob, this value).\n" +
		                "Only applies to recipes that include an embedded pretrained CLIP head.";
		            const clipMinInput = document.createElement("input");
		            clipMinInput.type = "number";
		            clipMinInput.step = "0.05";
		            clipMinInput.min = "0";
		            clipMinInput.max = "1";
		            clipMinInput.placeholder = "(use recipe)";
		            clipMinInput.title = clipMinLabel.title;
		            clipMinInput.value =
		                typeof step.clip_head_min_prob_override === "number" && Number.isFinite(step.clip_head_min_prob_override)
		                    ? String(step.clip_head_min_prob_override)
		                    : "";
		            clipMinInput.addEventListener("input", () => {
		                step.clip_head_min_prob_override = clamp01(clipMinInput.value, null);
		            });
		            clipMinWrap.appendChild(clipMinLabel);
		            clipMinWrap.appendChild(clipMinInput);

		            const clipMarginWrap = document.createElement("div");
		            const clipMarginLabel = document.createElement("label");
		            clipMarginLabel.textContent = "Extra CLIP margin";
		            clipMarginLabel.title =
		                "Optional: apply an extra CLIP-head margin check for this step.\n" +
		                "Margin means p(target) must beat the best other class by Δ.\n" +
		                "This is cumulative with the recipe's baked-in CLIP head thresholds.\n" +
		                "Effective margin = max(recipe margin, this value).\n" +
		                "Only applies to recipes that include an embedded pretrained CLIP head.";
		            const clipMarginInput = document.createElement("input");
		            clipMarginInput.type = "number";
		            clipMarginInput.step = "0.05";
		            clipMarginInput.min = "0";
		            clipMarginInput.max = "1";
		            clipMarginInput.placeholder = "(use recipe)";
		            clipMarginInput.title = clipMarginLabel.title;
		            clipMarginInput.value =
		                typeof step.clip_head_margin_override === "number" && Number.isFinite(step.clip_head_margin_override)
		                    ? String(step.clip_head_margin_override)
		                    : "";
		            clipMarginInput.addEventListener("input", () => {
		                step.clip_head_margin_override = clamp01(clipMarginInput.value, null);
		            });
		            clipMarginWrap.appendChild(clipMarginLabel);
		            clipMarginWrap.appendChild(clipMarginInput);

		            const extraClipModelWrap = document.createElement("div");
		            const extraClipModelLabel = document.createElement("label");
		            extraClipModelLabel.textContent = "Extra CLIP model";
		            extraClipModelLabel.title =
		                "Optional: apply an additional CLIP classifier filter after this recipe runs.\n" +
		                "This is useful for crop-bank recipes (crops-only) that do not include an embedded CLIP head.\n" +
		                "Detections must pass the recipe's own filters AND this extra classifier filter.\n" +
		                "The classifier is matched to the step's output class by name.";
		            const extraClipModelSelect = document.createElement("select");
		            extraClipModelSelect.title = extraClipModelLabel.title;
		            const clipPlaceholder = clipClassifierOptions.length ? "(none)" : "No CLIP classifiers found";
		            populateSelectOptions(extraClipModelSelect, clipClassifierOptions, step.extra_clip_classifier_path || "", clipPlaceholder);
		            extraClipModelSelect.disabled = clipClassifierOptions.length === 0;
		            extraClipModelWrap.appendChild(extraClipModelLabel);
		            extraClipModelWrap.appendChild(extraClipModelSelect);

		            const extraClipThresholdWrap = document.createElement("div");
		            const extraClipThresholdLabel = document.createElement("label");
		            extraClipThresholdLabel.textContent = "Extra CLIP threshold";
		            extraClipThresholdLabel.title =
		                "Extra CLIP classifier filter threshold.\n" +
		                "Higher = cleaner (fewer false positives), but can miss objects.\n" +
		                "Only used when an Extra CLIP model is selected.";
		            const extraClipThresholdRow = document.createElement("div");
		            extraClipThresholdRow.style.display = "flex";
		            extraClipThresholdRow.style.alignItems = "center";
		            extraClipThresholdRow.style.gap = "8px";
		            const extraClipThresholdLow = document.createElement("span");
		            extraClipThresholdLow.className = "training-help";
		            extraClipThresholdLow.style.whiteSpace = "nowrap";
		            extraClipThresholdLow.textContent = "More (noisier)";
		            const extraClipThresholdInput = document.createElement("input");
		            extraClipThresholdInput.type = "range";
		            extraClipThresholdInput.min = "0";
		            extraClipThresholdInput.max = "1";
		            extraClipThresholdInput.step = "0.01";
		            extraClipThresholdInput.style.flex = "1";
		            const initialExtraThr =
		                typeof step.extra_clip_min_prob === "number" && Number.isFinite(step.extra_clip_min_prob) ? step.extra_clip_min_prob : 0.9;
		            extraClipThresholdInput.value = String(Math.min(1, Math.max(0, initialExtraThr)));
		            extraClipThresholdInput.disabled = !step.extra_clip_classifier_path;
		            extraClipThresholdInput.title = extraClipThresholdLabel.title;
		            const extraClipThresholdHigh = document.createElement("span");
		            extraClipThresholdHigh.className = "training-help";
		            extraClipThresholdHigh.style.whiteSpace = "nowrap";
		            extraClipThresholdHigh.textContent = "Cleaner";
		            extraClipThresholdRow.appendChild(extraClipThresholdLow);
		            extraClipThresholdRow.appendChild(extraClipThresholdInput);
		            extraClipThresholdRow.appendChild(extraClipThresholdHigh);
		            const extraClipThresholdValue = document.createElement("div");
		            extraClipThresholdValue.className = "training-help";
		            const updateExtraThrLabel = () => {
		                const val = parseFloat(extraClipThresholdInput.value);
		                extraClipThresholdValue.textContent = Number.isFinite(val) ? `Threshold: ${val.toFixed(2)}` : "";
		            };
		            updateExtraThrLabel();
		            extraClipThresholdInput.addEventListener("input", () => {
		                const val = parseFloat(extraClipThresholdInput.value);
		                step.extra_clip_min_prob = Number.isFinite(val) ? Math.min(1, Math.max(0, val)) : step.extra_clip_min_prob;
		                updateExtraThrLabel();
		            });
		            extraClipModelSelect.addEventListener("change", () => {
		                step.extra_clip_classifier_path = extraClipModelSelect.value || null;
		                extraClipThresholdInput.disabled = !step.extra_clip_classifier_path;
		                refreshSam3CascadeControls();
		            });
		            extraClipThresholdWrap.appendChild(extraClipThresholdLabel);
		            extraClipThresholdWrap.appendChild(extraClipThresholdRow);
		            extraClipThresholdWrap.appendChild(extraClipThresholdValue);

		            grid.appendChild(recipeWrap);
		            grid.appendChild(groupWrap);
		            grid.appendChild(crossWrap);
		            grid.appendChild(overrideWrap);
		            grid.appendChild(clipMinWrap);
		            grid.appendChild(clipMarginWrap);
		            grid.appendChild(extraClipModelWrap);
		            grid.appendChild(extraClipThresholdWrap);
		            card.appendChild(grid);

		            root.appendChild(card);
		        });
		    }

	    function clamp01(val, fallback) {
	        if (val === "" || val === null || typeof val === "undefined") {
	            return fallback;
	        }
	        const n = Number(val);
	        if (!Number.isFinite(n)) {
	            return fallback;
	        }
	        return Math.min(1, Math.max(0, n));
	    }

	    function getSam3CascadeDedupeConfig() {
	        const perClassIou = clamp01(sam3RecipeElements.perClassIouInput?.value, 0.5);
	        const crossEnabled = Boolean(sam3RecipeElements.crossDedupeToggle?.checked);
	        const crossIou = clamp01(sam3RecipeElements.crossIouInput?.value, 0.5);
	        const scopeRaw = sam3RecipeElements.crossScopeSelect?.value;
	        const crossScope = scopeRaw === "global" ? "global" : "groups";
	        const confRaw = sam3RecipeElements.confidenceSelect?.value;
	        const confidence =
	            confRaw === "clip_head_prob" || confRaw === "clip_head_margin" || confRaw === "sam_score" ? confRaw : "sam_score";
	        let clipHeadRecipeId = sam3RecipeElements.clipHeadSourceSelect?.value || null;
	        if (confidence === "sam_score") {
	            clipHeadRecipeId = null;
	        }
	        return {
	            per_class_iou: perClassIou,
	            cross_class_enabled: crossEnabled,
	            cross_class_iou: crossIou,
	            cross_class_scope: crossScope,
	            confidence,
	            clip_head_recipe_id: clipHeadRecipeId || null,
	        };
	    }

	    function applySam3CascadeDedupeConfig(cfg) {
	        if (!cfg || typeof cfg !== "object") {
	            return;
	        }
	        if (sam3RecipeElements.perClassIouInput) {
	            sam3RecipeElements.perClassIouInput.value = String(clamp01(cfg.per_class_iou, 0.5));
	        }
	        if (sam3RecipeElements.crossDedupeToggle) {
	            sam3RecipeElements.crossDedupeToggle.checked = Boolean(cfg.cross_class_enabled);
	        }
	        if (sam3RecipeElements.crossIouInput) {
	            sam3RecipeElements.crossIouInput.value = String(clamp01(cfg.cross_class_iou, 0.5));
	        }
	        if (sam3RecipeElements.crossScopeSelect) {
	            sam3RecipeElements.crossScopeSelect.value = cfg.cross_class_scope === "global" ? "global" : "groups";
	        }
	        if (sam3RecipeElements.confidenceSelect) {
	            const val = cfg.confidence;
	            sam3RecipeElements.confidenceSelect.value =
	                val === "clip_head_prob" || val === "clip_head_margin" || val === "sam_score" ? val : "sam_score";
	        }
	        refreshSam3CascadeClipHeadSourceOptions({ preserveSelection: true });
	        if (sam3RecipeElements.clipHeadSourceSelect) {
	            sam3RecipeElements.clipHeadSourceSelect.value = cfg.clip_head_recipe_id || "";
	        }
	        refreshSam3CascadeControls();
	    }

	    function refreshSam3CascadeControls() {
	        const crossEnabled = Boolean(sam3RecipeElements.crossDedupeToggle?.checked);
	        if (sam3RecipeElements.crossScopeSelect) sam3RecipeElements.crossScopeSelect.disabled = !crossEnabled;
	        if (sam3RecipeElements.crossIouInput) sam3RecipeElements.crossIouInput.disabled = !crossEnabled;
	        const conf = sam3RecipeElements.confidenceSelect?.value || "sam_score";
	        const wantsHead = conf === "clip_head_prob" || conf === "clip_head_margin";
	        if (sam3RecipeElements.clipHeadSourceSelect) {
	            sam3RecipeElements.clipHeadSourceSelect.disabled = !wantsHead;
	        }

	        const enabledSteps = (Array.isArray(sam3CascadeState.steps) ? sam3CascadeState.steps : []).filter((s) => s && s.enabled);
	        const hasAnyEnabled = enabledSteps.length > 0;
	        const missingRecipe = enabledSteps.some((s) => !s.recipe_id);
	        const hasRunnable = hasAnyEnabled && !missingRecipe;
	        if (sam3RecipeElements.cascadeApplyButton) {
	            sam3RecipeElements.cascadeApplyButton.disabled = !hasRunnable || !currentImage;
	        }
	        if (sam3RecipeElements.cascadePresetSaveButton) {
	            sam3RecipeElements.cascadePresetSaveButton.disabled = !hasRunnable;
	        }
	        if (sam3RecipeElements.cascadePresetExportButton) {
	            sam3RecipeElements.cascadePresetExportButton.disabled = !sam3RecipeElements.cascadePresetSelect?.value;
	        }
	        if (sam3RecipeElements.cascadePresetLoadButton) {
	            sam3RecipeElements.cascadePresetLoadButton.disabled = !sam3RecipeElements.cascadePresetSelect?.value;
	        }
	        if (sam3RecipeElements.cascadePresetDeleteButton) {
	            sam3RecipeElements.cascadePresetDeleteButton.disabled = !sam3RecipeElements.cascadePresetSelect?.value;
	        }
	    }

	    function applyCascadePayloadToUi(cascade) {
	        const stepsRaw = cascade?.steps;
	        const dedupeRaw = cascade?.dedupe;
	        if (Array.isArray(stepsRaw) && stepsRaw.length) {
		            sam3CascadeState.steps = stepsRaw.map((raw) => {
		                const step = createSam3CascadeStep({ recipeId: raw.recipe_id || null });
		                step.enabled = raw.enabled !== false;
		                step.dedupe_group = raw.dedupe_group || "";
		                step.participate_cross_class_dedupe = raw.participate_cross_class_dedupe !== false;
		                step.clip_head_min_prob_override = clamp01(raw.clip_head_min_prob_override, null);
		                step.clip_head_margin_override = clamp01(raw.clip_head_margin_override, null);
		                step.extra_clip_classifier_path = raw.extra_clip_classifier_path || null;
		                step.extra_clip_min_prob = clamp01(raw.extra_clip_min_prob, 0.9);
		                step.extra_clip_margin = clamp01(raw.extra_clip_margin, 0.0);
		                const overrideName = raw.override_class_name || findClassNameById(raw.override_class_id);
		                if (overrideName) {
		                    step.override_enabled = true;
		                    step.override_class_name = overrideName;
		                } else {
	                    step.override_enabled = false;
	                    step.override_class_name = null;
	                }
	                return step;
	            });
	        } else {
	            sam3CascadeState.steps = [createSam3CascadeStep({})];
	        }
	        applySam3CascadeDedupeConfig(dedupeRaw || {});
	        renderSam3CascadeSteps();
	        refreshSam3CascadeControls();
	        if (sam3RecipeElements.cascadePresetNameInput) {
	            sam3RecipeElements.cascadePresetNameInput.value = cascade?.label || "";
	        }
	    }

	    async function loadSam3CascadePresets({ preserveSelection = true } = {}) {
	        if (!sam3RecipeElements.cascadePresetSelect) return;
	        try {
	            const previous = preserveSelection ? sam3RecipeElements.cascadePresetSelect.value : "";
	            const resp = await fetch(`${API_ROOT}/agent_mining/cascades`);
	            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
	            const data = await resp.json();
	            sam3CascadeState.cascadePresets = Array.isArray(data) ? data : [];
	            const select = sam3RecipeElements.cascadePresetSelect;
	            select.innerHTML = "";
	            const placeholder = document.createElement("option");
	            placeholder.value = "";
	            placeholder.textContent = "Select cascade…";
	            select.appendChild(placeholder);
	            const seen = new Set();
	            sam3CascadeState.cascadePresets.forEach((c) => {
	                const id = c?.id;
	                if (!id || seen.has(id)) return;
	                seen.add(id);
	                const opt = document.createElement("option");
	                opt.value = id;
	                opt.textContent = c.label || id;
	                select.appendChild(opt);
	            });
	            if (preserveSelection && previous) {
	                const values = Array.from(select.options).map((o) => o.value);
	                if (values.includes(previous)) {
	                    select.value = previous;
	                }
	            }
	            refreshSam3CascadeControls();
	        } catch (err) {
	            console.error("Load cascade presets failed", err);
	            setSam3RecipeStatus("Failed to load cascade presets.", "warn");
	        }
	    }

	    async function saveSam3CascadePreset() {
	        const rawLabel = sam3RecipeElements.cascadePresetNameInput?.value || "";
	        const label = rawLabel.trim() || "recipe_cascade";
	        const classNames = orderedClassNames();
	        const stepsPayload = [];
	        const stepList = Array.isArray(sam3CascadeState.steps) ? sam3CascadeState.steps : [];
	        for (let idx = 0; idx < stepList.length; idx += 1) {
	            const step = stepList[idx];
	            if (!step) continue;
	            const rid = step.recipe_id;
	            if (!rid) {
	                if (step.enabled) {
	                    setSam3RecipeStatus(`Select a recipe for step ${idx + 1} (or disable it) before saving.`, "warn");
	                    return;
	                }
	                continue;
	            }
	            let overrideName = null;
	            let overrideId = null;
	            if (step.override_enabled) {
	                overrideName = step.override_class_name || null;
	                if (!overrideName || !classNames.includes(overrideName)) {
	                    setSam3RecipeStatus("Select a valid output class override for each enabled step.", "warn");
	                    return;
	                }
	                overrideId = typeof classes[overrideName] !== "undefined" ? classes[overrideName] : null;
	            }
		            stepsPayload.push({
		                enabled: step.enabled !== false,
		                recipe_id: rid,
		                override_class_id: overrideId,
		                override_class_name: overrideName,
		                dedupe_group: step.dedupe_group || "",
		                participate_cross_class_dedupe: step.participate_cross_class_dedupe !== false,
		                clip_head_min_prob_override:
		                    typeof step.clip_head_min_prob_override === "number" && Number.isFinite(step.clip_head_min_prob_override)
		                        ? step.clip_head_min_prob_override
		                        : null,
		                clip_head_margin_override:
		                    typeof step.clip_head_margin_override === "number" && Number.isFinite(step.clip_head_margin_override)
		                        ? step.clip_head_margin_override
		                        : null,
		                extra_clip_classifier_path: step.extra_clip_classifier_path || null,
		                extra_clip_min_prob:
		                    typeof step.extra_clip_min_prob === "number" && Number.isFinite(step.extra_clip_min_prob)
		                        ? step.extra_clip_min_prob
		                        : null,
		                extra_clip_margin:
		                    typeof step.extra_clip_margin === "number" && Number.isFinite(step.extra_clip_margin)
		                        ? step.extra_clip_margin
		                        : null,
		            });
		        }
	        if (!stepsPayload.some((s) => s.enabled)) {
	            setSam3RecipeStatus("Enable at least one step before saving.", "warn");
	            return;
	        }
	        const dedupe = getSam3CascadeDedupeConfig();
	        try {
	            const resp = await fetch(`${API_ROOT}/agent_mining/cascades`, {
	                method: "POST",
	                headers: { "Content-Type": "application/json" },
	                body: JSON.stringify({ label, steps: stepsPayload, dedupe }),
	            });
	            if (!resp.ok) {
	                const detail = await resp.text();
	                throw new Error(detail || `HTTP ${resp.status}`);
	            }
	            const saved = await resp.json();
	            await loadSam3CascadePresets({ preserveSelection: false });
	            if (sam3RecipeElements.cascadePresetSelect && saved?.id) {
	                sam3RecipeElements.cascadePresetSelect.value = saved.id;
	            }
	            setSam3RecipeStatus(`Saved cascade preset ${saved?.label || saved?.id || ""}.`, "success");
	            refreshSam3CascadeControls();
	        } catch (err) {
	            console.error("Save cascade preset failed", err);
	            setSam3RecipeStatus(err.message || "Save failed.", "error");
	        }
	    }

	    async function loadSam3CascadePreset() {
	        const cascadeId = sam3RecipeElements.cascadePresetSelect?.value;
	        if (!cascadeId) {
	            setSam3RecipeStatus("Choose a cascade preset to load.", "warn");
	            return;
	        }
	        try {
	            const resp = await fetch(`${API_ROOT}/agent_mining/cascades/${encodeURIComponent(cascadeId)}`);
	            if (!resp.ok) {
	                const detail = await resp.text();
	                throw new Error(detail || `HTTP ${resp.status}`);
	            }
	            const data = await resp.json();
	            applyCascadePayloadToUi(data);
	            setSam3RecipeStatus(`Loaded cascade ${data?.label || data?.id || cascadeId}.`, "success");
	        } catch (err) {
	            console.error("Load cascade preset failed", err);
	            setSam3RecipeStatus(err.message || "Load failed.", "error");
	        }
	    }

	    async function deleteSam3CascadePreset() {
	        const cascadeId = sam3RecipeElements.cascadePresetSelect?.value;
	        if (!cascadeId) {
	            setSam3RecipeStatus("Choose a cascade preset to delete.", "warn");
	            return;
	        }
	        if (typeof window !== "undefined" && !window.confirm("Delete this cascade? This cannot be undone.")) {
	            return;
	        }
	        try {
	            const resp = await fetch(`${API_ROOT}/agent_mining/cascades/${encodeURIComponent(cascadeId)}`, {
	                method: "DELETE",
	            });
	            if (!resp.ok) {
	                const detail = await resp.text();
	                throw new Error(detail || `HTTP ${resp.status}`);
	            }
	            await loadSam3CascadePresets({ preserveSelection: false });
	            if (sam3RecipeElements.cascadePresetSelect) sam3RecipeElements.cascadePresetSelect.value = "";
	            setSam3RecipeStatus("Deleted cascade preset.", "success");
	            refreshSam3CascadeControls();
	        } catch (err) {
	            console.error("Delete cascade preset failed", err);
	            setSam3RecipeStatus(err.message || "Delete failed.", "error");
	        }
	    }

	    async function exportSam3CascadePreset() {
	        const cascadeId = sam3RecipeElements.cascadePresetSelect?.value;
	        if (!cascadeId) {
	            setSam3RecipeStatus("Choose a cascade preset to download.", "warn");
	            return;
	        }
	        try {
	            const resp = await fetch(`${API_ROOT}/agent_mining/cascades/${encodeURIComponent(cascadeId)}/export`);
	            if (!resp.ok) {
	                const detail = await resp.text();
	                throw new Error(detail || `HTTP ${resp.status}`);
	            }
	            const blob = await resp.blob();
	            saveAs(blob, `${cascadeId}.zip`);
	            setSam3RecipeStatus("Downloaded cascade zip.", "success");
	        } catch (err) {
	            console.error("Export cascade failed", err);
	            setSam3RecipeStatus(err.message || "Download failed.", "error");
	        }
	    }

	    async function handleSam3CascadeFile(event) {
	        const file = event.target?.files?.[0];
	        if (!file) {
	            return;
	        }
	        try {
	            if (!file.name.toLowerCase().endsWith(".zip")) {
	                throw new Error("zip_only");
	            }
	            const formData = new FormData();
	            formData.append("file", file);
	            const resp = await fetch(`${API_ROOT}/agent_mining/cascades/import`, {
	                method: "POST",
	                body: formData,
	            });
	            if (!resp.ok) {
	                const detail = await resp.text();
	                throw new Error(detail || `HTTP ${resp.status}`);
	            }
	            const data = await resp.json();
	            await loadSam3RecipePresets();
	            await loadSam3CascadePresets({ preserveSelection: false });
	            if (sam3RecipeElements.cascadePresetSelect && data?.id) {
	                sam3RecipeElements.cascadePresetSelect.value = data.id;
	            }
	            applyCascadePayloadToUi(data);
	            setSam3RecipeStatus(`Imported cascade ${data?.label || data?.id || ""}.`, "success");
	        } catch (err) {
	            console.error("Cascade import failed", err);
	            const msg = err?.message === "zip_only" ? "Cascades must be loaded from a .zip file." : "Invalid cascade file (use zip).";
	            setSam3RecipeStatus(msg, "error");
	        } finally {
	            if (sam3RecipeElements.cascadeFileInput) sam3RecipeElements.cascadeFileInput.value = "";
	        }
		    }

		    async function runSam3CascadeOnImage() {
		        if (sam3RecipeElements.status) {
		            sam3RecipeElements.status.title = "";
		        }
		        if (!currentImage) {
		            setSam3RecipeStatus("Open an image first.", "warn");
		            return;
		        }
	        const classNames = orderedClassNames();
	        const enabledSteps = (Array.isArray(sam3CascadeState.steps) ? sam3CascadeState.steps : []).filter((s) => s && s.enabled);
	        const missingIndex = (Array.isArray(sam3CascadeState.steps) ? sam3CascadeState.steps : []).findIndex(
	            (s) => s && s.enabled && !s.recipe_id,
	        );
	        if (missingIndex >= 0) {
	            setSam3RecipeStatus(`Select a recipe for step ${missingIndex + 1} (or disable it) before applying.`, "warn");
	            return;
	        }
	        const stepsPayload = [];
	        for (const step of enabledSteps) {
	            let overrideName = null;
	            let overrideId = null;
	            if (step.override_enabled) {
	                overrideName = step.override_class_name || null;
	                if (!overrideName || !classNames.includes(overrideName)) {
	                    setSam3RecipeStatus("Select a valid output class override for each enabled step.", "warn");
	                    return;
	                }
	                overrideId = typeof classes[overrideName] !== "undefined" ? classes[overrideName] : null;
	            }
		            stepsPayload.push({
		                enabled: true,
		                recipe_id: step.recipe_id,
		                override_class_id: overrideId,
		                override_class_name: overrideName,
		                dedupe_group: step.dedupe_group || "",
		                participate_cross_class_dedupe: step.participate_cross_class_dedupe !== false,
		                clip_head_min_prob_override:
		                    typeof step.clip_head_min_prob_override === "number" && Number.isFinite(step.clip_head_min_prob_override)
		                        ? step.clip_head_min_prob_override
		                        : null,
		                clip_head_margin_override:
		                    typeof step.clip_head_margin_override === "number" && Number.isFinite(step.clip_head_margin_override)
		                        ? step.clip_head_margin_override
		                        : null,
		                extra_clip_classifier_path: step.extra_clip_classifier_path || null,
		                extra_clip_min_prob:
		                    typeof step.extra_clip_min_prob === "number" && Number.isFinite(step.extra_clip_min_prob)
		                        ? step.extra_clip_min_prob
		                        : null,
		                extra_clip_margin:
		                    typeof step.extra_clip_margin === "number" && Number.isFinite(step.extra_clip_margin)
		                        ? step.extra_clip_margin
		                        : null,
		            });
		        }
		        if (!stepsPayload.length) {
		            setSam3RecipeStatus("Add at least one enabled step with a recipe before applying.", "warn");
		            return;
		        }
		        const dedupe = getSam3CascadeDedupeConfig();
		        const cascadeTaskId = enqueueTask({
		            kind: "recipe-cascade",
		            imageName: currentImage.name,
		            detail: { steps: stepsPayload.length },
		        });
		        setSam3RecipeStatus(`Running cascade on ${currentImage.name}…`, "info");
		        try {
		            let maskThreshold = parseFloat(sam3TextElements.maskThresholdInput?.value || "0.5");
	            if (Number.isNaN(maskThreshold)) {
	                maskThreshold = 0.5;
	            }
	            maskThreshold = Math.min(Math.max(maskThreshold, 0), 1);
	            const minSize = Math.max(0, getMinMaskArea());
	            const simplifyEps = Math.max(0, getSimplifyEpsilon());
	            let maxResults = parseInt(sam3TextElements.maxResultsInput?.value || "100", 10);
	            if (!Number.isFinite(maxResults) || maxResults <= 0) {
	                maxResults = 100;
	            }
	            maxResults = Math.min(Math.max(maxResults, 1), 5000);

	            const imageNameForRequest = currentImage.name;
	            const variantForRequest = "sam3";
	            const preloadToken = await waitForSamPreloadIfActive(imageNameForRequest, variantForRequest);
	            let imagePayload = await buildSamImagePayload({ variantOverride: variantForRequest, preferredToken: preloadToken });
	            imagePayload.sam_variant = variantForRequest;
	            let resp = await fetch(`${API_ROOT}/agent_mining/apply_image_chain`, {
	                method: "POST",
	                headers: { "Content-Type": "application/json" },
	                body: JSON.stringify({
	                    ...imagePayload,
	                    steps: stepsPayload,
	                    dedupe,
	                    mask_threshold: maskThreshold,
	                    min_size: minSize,
	                    simplify_epsilon: simplifyEps,
	                    max_results: maxResults,
	                }),
	            });
	            if (resp.status === 428) {
	                imagePayload = await buildSamImagePayload({
	                    forceBase64: true,
	                    variantOverride: variantForRequest,
	                    preferredToken: preloadToken,
	                });
	                imagePayload.sam_variant = variantForRequest;
	                resp = await fetch(`${API_ROOT}/agent_mining/apply_image_chain`, {
	                    method: "POST",
	                    headers: { "Content-Type": "application/json" },
	                    body: JSON.stringify({
	                        ...imagePayload,
	                        steps: stepsPayload,
	                        dedupe,
	                        mask_threshold: maskThreshold,
	                        min_size: minSize,
	                        simplify_epsilon: simplifyEps,
	                        max_results: maxResults,
	                    }),
	                });
	            }
	            if (!resp.ok) {
	                const detail = await resp.text();
	                throw new Error(detail || resp.statusText || `HTTP ${resp.status}`);
	            }
	            const result = await resp.json();
	            if (currentImage && result?.image_token) {
	                rememberSamToken(currentImage.name, variantForRequest, result.image_token);
		            }
		            const detections = Array.isArray(result?.detections) ? result.detections : [];
		            const warnList = Array.isArray(result?.warnings) ? result.warnings : [];
		            const warnDetails = formatAgentWarningsForUi(warnList);
		            const byClass = new Map();
		            const missingClasses = new Set();
		            detections.forEach((det) => {
		                const cls = det?.class_name || det?.qwen_label || "";
	                if (!cls) return;
	                if (!classNames.includes(cls)) {
	                    missingClasses.add(cls);
	                    return;
	                }
	                if (!byClass.has(cls)) byClass.set(cls, []);
	                byClass.get(cls).push(det);
	            });
		            let added = 0;
		            byClass.forEach((list, cls) => {
		                added += applySegAwareDetections(list, cls, "Recipe cascade");
		            });
		            const warnText = warnDetails.message ? ` Warnings: ${warnDetails.message}` : "";
		            const missingText = missingClasses.size ? ` Missing classes: ${Array.from(missingClasses).join(", ")}` : "";
		            if (sam3RecipeElements.status) {
		                sam3RecipeElements.status.title = warnDetails.codes.length ? warnDetails.codes.join("\n") : "";
		            }
		            if (added > 0) {
		                setSam3RecipeStatus(
		                    `Cascade applied: added ${added} ${datasetType === "seg" ? "polygons" : "boxes"}.${warnText}${missingText}`,
		                    warnList.length || missingClasses.size ? "warn" : "success",
	                );
	            } else {
	                setSam3RecipeStatus(`Cascade applied: no detections.${warnText}${missingText}`, "warn");
	            }
		        } catch (err) {
		            console.error("Cascade apply failed", err);
		            setSam3RecipeStatus(`Cascade failed: ${err.message || err}`, "error");
		        } finally {
		            completeTask(cascadeTaskId);
		            refreshSam3CascadeControls();
		        }
		    }

    function parseRecipeJson(text) {
        try {
            const data = JSON.parse(text);
            if (!data || typeof data !== "object") throw new Error("invalid_json");
            const steps = Array.isArray(data.steps) ? data.steps : [];
            const cleanedSteps = steps
                .map((s) => ({
                    prompt: typeof s.prompt === "string" ? s.prompt.trim() : "",
                    threshold:
                        typeof s.threshold === "number" && s.threshold >= 0 && s.threshold <= 1
                            ? s.threshold
                            : null,
                }))
                .filter((s) => s.prompt && s.threshold !== null);
            if (!cleanedSteps.length) throw new Error("no_steps");
            const targetClass = (data.class_name || data.class || data.target_class || "").trim();
            const targetId = data.class_id;
            return {
                label: data.label || data.id || "recipe",
                class_name: targetClass,
                class_id: targetId,
                steps: cleanedSteps,
            };
        } catch (err) {
            throw new Error("parse_failed");
        }
    }

    function normalizeAgentRecipePayload(data) {
        if (!data || typeof data !== "object") {
            return null;
        }
        const recipeBody =
            data.recipe && typeof data.recipe === "object" && !Array.isArray(data.recipe) ? data.recipe : data;
        const steps = Array.isArray(recipeBody.steps) ? recipeBody.steps : Array.isArray(data.steps) ? data.steps : [];
        const textPrompts = Array.isArray(recipeBody.text_prompts)
            ? recipeBody.text_prompts
            : Array.isArray(data.text_prompts)
                ? data.text_prompts
                : [];
        const positives = Array.isArray(recipeBody.positives)
            ? recipeBody.positives
            : Array.isArray(data.positives)
                ? data.positives
                : [];
        const negatives = Array.isArray(recipeBody.negatives)
            ? recipeBody.negatives
            : Array.isArray(data.negatives)
                ? data.negatives
                : [];
        const params =
            data.params && typeof data.params === "object"
                ? data.params
                : recipeBody?.params && typeof recipeBody.params === "object"
                    ? recipeBody.params
                    : {};
        const mode = recipeBody?.mode || data.mode || null;
        return {
            raw: data,
            id: data.id || null,
            label: data.label || data.id || "recipe",
            class_name: data.class_name || data?.recipe?.class_name || "",
            class_id: typeof data.class_id === "number" ? data.class_id : data?.recipe?.class_id,
            mode,
            params,
            steps: Array.isArray(steps) ? steps : [],
            text_prompts: Array.isArray(textPrompts) ? textPrompts : [],
            positives: Array.isArray(positives) ? positives : [],
            negatives: Array.isArray(negatives) ? negatives : [],
            summary: data?.recipe?.summary ?? data.summary ?? null,
            dataset_id: data.dataset_id ?? null,
            labelmap_hash: data.labelmap_hash ?? null,
            labelmap: data.labelmap ?? null,
            dataset_signature: data.dataset_signature ?? null,
            _zip: data._zip ?? null,
            _path: data._path ?? null,
        };
    }

	    async function handleSam3RecipeFile(event) {
	        const file = event.target?.files?.[0];
	        if (!file) {
	            return;
	        }
	        try {
	            if (!file.name.toLowerCase().endsWith(".zip")) {
	                throw new Error("zip_only");
	            }
	            const formData = new FormData();
	            formData.append("file", file);
	            const resp = await fetch(`${API_ROOT}/agent_mining/recipes/import`, {
	                method: "POST",
	                body: formData,
	            });
	            if (!resp.ok) throw new Error(await resp.text());
	            const data = await resp.json();
	            const recipe = normalizeAgentRecipePayload(data);
	            const hasContent =
	                recipe &&
	                ((Array.isArray(recipe.steps) && recipe.steps.length > 0) ||
	                    (Array.isArray(recipe.text_prompts) && recipe.text_prompts.length > 0) ||
	                    (Array.isArray(recipe.positives) && recipe.positives.length > 0));
	            if (!hasContent) {
	                throw new Error("no_steps");
	            }
	            const classNames = orderedClassNames();
	            const lowerToName = new Map(classNames.map((n) => [n.toLowerCase(), n]));
	            const targetName = (recipe.class_name || "").trim();
	            if (targetName) {
	                const found = lowerToName.get(targetName.toLowerCase());
	                if (found) {
	                    recipe.class_name = found;
	                } else {
	                    setSam3RecipeStatus(
	                        `Imported recipe ${recipe.label}. Note: class ${targetName} not in label map; use per-step output override.`,
	                        "warn",
	                    );
	                }
	            }
	            sam3RecipeState.recipe = recipe;
	            if (recipe.id) {
	                addSam3CascadeStep({ recipeId: recipe.id });
	            }
	            await loadSam3RecipePresets();
	            refreshSam3CascadeControls();
	            const parts = [];
	            if (recipe.mode) parts.push(recipe.mode);
	            const promptCount = Array.isArray(recipe.text_prompts) ? recipe.text_prompts.length : 0;
	            const posCount = Array.isArray(recipe.positives) ? recipe.positives.length : 0;
	            const stepCount = Array.isArray(recipe.steps) ? recipe.steps.length : 0;
	            parts.push(`${promptCount} prompts`);
	            parts.push(`${posCount} crops`);
	            if (stepCount) parts.push(`${stepCount} steps`);
	            const stepSuffix = recipe.id ? " Added as a cascade step." : "";
	            setSam3RecipeStatus(`Imported recipe ${recipe.label} (${parts.join(", ")}).${stepSuffix}`, "success");
	        } catch (err) {
	            console.error("Failed to load recipe", err);
	            const msg = err?.message === "zip_only" ? "Recipes must be loaded from a .zip file." : "Invalid recipe file (use zip).";
	            setSam3RecipeStatus(msg, "error");
	            sam3RecipeState.recipe = null;
	        } finally {
	            if (sam3RecipeElements.fileInput) sam3RecipeElements.fileInput.value = "";
	        }
	    }

    async function runSam3RecipeOnImage() {
        const recipe = sam3RecipeState.recipe;
        const hasContent =
            recipe &&
            ((Array.isArray(recipe.steps) && recipe.steps.length > 0) ||
                (Array.isArray(recipe.text_prompts) && recipe.text_prompts.length > 0) ||
                (Array.isArray(recipe.positives) && recipe.positives.length > 0));
        if (!hasContent) {
            setSam3RecipeStatus("Load a recipe zip first.", "warn");
            return;
        }
        if (!currentImage) {
            setSam3RecipeStatus("Open an image first.", "warn");
            return;
        }
        if (sam3RecipeElements.status) {
            sam3RecipeElements.status.title = "";
        }
        const classNames = orderedClassNames();
        const overrideEnabled = Boolean(sam3RecipeElements.overrideToggle?.checked);
        let outputClassName = null;
        let outputClassId = null;
        if (overrideEnabled) {
            outputClassName = sam3RecipeElements.overrideSelect?.value || null;
            if (!outputClassName || !classNames.includes(outputClassName)) {
                setSam3RecipeStatus("Select an output class override before applying.", "warn");
                return;
            }
            outputClassId = typeof classes[outputClassName] !== "undefined" ? classes[outputClassName] : null;
	        } else {
	            const target = (recipe.class_name || "").trim();
	            if (!target) {
	                setSam3RecipeStatus("Recipe is missing a target class; enable output class override.", "error");
                return;
            }
            const lowerToName = new Map(classNames.map((n) => [n.toLowerCase(), n]));
            const found = lowerToName.get(target.toLowerCase());
            if (!found) {
                setSam3RecipeStatus(`Class ${target} not in current label map. Enable output class override.`, "error");
                return;
            }
	            outputClassName = found;
	            outputClassId = typeof classes[outputClassName] !== "undefined" ? classes[outputClassName] : null;
	        }
	        if (sam3RecipeElements.applyButton) sam3RecipeElements.applyButton.disabled = true;
	        const recipeTaskId = enqueueTask({ kind: "recipe-apply", imageName: currentImage.name, detail: outputClassName });
	        setSam3RecipeStatus(`Running recipe on ${currentImage.name}…`, "info");
	        try {
	            let maskThreshold = parseFloat(sam3TextElements.maskThresholdInput?.value || String(recipe.params?.mask_threshold ?? "0.5"));
            if (Number.isNaN(maskThreshold)) {
                maskThreshold = 0.5;
            }
            maskThreshold = Math.min(Math.max(maskThreshold, 0), 1);
            const minSize = Math.max(0, getMinMaskArea());
            const simplifyEps = Math.max(0, getSimplifyEpsilon());
            let maxResults = parseInt(sam3TextElements.maxResultsInput?.value || String(recipe.params?.max_results ?? "100"), 10);
            if (!Number.isFinite(maxResults) || maxResults <= 0) {
                maxResults = 100;
            }
            maxResults = Math.min(Math.max(maxResults, 1), 5000);
            const imageNameForRequest = currentImage.name;
            const variantForRequest = "sam3";
            const preloadToken = await waitForSamPreloadIfActive(imageNameForRequest, variantForRequest);
            let imagePayload = await buildSamImagePayload({ variantOverride: variantForRequest, preferredToken: preloadToken });
            imagePayload.sam_variant = variantForRequest;
            const recipePayload = recipe?.raw && typeof recipe.raw === "object" ? recipe.raw : recipe;
            let resp = await fetch(`${API_ROOT}/agent_mining/apply_image`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({
                    ...imagePayload,
                    recipe: recipePayload,
                    mask_threshold: maskThreshold,
                    min_size: minSize,
                    simplify_epsilon: simplifyEps,
                    max_results: maxResults,
                    override_class_id: overrideEnabled ? outputClassId : null,
                    override_class_name: overrideEnabled ? outputClassName : null,
                }),
            });
            if (resp.status === 428) {
                imagePayload = await buildSamImagePayload({ forceBase64: true, variantOverride: variantForRequest, preferredToken: preloadToken });
                imagePayload.sam_variant = variantForRequest;
                resp = await fetch(`${API_ROOT}/agent_mining/apply_image`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify({
                        ...imagePayload,
                        recipe: recipePayload,
                        mask_threshold: maskThreshold,
                        min_size: minSize,
                        simplify_epsilon: simplifyEps,
                        max_results: maxResults,
                        override_class_id: overrideEnabled ? outputClassId : null,
                        override_class_name: overrideEnabled ? outputClassName : null,
                    }),
                });
            }
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || resp.statusText || `HTTP ${resp.status}`);
            }
            const result = await resp.json();
            if (currentImage && result?.image_token) {
                rememberSamToken(currentImage.name, variantForRequest, result.image_token);
            }
            const detections = Array.isArray(result?.detections) ? result.detections : [];
            const warnList = Array.isArray(result?.warnings) ? result.warnings : [];
            const warnDetails = formatAgentWarningsForUi(warnList);
            const added = applySegAwareDetections(detections, outputClassName, "Agent recipe");
            const warnText = warnDetails.message ? ` Warnings: ${warnDetails.message}` : "";
            if (sam3RecipeElements.status) {
                sam3RecipeElements.status.title = warnDetails.codes.length ? warnDetails.codes.join("\n") : "";
            }
            if (added > 0) {
                setSam3RecipeStatus(`Recipe applied: added ${added} ${datasetType === "seg" ? "polygons" : "boxes"} to ${outputClassName}.${warnText}`, warnList.length ? "warn" : "success");
            } else {
                setSam3RecipeStatus(`Recipe applied: no detections.${warnText}`, warnList.length ? "warn" : "warn");
            }
	        } catch (err) {
	            console.error("Recipe apply failed", err);
	            setSam3RecipeStatus(`Recipe failed: ${err.message || err}`, "error");
	        } finally {
	            completeTask(recipeTaskId);
	            if (sam3RecipeElements.applyButton) sam3RecipeElements.applyButton.disabled = false;
	        }
	    }

    function refreshSam3SimilarityVisibility() {
        const row = sam3TextElements.similarityRow;
        const btn = sam3TextElements.similarityButton;
        const show = samVariant === "sam3" && samMode;
        if (row) {
            row.style.display = show ? "" : "none";
        }
        if (btn) {
            btn.style.display = show ? "" : "none";
        }
        if (sam3TextElements.similarityThresholdInput) {
            sam3TextElements.similarityThresholdInput.disabled = !show;
        }
    }

    function updateSam3TextButtons() {
        refreshSam3SimilarityVisibility();
        const busy = sam3TextRequestActive
            || sam3SimilarityRequestActive
            || sam3TextBatchActive
            || sam3TextCascadeActive;
        setButtonDisabled(sam3TextElements.runButton, busy);
        setButtonDisabled(sam3TextElements.similarityButton, busy);
        setButtonDisabled(sam3TextElements.cascadeToggleButton, busy);
        setButtonDisabled(sam3TextElements.cascadeAddButton, busy);
        setButtonDisabled(sam3TextElements.cascadeRunButton, busy);
        setButtonDisabled(sam3TextElements.cascadeClearButton, busy);
        setButtonDisabled(sam3TextElements.cascadeStopButton, !sam3TextCascadeActive);
        setButtonDisabled(sam3TextElements.batchRunButton, busy);
        setButtonDisabled(sam3TextElements.batchCountInput, busy);
        setButtonDisabled(sam3TextElements.batchIncludeCurrentToggle, busy);
        setButtonDisabled(sam3TextElements.batchStopButton, !sam3TextBatchActive);
        if (sam3TextElements.runButton) {
            sam3TextElements.runButton.textContent = busy ? "Running…" : "Run SAM3";
        }
        if (sam3TextElements.similarityButton) {
            sam3TextElements.similarityButton.textContent = busy ? "Running…" : "SAM3 similarity prompt (use selected box(es))";
        }
        if (sam3TextElements.batchRunButton) {
            sam3TextElements.batchRunButton.textContent = sam3TextBatchActive ? "Running batch…" : "Run batch";
        }
        if (sam3TextElements.cascadeRunButton) {
            sam3TextElements.cascadeRunButton.textContent = sam3TextCascadeActive ? "Running cascade…" : "Run cascade";
        }
        if (!busy && !(sam3TextElements.status && sam3TextElements.status.textContent)) {
            setSam3TextStatus("Enter a prompt to run SAM3 text segmentation.", "info");
        }
    }

    function orderedClassNames() {
        const entries = Object.entries(classes || {});
        if (!entries.length) {
            return [];
        }
        return entries
            .sort((a, b) => a[1] - b[1])
            .map(([name]) => name);
    }

    function updateQwenClassOptions({ resetOverride = false, preserveSelection = false } = {}) {
        if (!qwenElements.classSelect) {
            return;
        }
        const classNames = orderedClassNames();
        qwenElements.classSelect.innerHTML = "";
        if (!classNames.length) {
            const placeholder = document.createElement("option");
            placeholder.textContent = "Load classes first";
            placeholder.value = "";
            qwenElements.classSelect.appendChild(placeholder);
            qwenElements.classSelect.disabled = true;
            qwenClassOverride = false;
            return;
        }
        qwenElements.classSelect.disabled = false;
        const previousValue = preserveSelection ? qwenElements.classSelect.value : null;
        classNames.forEach((name) => {
            const option = document.createElement("option");
            option.value = name;
            option.textContent = name;
            qwenElements.classSelect.appendChild(option);
        });
        let targetValue = null;
        if (preserveSelection && previousValue && classNames.includes(previousValue)) {
            targetValue = previousValue;
        } else if (currentClass && classNames.includes(currentClass)) {
            targetValue = currentClass;
        } else {
            targetValue = classNames[0];
        }
        qwenElements.classSelect.value = targetValue;
        if (resetOverride) {
            qwenClassOverride = false;
        }
    }

    function syncQwenClassToCurrent() {
        if (!qwenElements.classSelect || qwenClassOverride) {
            return;
        }
        if (currentClass && qwenElements.classSelect.value !== currentClass) {
            const options = Array.from(qwenElements.classSelect.options).map((opt) => opt.value);
            if (options.includes(currentClass)) {
                qwenElements.classSelect.value = currentClass;
            }
        }
    }

    function getQwenTargetClass() {
        if (qwenElements.classSelect && qwenElements.classSelect.value) {
            return qwenElements.classSelect.value;
        }
        return currentClass;
    }

    function updateSam3ClassOptions({ resetOverride = false, preserveSelection = false } = {}) {
        if (!sam3TextElements.classSelect) {
            return;
        }
        const classNames = orderedClassNames();
        sam3TextElements.classSelect.innerHTML = "";
        if (!classNames.length) {
            const placeholder = document.createElement("option");
            placeholder.textContent = "Load classes first";
            placeholder.value = "";
            sam3TextElements.classSelect.appendChild(placeholder);
            sam3TextElements.classSelect.disabled = true;
            return;
        }
        sam3TextElements.classSelect.disabled = false;
        const previousValue = preserveSelection ? sam3TextElements.classSelect.value : null;
        classNames.forEach((name) => {
            const option = document.createElement("option");
            option.value = name;
            option.textContent = name;
            sam3TextElements.classSelect.appendChild(option);
        });
        let targetValue = null;
        if (preserveSelection && previousValue && classNames.includes(previousValue)) {
            targetValue = previousValue;
        } else if (currentClass && classNames.includes(currentClass)) {
            targetValue = currentClass;
        } else {
            targetValue = classNames[0];
        }
        sam3TextElements.classSelect.value = targetValue;
        if (resetOverride && classNames.length) {
            sam3TextElements.classSelect.value = targetValue;
        }
        refreshSam3TextCascadeClassOptions({ preserveSelection });
        renderSam3CascadeSteps();
    }

    function updateSam3RecipeOverrideOptions({ resetOverride = false, preserveSelection = true } = {}) {
        if (!sam3RecipeElements.overrideSelect) {
            return;
        }
        const select = sam3RecipeElements.overrideSelect;
        const classNames = orderedClassNames();
        const enabled = Boolean(sam3RecipeElements.overrideToggle?.checked);
        select.innerHTML = "";
        if (!classNames.length) {
            const placeholder = document.createElement("option");
            placeholder.textContent = "Load classes first";
            placeholder.value = "";
            select.appendChild(placeholder);
            select.disabled = true;
            return;
        }
        const previousValue = preserveSelection ? select.value : null;
        classNames.forEach((name) => {
            const option = document.createElement("option");
            option.value = name;
            option.textContent = name;
            select.appendChild(option);
        });
        let targetValue = null;
        if (preserveSelection && previousValue && classNames.includes(previousValue)) {
            targetValue = previousValue;
        } else if (currentClass && classNames.includes(currentClass)) {
            targetValue = currentClass;
        } else {
            targetValue = classNames[0];
        }
        select.value = targetValue;
        if (resetOverride && classNames.length) {
            select.value = targetValue;
        }
        select.disabled = !enabled;
    }

    function updateQwenRunButton() {
        if (!qwenElements.runButton) {
            return;
        }
        qwenElements.runButton.disabled = !qwenAvailable || qwenRequestActive;
        qwenElements.runButton.textContent = qwenRequestActive ? "Running…" : "Use Qwen";
    }

    function updateQwenCaptionButton() {
        if (!qwenElements.captionRunButton) {
            return;
        }
        const busy = qwenCaptionActive || qwenCaptionBatchActive;
        qwenElements.captionRunButton.disabled = !qwenAvailable || busy;
        qwenElements.captionRunButton.textContent = qwenCaptionActive ? "Captioning…" : "Caption image";
        if (qwenElements.captionBatchRun) {
            qwenElements.captionBatchRun.disabled = !qwenAvailable || busy;
        }
        if (qwenElements.captionBatchRunAll) {
            qwenElements.captionBatchRunAll.disabled = !qwenAvailable || busy;
        }
        if (qwenElements.captionBatchCancel) {
            qwenElements.captionBatchCancel.disabled = !busy;
        }
    }

    function getCaptionPresetText() {
        const presetId = qwenElements.captionPreset?.value || CAPTION_PRESETS[0].id;
        const preset = CAPTION_PRESETS.find((entry) => entry.id === presetId) || CAPTION_PRESETS[0];
        return preset.text || "";
    }

    function applyCaptionPreset({ randomize = false } = {}) {
        if (!qwenElements.captionPreset || !qwenElements.captionHint) {
            return;
        }
        if (randomize) {
            const selectable = CAPTION_PRESETS.filter((preset) => preset.id !== "custom");
            const pick = selectable[Math.floor(Math.random() * selectable.length)] || CAPTION_PRESETS[0];
            qwenElements.captionPreset.value = pick.id;
        }
        const presetText = getCaptionPresetText();
        if (presetText) {
            qwenElements.captionHint.value = presetText;
        }
    }

    function buildCaptionStylePrompt() {
        const raw = (qwenElements.captionStyleList?.value || "").trim();
        if (!raw) {
            return "";
        }
        const lines = raw
            .split("\n")
            .map((line) => line.trim())
            .filter(Boolean);
        if (!lines.length) {
            return "";
        }
        const joined = lines.join(" / ");
        const inspirationOnly = qwenElements.captionStyleInspiration?.checked;
        if (inspirationOnly) {
            return "Style inspirations (for tone/angle only; rephrase, do not quote verbatim): "
                + `${joined}.`;
        }
        return `Use one of these styles as a starting point: ${joined}.`;
    }

    function parseCaptionList(raw) {
        const cleaned = (raw || "").trim();
        if (!cleaned) {
            return [];
        }
        if (cleaned.startsWith("[")) {
            try {
                const parsed = JSON.parse(cleaned);
                if (Array.isArray(parsed)) {
                    return parsed.map((item) => String(item || "").trim()).filter(Boolean);
                }
            } catch (error) {
                // Fall back to newline parsing.
            }
        }
        return cleaned
            .split("\n")
            .map((line) => line.trim())
            .filter(Boolean);
    }

    function buildCaptionOpeningPrompt() {
        if (qwenElements.captionVaryOpening && !qwenElements.captionVaryOpening.checked) {
            return "";
        }
        const raw = (qwenElements.captionOpeningList?.value || "").trim();
        const lines = parseCaptionList(raw);
        if (!lines.length) {
            return "";
        }
        const joined = lines.join(" / ");
        return `Preferred opening phrases (choose one and rephrase if needed): ${joined}.`;
    }

    function updateCaptionWindowMode() {
        if (!qwenElements.captionMode) {
            return;
        }
        const isWindowed = qwenElements.captionMode.value === "windowed";
        const controls = [qwenElements.captionWindowSize, qwenElements.captionWindowOverlap];
        controls.forEach((control) => {
            if (!control) {
                return;
            }
            control.disabled = !isWindowed;
            control.closest("div")?.classList.toggle("is-disabled", !isWindowed);
        });
    }

    function setQwenCaptionStatus(message) {
        if (!qwenElements.captionStatus) {
            return;
        }
        qwenElements.captionStatus.textContent = message || "";
    }

    function getSam3TargetClass() {
        if (sam3TextElements.classSelect && sam3TextElements.classSelect.value) {
            return sam3TextElements.classSelect.value;
        }
        return currentClass;
    }

    function toggleQwenAdvanced(forceState = null) {
        if (!qwenElements.advancedToggle || !qwenElements.advancedPanel) {
            return;
        }
        if (typeof forceState === "boolean") {
            qwenAdvancedVisible = forceState;
        } else {
            qwenAdvancedVisible = !qwenAdvancedVisible;
        }
        const expanded = qwenAdvancedVisible;
        qwenElements.advancedToggle.setAttribute("aria-expanded", expanded ? "true" : "false");
        qwenElements.advancedPanel.setAttribute("aria-hidden", expanded ? "false" : "true");
        qwenElements.advancedToggle.textContent = expanded ? "Hide advanced overrides" : "Show advanced overrides";
    }

    async function refreshQwenStatus({ silent = false } = {}) {
        if (!qwenElements.statusLabel) {
            return;
        }
        if (!silent) {
            setQwenStatusLabel("Checking…", "info");
        }
        qwenAvailable = false;
        updateQwenRunButton();
        updateQwenCaptionButton();
        try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 6000);
            const resp = await fetch(`${API_ROOT}/qwen/status`, { signal: controller.signal });
            clearTimeout(timeout);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            const data = await resp.json();
            if (data.available && !data.dependency_error) {
                qwenAvailable = true;
                const deviceLabel = data.device ? ` (${data.device})` : "";
                if (data.loaded) {
                    setQwenStatusLabel(`Ready${deviceLabel}`, "ready");
                } else {
                    setQwenStatusLabel(`Available${deviceLabel}`, "ready");
                }
            } else if (data.dependency_error) {
                setQwenStatusLabel("Unavailable (deps)", "error");
            } else {
                setQwenStatusLabel("Disabled", "error");
            }
        } catch (error) {
            setQwenStatusLabel("Unavailable", "error");
            qwenAvailable = false;
        } finally {
            updateQwenRunButton();
            updateQwenCaptionButton();
        }
    }

    function setQwenModelStatus(message, variant = "info") {
        if (!qwenModelElements.status) {
            return;
        }
        qwenModelElements.status.textContent = message || "";
        qwenModelElements.status.className = variant ? `qwen-model-status ${variant}` : "qwen-model-status";
    }

    function applyActiveQwenMetadata(metadata) {
        qwenModelState.activeMetadata = metadata || null;
        const badge = document.getElementById("qwenActiveModelLabel");
        if (badge) {
            badge.textContent = metadata?.label ? `Active: ${metadata.label}` : "Active: Base Qwen";
        }
        const context = metadata?.dataset_context || "";
        const classes = Array.isArray(metadata?.classes) ? metadata.classes : [];
        if (qwenElements.imageTypeInput && !qwenElements.imageTypeInput.value) {
            qwenElements.imageTypeInput.placeholder = context || "Describe the image";
        }
        if (qwenElements.itemsInput && !qwenElements.itemsInput.value) {
            qwenElements.itemsInput.placeholder = classes.length ? classes.join(", ") : "car, bus, kiosk";
        }
    }

    function renderQwenModelDetails(metadata) {
        if (!qwenModelElements.details) {
            return;
        }
        if (!metadata) {
            qwenModelElements.details.innerHTML = "Select a model to see its prompts and defaults.";
            return;
        }
        const modelFamily = metadata.model_family || "qwen3";
        const familyLabel = modelFamily !== "qwen3" ? "Legacy (read-only)" : "Qwen3";
        const classes = Array.isArray(metadata.classes) ? metadata.classes.join(", ") : "(not specified)";
        const context = metadata.dataset_context || "(not specified)";
        const minPixelsValue = Number(metadata.min_pixels);
        const maxPixelsValue = Number(metadata.max_pixels);
        const minPixels = Number.isFinite(minPixelsValue) && minPixelsValue > 0 ? minPixelsValue : 12544;
        const maxPixels = Number.isFinite(maxPixelsValue) && maxPixelsValue > 0 ? maxPixelsValue : 451584;
        qwenModelElements.details.innerHTML = `
            <p><strong>Name:</strong> ${metadata.label || metadata.id || "Custom Run"}</p>
            <p><strong>Base model:</strong> ${metadata.model_id || "Qwen/Qwen3-VL-4B-Instruct"}</p>
            <p><strong>Model family:</strong> ${familyLabel}</p>
            <p><strong>Context hint:</strong> ${context}</p>
            <p><strong>Classes:</strong> ${classes}</p>
            <p><strong>Pixel budget:</strong> ${minPixels}–${maxPixels}</p>
            <label>System prompt</label>
            <pre>${metadata.system_prompt || ""}</pre>
        `;
    }

    function renderQwenModelList() {
        if (!qwenModelElements.list) {
            return;
        }
        qwenModelElements.list.innerHTML = "";
        qwenModelState.models.forEach((entry) => {
            const card = document.createElement("div");
            card.className = entry.active ? "qwen-model-card active" : "qwen-model-card";
            const title = document.createElement("h3");
            title.textContent = entry.label || entry.id;
            card.appendChild(title);
            const metaText = document.createElement("p");
            const context = entry.metadata?.dataset_context;
            const classes = Array.isArray(entry.metadata?.classes) ? entry.metadata.classes.join(", ") : "";
            const modelFamily = entry.metadata?.model_family || "qwen3";
            const legacyTag = modelFamily !== "qwen3" ? "Legacy (read-only)" : "";
            metaText.textContent = [context, classes, legacyTag].filter(Boolean).join(" • ") || "No context provided";
            card.appendChild(metaText);
            const button = document.createElement("button");
            button.type = "button";
            button.className = "training-button";
            const isLegacy = modelFamily !== "qwen3";
            if (isLegacy) {
                card.classList.add("legacy");
            }
            button.textContent = entry.active ? "Active" : isLegacy ? "Legacy" : "Activate";
            button.disabled = !!entry.active || isLegacy;
            if (isLegacy) {
                button.title = "Legacy Qwen2.5 checkpoints stay on disk but cannot be activated.";
            } else {
                button.addEventListener("click", () => activateQwenModel(entry.id));
            }
            card.appendChild(button);
            qwenModelElements.list.appendChild(card);
        });
    }

    async function refreshQwenModels() {
        setQwenModelStatus("Loading models…", "info");
        if (qwenModelElements.refreshButton) {
            qwenModelElements.refreshButton.disabled = true;
        }
        try {
            const resp = await fetch(`${API_ROOT}/qwen/models`);
            if (!resp.ok) {
                const text = await resp.text();
                throw new Error(text || `HTTP ${resp.status}`);
            }
            const data = await resp.json();
            qwenModelState.models = data.models || [];
            qwenModelState.activeId = data.active || "default";
            const activeEntry = qwenModelState.models.find((entry) => entry.id === qwenModelState.activeId);
            applyActiveQwenMetadata(activeEntry?.metadata || null);
            renderQwenModelList();
            renderQwenModelDetails(activeEntry?.metadata || null);
            setQwenModelStatus("Models loaded.", "success");
        } catch (error) {
            console.error("Failed to load Qwen models", error);
            setQwenModelStatus(`Failed to load models: ${error.message || error}`, "error");
        } finally {
            if (qwenModelElements.refreshButton) {
                qwenModelElements.refreshButton.disabled = false;
            }
        }
    }

    async function activateQwenModel(modelId) {
        setQwenModelStatus("Switching models…", "info");
        try {
            const resp = await fetch(`${API_ROOT}/qwen/models/activate`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ model_id: modelId }),
            });
            if (!resp.ok) {
                const text = await resp.text();
                throw new Error(text || `HTTP ${resp.status}`);
            }
            await refreshQwenModels();
            setQwenModelStatus("Model activated.", "success");
        } catch (error) {
            console.error("Failed to activate Qwen model", error);
            setQwenModelStatus(`Activation failed: ${error.message || error}`, "error");
        }
    }

    function initQwenModelTab() {
        if (qwenModelElements.status) {
            return;
        }
        qwenModelElements.status = document.getElementById("qwenModelStatus");
        qwenModelElements.list = document.getElementById("qwenModelList");
        qwenModelElements.details = document.getElementById("qwenModelDetails");
        qwenModelElements.refreshButton = document.getElementById("qwenModelRefreshBtn");
        if (qwenModelElements.refreshButton) {
            qwenModelElements.refreshButton.addEventListener("click", () => {
                refreshQwenModels();
            });
        }
        refreshQwenModels();
    }

    async function handleQwenRun() {
        if (qwenRequestActive) {
            return;
        }
        if (!qwenAvailable) {
            setSamStatus("Qwen backend is unavailable", { variant: "warn", duration: 3500 });
            return;
        }
        if (!currentImage || !currentImage.name) {
            setSamStatus("Load an image before using Qwen", { variant: "warn", duration: 3000 });
            return;
        }
        const targetClass = getQwenTargetClass();
        if (!targetClass) {
            setSamStatus("Load classes and pick a target class before using Qwen", { variant: "warn", duration: 3500 });
            return;
        }
        const manualPrompt = (qwenElements.manualPrompt?.value || "").trim();
        const itemsText = (qwenElements.itemsInput?.value || "").trim();
        if (!manualPrompt && !itemsText) {
            setSamStatus("Describe what to detect or supply a custom prompt.", { variant: "warn", duration: 3500 });
            qwenElements.itemsInput?.focus();
            return;
        }
        const promptType = qwenElements.promptType?.value || "bbox";
        let maxResults = parseInt(qwenElements.maxResults?.value || "8", 10);
        if (Number.isNaN(maxResults)) {
            maxResults = 8;
        }
        maxResults = Math.min(Math.max(maxResults, 1), 50);
        qwenRequestActive = true;
        updateQwenRunButton();
        setSamStatus(`Running Qwen (${promptType === "point" ? "points" : "bbox"}) for ${targetClass}…`, { variant: "info", duration: 0 });
        try {
            if (qwenElements.unloadOthers?.checked) {
                setSamStatus("Unloading other models before Qwen run…", { variant: "info", duration: 2000 });
                try {
                    await fetch(`${API_ROOT}/runtime/unload`, { method: "POST" });
                } catch (error) {
                    console.warn("Failed to unload other runtimes", error);
                }
            }
            const requestFields = {
                prompt_type: promptType,
                max_results: maxResults,
            };
            if (manualPrompt) {
                requestFields.prompt = manualPrompt;
            } else {
                requestFields.item_list = itemsText;
                const imageTypeOverride = (qwenElements.imageTypeInput?.value || "").trim();
                const extraOverride = (qwenElements.extraContextInput?.value || "").trim();
                if (imageTypeOverride) {
                    requestFields.image_type = imageTypeOverride;
                }
                if (extraOverride) {
                    requestFields.extra_context = extraOverride;
                }
            }
            const result = await invokeQwenInfer(requestFields);
            if (currentImage && result?.image_token) {
                rememberSamToken(currentImage.name, samVariant, result.image_token);
            }
            const added = applyQwenBoxes(result?.boxes || [], targetClass);
            if (!added) {
                const warning = Array.isArray(result?.warnings) && result.warnings.includes("no_results")
                    ? "No regions matched the prompt"
                    : "Qwen returned no usable boxes";
                setSamStatus(warning, { variant: "warn", duration: 4000 });
            }
        } catch (error) {
            const message = error?.message || error;
            setSamStatus(`Qwen error: ${message}`, { variant: "error", duration: 5000 });
            console.error("Qwen inference failed", error);
        } finally {
            qwenRequestActive = false;
            updateQwenRunButton();
        }
    }

    function collectCaptionLabelHintsForImage(imageName) {
        if (!imageName || !bboxes[imageName]) {
            return [];
        }
        const hints = [];
        const buckets = bboxes[imageName];
        Object.keys(buckets).forEach((className) => {
            (buckets[className] || []).forEach((bboxRecord) => {
                if (!bboxRecord) {
                    return;
                }
                let x1 = null;
                let y1 = null;
                let x2 = null;
                let y2 = null;
                const isPoly = bboxRecord.type === "polygon" || (Array.isArray(bboxRecord.points) && bboxRecord.points.length >= 3);
                if (isPoly) {
                    const xs = bboxRecord.points.map((p) => p.x);
                    const ys = bboxRecord.points.map((p) => p.y);
                    x1 = Math.min(...xs);
                    y1 = Math.min(...ys);
                    x2 = Math.max(...xs);
                    y2 = Math.max(...ys);
                } else if (Number.isFinite(bboxRecord.x) && Number.isFinite(bboxRecord.y)) {
                    x1 = bboxRecord.x;
                    y1 = bboxRecord.y;
                    x2 = bboxRecord.x + (bboxRecord.width || 0);
                    y2 = bboxRecord.y + (bboxRecord.height || 0);
                }
                if (x1 === null || y1 === null || x2 === null || y2 === null) {
                    return;
                }
                const hint = {
                    label: className,
                    bbox: [x1, y1, x2, y2],
                };
                if (Number.isFinite(bboxRecord.score)) {
                    hint.confidence = bboxRecord.score;
                }
                hints.push(hint);
            });
        });
        return hints;
    }

    function collectCaptionLabelHints() {
        if (!currentImage || !currentImage.name) {
            return [];
        }
        return collectCaptionLabelHintsForImage(currentImage.name);
    }

    async function invokeQwenCaption(requestFields) {
        if (!currentImage) {
            throw new Error("No active image");
        }
        const imageNameForRequest = currentImage.name;
        const variantForRequest = samVariant;
        const preloadToken = await waitForSamPreloadIfActive(imageNameForRequest, variantForRequest);
        let payload = await buildSamImagePayload({ variantOverride: variantForRequest, preferredToken: preloadToken });
        if (imageNameForRequest && !payload.image_name) {
            payload.image_name = imageNameForRequest;
        }
        payload.sam_variant = variantForRequest;
        let resp = await fetch(`${API_ROOT}/qwen/caption`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ...requestFields, ...payload }),
        });
        if (resp.status === 428) {
            payload = await buildSamImagePayload({ forceBase64: true, variantOverride: variantForRequest, preferredToken: preloadToken });
            if (imageNameForRequest && !payload.image_name) {
                payload.image_name = imageNameForRequest;
            }
            payload.sam_variant = variantForRequest;
            resp = await fetch(`${API_ROOT}/qwen/caption`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ ...requestFields, ...payload }),
            });
        }
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || resp.statusText || `HTTP ${resp.status}`);
        }
        return resp.json();
    }

    function buildQwenCaptionRequestFields(imageName) {
        let maxTokens = parseInt(qwenElements.captionMaxTokens?.value || "256", 10);
        if (Number.isNaN(maxTokens)) {
            maxTokens = 256;
        }
        maxTokens = Math.min(Math.max(maxTokens, 32), 2000);
        let maxBoxes = parseInt(qwenElements.captionMaxBoxes?.value || "25", 10);
        if (Number.isNaN(maxBoxes)) {
            maxBoxes = 25;
        }
        maxBoxes = Math.min(Math.max(maxBoxes, 0), 200);
        const captionMode = qwenElements.captionMode?.value || "full";
        let windowSize = parseInt(qwenElements.captionWindowSize?.value || `${DEFAULT_CAPTION_WINDOW_SIZE}`, 10);
        if (Number.isNaN(windowSize)) {
            windowSize = DEFAULT_CAPTION_WINDOW_SIZE;
        }
        let windowOverlap = parseFloat(qwenElements.captionWindowOverlap?.value || `${DEFAULT_CAPTION_WINDOW_OVERLAP}`);
        if (Number.isNaN(windowOverlap)) {
            windowOverlap = DEFAULT_CAPTION_WINDOW_OVERLAP;
        }
        const includeCounts = !!qwenElements.captionIncludeCounts?.checked;
        const includeCoords = !!qwenElements.captionIncludeCoords?.checked;
        const variant = qwenElements.captionVariant?.value || "auto";
        const finalOnly = !!qwenElements.captionFinalOnly?.checked;
        const twoStage = !!qwenElements.captionTwoStage?.checked;
        const highVram = !!qwenElements.captionHighVram?.checked;
        const modelPick = qwenElements.captionModel?.value || "active";
        const basePreset = getCaptionPresetText();
        const customHint = (qwenElements.captionHint?.value || "").trim();
        const stylePrompt = buildCaptionStylePrompt();
        const openingPrompt = buildCaptionOpeningPrompt();
        let combinedPrompt = "";
        if (basePreset) {
            combinedPrompt = basePreset;
            if (customHint && basePreset !== customHint) {
                combinedPrompt = `${basePreset} ${customHint}`;
            }
        } else {
            combinedPrompt = customHint;
        }
        if (stylePrompt) {
            combinedPrompt = combinedPrompt ? `${combinedPrompt} ${stylePrompt}` : stylePrompt;
        }
        if (openingPrompt) {
            combinedPrompt = combinedPrompt ? `${combinedPrompt} ${openingPrompt}` : openingPrompt;
        }
        let modelOverride = null;
        if (modelPick !== "active") {
            if (modelPick.includes("/")) {
                modelOverride = modelPick;
            } else {
                const variantSuffix = variant === "Thinking" ? "Thinking" : "Instruct";
                modelOverride = `Qwen/Qwen3-VL-${modelPick}-${variantSuffix}`;
            }
            warnIfFp8Unsupported(modelOverride);
        }
        const hints = collectCaptionLabelHintsForImage(imageName);
        if (variant === "Thinking") {
            maxTokens = Math.max(maxTokens, 2000);
        } else if (captionMode === "windowed") {
            maxTokens = Math.max(maxTokens, 2000);
        }
        const requestFields = {
            user_prompt: combinedPrompt,
            label_hints: hints,
            include_counts: includeCounts,
            include_coords: includeCoords,
            max_boxes: maxBoxes,
            max_new_tokens: maxTokens,
            model_variant: variant,
            model_id: modelOverride,
            final_answer_only: finalOnly,
            two_stage_refine: twoStage,
            multi_model_cache: highVram,
            caption_mode: captionMode,
            window_size: captionMode === "windowed" ? windowSize : null,
            window_overlap: captionMode === "windowed" ? windowOverlap : null,
        };
        return {
            requestFields,
            meta: {
                imageName,
                model: modelOverride || modelPick,
                variant,
                captionMode,
                windowSize,
                windowOverlap,
                includeCounts,
                includeCoords,
                maxBoxes,
                maxTokens,
            },
            hints,
        };
    }

    function storeCaptionRecord(imageName, caption, result, meta, runId) {
        if (!textLabels) {
            textLabels = {};
        }
        textLabels[imageName] = String(caption || "").trim();
        const record = {
            image: imageName,
            caption: String(caption || "").trim(),
            dataset_id: null,
            model_id: meta?.model || null,
            variant: meta?.variant || null,
            caption_mode: meta?.captionMode || null,
            window_size: meta?.windowSize || null,
            window_overlap: meta?.windowOverlap || null,
            include_counts: meta?.includeCounts ?? null,
            include_coords: meta?.includeCoords ?? null,
            max_boxes: meta?.maxBoxes ?? null,
            max_new_tokens: meta?.maxTokens ?? null,
            used_boxes: result?.used_boxes ?? null,
            counts: result?.used_counts ?? null,
            created_at: new Date().toISOString(),
            run_id: runId || null,
        };
        if (!textLabelRecords) {
            textLabelRecords = [];
        }
        textLabelRecords.push(record);
    }

    async function handleQwenCaption() {
        if (qwenCaptionActive) {
            return;
        }
        if (!qwenAvailable) {
            setSamStatus("Qwen backend is unavailable", { variant: "warn", duration: 3500 });
            return;
        }
        if (!currentImage || !currentImage.name) {
            setSamStatus("Load an image before captioning", { variant: "warn", duration: 3000 });
            return;
        }
        qwenCaptionActive = true;
        updateQwenCaptionButton();
        setQwenCaptionStatus("Running…");
        setSamStatus("Running Qwen caption…", { variant: "info", duration: 0 });
        try {
            if (qwenElements.unloadOthers?.checked) {
                setSamStatus("Unloading other models before Qwen run…", { variant: "info", duration: 2000 });
                try {
                    await fetch(`${API_ROOT}/runtime/unload`, { method: "POST" });
                } catch (error) {
                    console.warn("Failed to unload other runtimes", error);
                }
            }
            const { requestFields, meta, hints } = buildQwenCaptionRequestFields(currentImage.name);
            const result = await invokeQwenCaption({
                ...requestFields,
                image_width: currentImage.width,
                image_height: currentImage.height,
            });
            if (qwenElements.captionOutput) {
                qwenElements.captionOutput.value = result?.caption || "";
            }
            if (qwenElements.captionMeta) {
                const countEntries = result?.used_counts || {};
                const countSummary = Object.keys(countEntries).length
                    ? Object.entries(countEntries).map(([label, count]) => `${label}: ${count}`).join(" • ")
                    : "No label hints";
                const truncBadge = result?.truncated ? " • summarized" : "";
                const savedLabel = qwenElements.captionSaveText?.checked ? " • saved to text labels" : "";
                qwenElements.captionMeta.textContent = `Hints: ${hints.length} • Used boxes: ${result?.used_boxes ?? 0}${truncBadge} • ${countSummary}${savedLabel}`;
            }
            if (qwenElements.captionSaveText?.checked && currentImage?.name) {
                storeCaptionRecord(currentImage.name, result?.caption || "", result, meta, `single_${Date.now()}`);
            }
            setQwenCaptionStatus("Ready");
            setSamStatus("Caption ready.", { variant: "success", duration: 3500 });
        } catch (error) {
            const message = error?.message || error;
            setQwenCaptionStatus("Error");
            setSamStatus(`Caption error: ${message}`, { variant: "error", duration: 5000 });
            console.error("Qwen caption failed", error);
        } finally {
            qwenCaptionActive = false;
            updateQwenCaptionButton();
        }
    }

    function getCaptionImageList() {
        const imageList = document.getElementById("imageList");
        if (!imageList) {
            return [];
        }
        return Array.from(imageList.options || []).map((opt) => getOptionImageName(opt)).filter(Boolean);
    }

    async function invokeQwenCaptionForImage(imageName, requestFields) {
        const imageRecord = images[imageName];
        if (!imageRecord) {
            throw new Error(`Unknown image: ${imageName}`);
        }
        const ready = await ensureImageRecordReady(imageRecord);
        if (!ready) {
            throw new Error(`Unable to load image: ${imageName}`);
        }
        const base64 = await getBase64ForImageRecord(imageRecord);
        if (!base64) {
            throw new Error(`Failed to encode image: ${imageName}`);
        }
        const payload = {
            ...requestFields,
            image_base64: base64,
            image_width: imageRecord.width,
            image_height: imageRecord.height,
        };
        const resp = await fetch(`${API_ROOT}/qwen/caption`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify(payload),
        });
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || resp.statusText || `HTTP ${resp.status}`);
        }
        return resp.json();
    }

    async function runQwenCaptionBatch(imageNames, options = {}) {
        if (!Array.isArray(imageNames) || imageNames.length === 0) {
            setSamStatus("No images selected for captioning.", { variant: "warn", duration: 3000 });
            return;
        }
        if (!qwenAvailable) {
            setSamStatus("Qwen backend is unavailable", { variant: "warn", duration: 3500 });
            return;
        }
        if (qwenCaptionBatchActive) {
            return;
        }
        qwenCaptionBatchActive = true;
        qwenCaptionBatchCancel = false;
        updateQwenCaptionButton();
        const runId = `batch_${Date.now()}`;
        const overwrite = !!options.overwrite;
        const includeCurrent = options.includeCurrent !== false;
        const total = imageNames.length;
        setQwenCaptionStatus(`Batch running (0/${total})…`);
        setSamStatus("Running Qwen caption batch…", { variant: "info", duration: 0 });
        try {
            if (qwenElements.unloadOthers?.checked) {
                setSamStatus("Unloading other models before Qwen batch…", { variant: "info", duration: 2000 });
                try {
                    await fetch(`${API_ROOT}/runtime/unload`, { method: "POST" });
                } catch (error) {
                    console.warn("Failed to unload other runtimes", error);
                }
            }
            let processed = 0;
            for (const imageName of imageNames) {
                if (qwenCaptionBatchCancel) {
                    setSamStatus("Caption batch cancelled.", { variant: "warn", duration: 3000 });
                    break;
                }
                if (!includeCurrent && currentImage?.name === imageName) {
                    continue;
                }
                if (!overwrite && textLabels?.[imageName]) {
                    processed += 1;
                    setQwenCaptionStatus(`Batch running (${processed}/${total})…`);
                    continue;
                }
                const { requestFields, meta } = buildQwenCaptionRequestFields(imageName);
                const result = await invokeQwenCaptionForImage(imageName, requestFields);
                if (qwenElements.captionSaveText?.checked) {
                    storeCaptionRecord(imageName, result?.caption || "", result, meta, runId);
                }
                processed += 1;
                setQwenCaptionStatus(`Batch running (${processed}/${total})…`);
            }
            setQwenCaptionStatus("Batch complete");
            setSamStatus("Caption batch complete.", { variant: "success", duration: 3500 });
        } catch (error) {
            const message = error?.message || error;
            setQwenCaptionStatus("Batch error");
            setSamStatus(`Caption batch error: ${message}`, { variant: "error", duration: 5000 });
            console.error("Qwen caption batch failed", error);
        } finally {
            qwenCaptionBatchActive = false;
            updateQwenCaptionButton();
        }
    }

    function downloadCaptionJsonl() {
        if (!textLabelRecords || textLabelRecords.length === 0) {
            setSamStatus("No captions to export yet.", { variant: "warn", duration: 3000 });
            return;
        }
        const lines = textLabelRecords.map((record) => JSON.stringify(record));
        const blob = new Blob([lines.join("\n")], { type: "application/jsonl" });
        saveAs(blob, "captions.jsonl");
    }

    function buildSam3TextSnapshot() {
        const prompt = (sam3TextElements.promptInput?.value || "").trim();
        let threshold = parseFloat(sam3TextElements.thresholdInput?.value || "0.5");
        if (Number.isNaN(threshold)) {
            threshold = 0.5;
        }
        threshold = Math.min(Math.max(threshold, 0), 1);
        let maskThreshold = parseFloat(sam3TextElements.maskThresholdInput?.value || "0.5");
        if (Number.isNaN(maskThreshold)) {
            maskThreshold = 0.5;
        }
        maskThreshold = Math.min(Math.max(maskThreshold, 0), 1);
        let minSize = parseInt(sam3TextElements.minSizeInput?.value || "0", 10);
        if (Number.isNaN(minSize) || minSize < 0) {
            minSize = 0;
        }
        let maxResults = parseInt(sam3TextElements.maxResultsInput?.value || "20", 10);
        if (Number.isNaN(maxResults)) {
            maxResults = 20;
        }
        maxResults = Math.min(Math.max(maxResults, 1), 100);
        let simplifyEps = parseFloat(sam3TextElements.epsilonInput?.value || "1.0");
        if (Number.isNaN(simplifyEps) || simplifyEps < 0) {
            simplifyEps = 1.0;
        }
        const targetClass = getSam3TargetClass();
        return {
            prompt,
            threshold,
            maskThreshold,
            minSize,
            maxResults,
            simplifyEps,
            targetClass,
        };
    }

    async function runSam3TextPromptSnapshot(snapshot) {
        const { prompt, threshold, maskThreshold, minSize, maxResults, simplifyEps, targetClass } = snapshot;
        const result = await invokeSam3TextPrompt({
            text_prompt: prompt,
            threshold,
            mask_threshold: maskThreshold,
            min_size: minSize,
            simplify_epsilon: simplifyEps,
            max_results: maxResults,
        });
        if (currentImage && result?.image_token) {
            rememberSamToken(currentImage.name, samVariant, result.image_token);
        }
        if (Array.isArray(result?.masks) && Array.isArray(result?.detections)) {
            result.detections.forEach((det, idx) => {
                if (det && !det.mask && result.masks[idx]) {
                    det.mask = result.masks[idx];
                }
            });
        }
        const applied = applySegAwareDetections(result?.detections || [], targetClass, "SAM3");
        if (applied) {
            const shapeLabel = datasetType === "seg" ? "polygon" : "bbox";
            setSam3TextStatus(`SAM3 added ${applied} ${shapeLabel}${applied === 1 ? "" : "es"} to ${targetClass}.`, "success");
            enqueueTaskNotice(`SAM3 text: added ${applied} ${shapeLabel}${applied === 1 ? "" : "es"} to ${targetClass}.`, { durationMs: 4500 });
        } else {
            const warning = Array.isArray(result?.warnings) && result.warnings.includes("no_results")
                ? "SAM3 found no matches for that prompt."
                : "SAM3 returned no usable detections.";
            setSam3TextStatus(warning, "warn");
            enqueueTaskNotice("SAM3 text: no detections added.", { durationMs: 3500 });
        }
        return { added: applied, detections: Array.isArray(result?.detections) ? result.detections.length : 0, warnings: result?.warnings || [] };
    }

    function getSam3TextCascadeStepElements() {
        if (!sam3TextElements.cascadeSteps) {
            return [];
        }
        return Array.from(sam3TextElements.cascadeSteps.querySelectorAll(".sam3-text-cascade__step"));
    }

    function refreshSam3TextCascadeStepTitles() {
        const steps = getSam3TextCascadeStepElements();
        steps.forEach((step, idx) => {
            const title = step.querySelector(".sam3-text-cascade__step-title");
            if (title) {
                title.textContent = sam3TextCascadeEnabled ? `Step ${idx + 2}` : `Step ${idx + 1}`;
            }
        });
    }

    function refreshSam3TextCascadeClassOptions({ preserveSelection = true } = {}) {
        const classNames = orderedClassNames();
        const steps = getSam3TextCascadeStepElements();
        steps.forEach((step) => {
            const select = step.querySelector(".sam3-text-cascade__class");
            if (!select) {
                return;
            }
            const previous = preserveSelection ? select.value : null;
            select.innerHTML = "";
            if (!classNames.length) {
                const placeholder = document.createElement("option");
                placeholder.textContent = "Load classes first";
                placeholder.value = "";
                select.appendChild(placeholder);
                select.disabled = true;
                return;
            }
            classNames.forEach((name) => {
                const option = document.createElement("option");
                option.value = name;
                option.textContent = name;
                select.appendChild(option);
            });
            let targetValue = null;
            if (preserveSelection && previous && classNames.includes(previous)) {
                targetValue = previous;
            } else if (currentClass && classNames.includes(currentClass)) {
                targetValue = currentClass;
            } else {
                targetValue = classNames[0];
            }
            select.value = targetValue;
        });
    }

    function createSam3TextCascadeStep({ useCurrentDefaults = false } = {}) {
        const promptDefault = useCurrentDefaults ? (sam3TextElements.promptInput?.value || "").trim() : "";
        const thresholdDefault = parseFloat(sam3TextElements.thresholdInput?.value || "0.5");
        const maskDefault = parseFloat(sam3TextElements.maskThresholdInput?.value || "0.5");
        const minSizeDefault = parseInt(sam3TextElements.minSizeInput?.value || "0", 10);
        const maxResultsDefault = parseInt(sam3TextElements.maxResultsInput?.value || "20", 10);
        const epsilonDefault = parseFloat(sam3TextElements.epsilonInput?.value || "1.0");
        const step = document.createElement("div");
        step.className = "sam3-text-cascade__step";
        step.innerHTML = `
            <div class="sam3-text-cascade__step-header">
                <span class="sam3-text-cascade__step-title">Step</span>
                <button type="button" class="training-button secondary sam3-text-cascade__remove">Remove</button>
            </div>
            <label>Prompt</label>
            <input type="text" class="sam3-text-cascade__prompt" placeholder="e.g., red helmet" />
            <div class="sam3-text-cascade__step-grid">
                <div>
                    <label>Assign class</label>
                    <select class="sam3-text-cascade__class"></select>
                </div>
                <div>
                    <label>Score threshold</label>
                    <input type="number" class="sam3-text-cascade__threshold" step="0.05" min="0" max="1" />
                </div>
                <div>
                    <label>Mask threshold</label>
                    <input type="number" class="sam3-text-cascade__mask" step="0.05" min="0" max="1" />
                </div>
                <div>
                    <label>Max results</label>
                    <input type="number" class="sam3-text-cascade__max-results" min="1" max="100" />
                </div>
                <div>
                    <label>Min size (px²)</label>
                    <input type="number" class="sam3-text-cascade__min-size" min="0" />
                </div>
                <div>
                    <label>Simplify epsilon (px)</label>
                    <input type="number" class="sam3-text-cascade__epsilon" min="0" step="0.1" />
                </div>
            </div>
        `;
        const promptInput = step.querySelector(".sam3-text-cascade__prompt");
        const thresholdInput = step.querySelector(".sam3-text-cascade__threshold");
        const maskInput = step.querySelector(".sam3-text-cascade__mask");
        const maxResultsInput = step.querySelector(".sam3-text-cascade__max-results");
        const minSizeInput = step.querySelector(".sam3-text-cascade__min-size");
        const epsilonInput = step.querySelector(".sam3-text-cascade__epsilon");
        const classSelect = step.querySelector(".sam3-text-cascade__class");
        if (promptInput) promptInput.value = promptDefault;
        if (thresholdInput) thresholdInput.value = Number.isFinite(thresholdDefault) ? thresholdDefault : 0.5;
        if (maskInput) maskInput.value = Number.isFinite(maskDefault) ? maskDefault : 0.5;
        if (maxResultsInput) maxResultsInput.value = Number.isFinite(maxResultsDefault) ? maxResultsDefault : 20;
        if (minSizeInput) minSizeInput.value = Number.isFinite(minSizeDefault) ? minSizeDefault : 0;
        if (epsilonInput) epsilonInput.value = Number.isFinite(epsilonDefault) ? epsilonDefault : 1.0;
        const removeButton = step.querySelector(".sam3-text-cascade__remove");
        if (removeButton) {
            removeButton.addEventListener("click", () => {
                step.remove();
                refreshSam3TextCascadeStepTitles();
            });
        }
        return step;
    }

    function addSam3TextCascadeStep(options = {}) {
        if (!sam3TextElements.cascadeSteps) {
            return;
        }
        const step = createSam3TextCascadeStep(options);
        sam3TextElements.cascadeSteps.appendChild(step);
        refreshSam3TextCascadeClassOptions();
        refreshSam3TextCascadeStepTitles();
    }

    function setSam3TextCascadeEnabled(enabled) {
        sam3TextCascadeEnabled = !!enabled;
        if (sam3TextElements.cascadePanel) {
            sam3TextElements.cascadePanel.hidden = !sam3TextCascadeEnabled;
        }
        if (sam3TextElements.cascadeToggleButton) {
            sam3TextElements.cascadeToggleButton.textContent = sam3TextCascadeEnabled ? "Exit cascade" : "Start cascade";
        }
        if (sam3TextCascadeEnabled && sam3TextElements.cascadeSteps && !sam3TextElements.cascadeSteps.children.length) {
            addSam3TextCascadeStep({ useCurrentDefaults: true });
        }
        refreshSam3TextCascadeStepTitles();
        updateSam3TextButtons();
    }

    function toggleSam3TextCascade() {
        setSam3TextCascadeEnabled(!sam3TextCascadeEnabled);
    }

    function clearSam3TextCascade() {
        if (!sam3TextElements.cascadeSteps) {
            return;
        }
        sam3TextElements.cascadeSteps.innerHTML = "";
        if (sam3TextCascadeEnabled) {
            addSam3TextCascadeStep({ useCurrentDefaults: true });
        }
    }

    function readSam3TextCascadeStep(step) {
        const prompt = (step.querySelector(".sam3-text-cascade__prompt")?.value || "").trim();
        let threshold = parseFloat(step.querySelector(".sam3-text-cascade__threshold")?.value || "0.5");
        if (Number.isNaN(threshold)) threshold = 0.5;
        threshold = Math.min(Math.max(threshold, 0), 1);
        let maskThreshold = parseFloat(step.querySelector(".sam3-text-cascade__mask")?.value || "0.5");
        if (Number.isNaN(maskThreshold)) maskThreshold = 0.5;
        maskThreshold = Math.min(Math.max(maskThreshold, 0), 1);
        let maxResults = parseInt(step.querySelector(".sam3-text-cascade__max-results")?.value || "20", 10);
        if (Number.isNaN(maxResults)) maxResults = 20;
        maxResults = Math.min(Math.max(maxResults, 1), 100);
        let minSize = parseInt(step.querySelector(".sam3-text-cascade__min-size")?.value || "0", 10);
        if (Number.isNaN(minSize) || minSize < 0) minSize = 0;
        let simplifyEps = parseFloat(step.querySelector(".sam3-text-cascade__epsilon")?.value || "1.0");
        if (Number.isNaN(simplifyEps) || simplifyEps < 0) simplifyEps = 1.0;
        const targetClass = step.querySelector(".sam3-text-cascade__class")?.value || "";
        return {
            prompt,
            threshold,
            maskThreshold,
            minSize,
            maxResults,
            simplifyEps,
            targetClass,
        };
    }

    function collectSam3TextCascadeSnapshots({ includeBase = false } = {}) {
        const steps = getSam3TextCascadeStepElements();
        const snapshots = [];
        let skipped = 0;
        if (includeBase) {
            const baseSnapshot = buildSam3TextSnapshot();
            if (baseSnapshot.prompt && baseSnapshot.targetClass) {
                snapshots.push(baseSnapshot);
            } else {
                skipped += 1;
            }
        }
        steps.forEach((step) => {
            const snapshot = readSam3TextCascadeStep(step);
            if (!snapshot.prompt || !snapshot.targetClass) {
                skipped += 1;
                return;
            }
            snapshots.push(snapshot);
        });
        return { snapshots, skipped, total: steps.length + (includeBase ? 1 : 0) };
    }

    async function runSam3TextCascadeSnapshots(snapshots, { shouldCancel = null, statusPrefix = "Cascade step" } = {}) {
        let totalAdded = 0;
        for (let idx = 0; idx < snapshots.length; idx += 1) {
            if (typeof shouldCancel === "function" && shouldCancel()) {
                break;
            }
            setSam3TextStatus(`${statusPrefix} ${idx + 1}/${snapshots.length}…`, "info");
            const result = await runSam3TextPromptSnapshot(snapshots[idx]);
            totalAdded += Number(result?.added || 0);
        }
        return totalAdded;
    }

    async function runSam3TextCascade() {
        if (sam3TextCascadeActive || sam3TextBatchActive || sam3TextRequestActive || sam3SimilarityRequestActive) {
            setSam3TextStatus("SAM3 is busy; wait for the current job to finish.", "warn");
            return;
        }
        if (!currentImage || !currentImage.name) {
            setSam3TextStatus("Load an image before running a cascade.", "warn");
            return;
        }
        const { snapshots, skipped, total } = collectSam3TextCascadeSnapshots({ includeBase: true });
        if (!snapshots.length) {
            setSam3TextStatus("Add at least one valid cascade step first.", "warn");
            return;
        }
        if (skipped) {
            setSam3TextStatus(`Skipping ${skipped} empty step${skipped === 1 ? "" : "s"} in cascade.`, "warn");
        }
        sam3TextCascadeActive = true;
        sam3TextCascadeCancel = false;
        updateSam3TextButtons();
        const taskId = enqueueTask({ kind: "sam3-cascade", imageName: currentImage.name, detail: { count: total } });
        let totalAdded = 0;
        try {
            totalAdded = await runSam3TextCascadeSnapshots(snapshots, {
                shouldCancel: () => sam3TextCascadeCancel,
                statusPrefix: "Cascade step",
            });
        } catch (error) {
            console.error("SAM3 cascade failed", error);
            setSam3TextStatus(`Cascade error: ${error.message || error}`, "error");
        } finally {
            sam3TextCascadeActive = false;
            updateSam3TextButtons();
            completeTask(taskId);
            const doneMessage = sam3TextCascadeCancel
                ? "Cascade cancelled."
                : `Cascade complete: added ${totalAdded} ${datasetType === "seg" ? "polygons" : "boxes"}.`;
            setSam3TextStatus(doneMessage, sam3TextCascadeCancel ? "warn" : "success");
            enqueueTaskNotice(doneMessage, { durationMs: 4500 });
        }
    }

    function stopSam3TextCascade() {
        if (!sam3TextCascadeActive) {
            return;
        }
        sam3TextCascadeCancel = true;
        setSam3TextStatus("Stopping cascade after current step…", "warn");
    }

    function getSam3TextCascadeBatchConfig() {
        const imageList = document.getElementById("imageList");
        if (!imageList || !imageList.options.length) {
            return null;
        }
        const includeCurrent = !!sam3TextElements.batchIncludeCurrentToggle?.checked;
        const countRaw = parseInt(sam3TextElements.batchCountInput?.value || "1", 10);
        const count = Number.isFinite(countRaw) ? Math.max(1, Math.min(999, countRaw)) : 1;
        const startIndex = Math.max(0, imageList.selectedIndex || 0);
        const names = [];
        for (let i = 0; i < count; i += 1) {
            const idx = includeCurrent ? startIndex + i : startIndex + i + 1;
            if (idx >= imageList.options.length) {
                break;
            }
            const name = getOptionImageName(imageList.options[idx]);
            if (name) {
                names.push(name);
            }
        }
        return names.length ? { names, includeCurrent } : null;
    }

    async function waitForCurrentImageReady(imageName, timeoutMs = 15000) {
        const start = Date.now();
        while (Date.now() - start < timeoutMs) {
            if (currentImage && currentImage.name === imageName && currentImage.object) {
                return true;
            }
            await yieldToDom(100);
        }
        return false;
    }

    async function startSam3TextBatch() {
        if (sam3TextBatchActive || sam3TextRequestActive || sam3SimilarityRequestActive || sam3TextCascadeActive) {
            setSam3TextStatus("SAM3 is busy; wait for the current job to finish.", "warn");
            return;
        }
        if (!currentImage || !currentImage.name) {
            setSam3TextStatus("Load an image before starting a batch run.", "warn");
            return;
        }
        const batchConfig = getSam3TextCascadeBatchConfig();
        if (!batchConfig) {
            setSam3TextStatus("No images found for the batch range.", "warn");
            return;
        }
        const { names } = batchConfig;
        const originalName = currentImage.name;
        const batchTaskId = enqueueTask({ kind: sam3TextCascadeEnabled ? "sam3-cascade" : "sam3-batch", imageName: originalName, detail: { count: names.length } });
        sam3TextBatchActive = true;
        sam3TextBatchCancel = false;
        updateSam3TextButtons();
        let totalAdded = 0;
        const cascadeConfig = sam3TextCascadeEnabled ? collectSam3TextCascadeSnapshots({ includeBase: true }) : null;
        if (sam3TextCascadeEnabled) {
            if (!cascadeConfig.snapshots.length) {
                setSam3TextStatus("Add at least one valid cascade step first.", "warn");
                sam3TextBatchActive = false;
                updateSam3TextButtons();
                completeTask(batchTaskId);
                return;
            }
            if (cascadeConfig.skipped) {
                setSam3TextStatus(`Skipping ${cascadeConfig.skipped} empty step${cascadeConfig.skipped === 1 ? "" : "s"} in cascade.`, "warn");
            }
        }
        const baseSnapshot = sam3TextCascadeEnabled ? null : buildSam3TextSnapshot();
        if (!sam3TextCascadeEnabled) {
            if (!baseSnapshot.prompt) {
                setSam3TextStatus("Enter a prompt before running a batch.", "warn");
                sam3TextElements.promptInput?.focus();
                sam3TextBatchActive = false;
                updateSam3TextButtons();
                completeTask(batchTaskId);
                return;
            }
            if (!baseSnapshot.targetClass) {
                setSam3TextStatus("Pick a class before running a batch.", "warn");
                sam3TextBatchActive = false;
                updateSam3TextButtons();
                completeTask(batchTaskId);
                return;
            }
        }
        try {
            for (let idx = 0; idx < names.length; idx += 1) {
                if (sam3TextBatchCancel) {
                    break;
                }
                const name = names[idx];
                setSam3TextStatus(`Batch ${idx + 1}/${names.length}: ${name}`, "info");
                setSamStatus(`SAM3 batch ${idx + 1}/${names.length}: ${name}`, { variant: "info", duration: 0 });
                const record = images[name];
                if (!record) {
                    continue;
                }
                await ensureImageRecordReady(record);
                if (!currentImage || currentImage.name !== name) {
                    setCurrentImage(record);
                }
                const ready = await waitForCurrentImageReady(name);
                if (!ready) {
                    setSam3TextStatus(`Batch ${idx + 1}/${names.length}: failed to load ${name}`, "warn");
                    continue;
                }
                try {
                    if (sam3TextCascadeEnabled) {
                        const added = await runSam3TextCascadeSnapshots(cascadeConfig.snapshots, {
                            shouldCancel: () => sam3TextBatchCancel,
                            statusPrefix: "Cascade step",
                        });
                        totalAdded += Number(added || 0);
                    } else {
                        const result = await runSam3TextPromptSnapshot(baseSnapshot);
                        totalAdded += Number(result?.added || 0);
                    }
                } catch (err) {
                    console.error("SAM3 batch step failed", err);
                    setSam3TextStatus(`Batch error on ${name}: ${err.message || err}`, "error");
                }
            }
        } finally {
            sam3TextBatchActive = false;
            updateSam3TextButtons();
            completeTask(batchTaskId);
            if (originalName && images[originalName] && (!currentImage || currentImage.name !== originalName)) {
                setCurrentImage(images[originalName]);
            }
            const doneMessage = sam3TextBatchCancel
                ? "Batch cancelled."
                : `Batch complete: added ${totalAdded} ${datasetType === "seg" ? "polygons" : "boxes"}.`;
            setSam3TextStatus(doneMessage, sam3TextBatchCancel ? "warn" : "success");
            enqueueTaskNotice(doneMessage, { durationMs: 5000 });
        }
    }

    function stopSam3TextBatch() {
        if (!sam3TextBatchActive) {
            return;
        }
        sam3TextBatchCancel = true;
        setSam3TextStatus("Stopping batch after current image…", "warn");
    }

    async function handleSam3TextRequest() {
        if (sam3TextRequestActive) {
            return;
        }
        if (sam3TextBatchActive || sam3TextCascadeActive) {
            setSam3TextStatus("Batch or cascade is running; wait for it to finish.", "warn");
            return;
        }
        if (!currentImage || !currentImage.name) {
            setSam3TextStatus("Load an image before running SAM3.", "warn");
            return;
        }
        const snapshot = buildSam3TextSnapshot();
        if (!snapshot.prompt) {
            setSam3TextStatus("Enter a prompt describing what to segment.", "warn");
            sam3TextElements.promptInput?.focus();
            return;
        }
        if (!snapshot.targetClass) {
            setSam3TextStatus("Pick a class to assign boxes to before running SAM3.", "warn");
            return;
        }
        sam3TextRequestActive = true;
        updateSam3TextButtons();
        setSam3TextStatus("Running SAM3…", "info");
        setSamStatus("Running SAM3 text prompt…", { variant: "info", duration: 0 });
        try {
            await runSam3TextPromptSnapshot(snapshot);
        } catch (error) {
            const detail = error?.message || error;
            setSam3TextStatus(`SAM3 error: ${detail}`, "error");
            console.error("SAM3 text prompt failed", error);
        } finally {
            sam3TextRequestActive = false;
            updateSam3TextButtons();
        }
    }

    async function handleSam3SimilarityPrompt() {
        if (sam3SimilarityRequestActive || sam3TextRequestActive || sam3TextBatchActive || sam3TextCascadeActive) {
            setSam3TextStatus("SAM3 is busy; wait for the current job to finish.", "warn");
            return;
        }
        if (!currentImage || !currentImage.name) {
            setSam3TextStatus("Load an image and select a bbox to use as the exemplar.", "warn");
            return;
        }
        const selectedRecords = getSelectedBboxRecords({ negative: false });
        const negativeRecords = getSelectedBboxRecords({ negative: true });
        const currentUuid = currentBbox && currentBbox.bbox ? currentBbox.bbox.uuid : null;
        const isCurrentNegative = currentUuid ? negativeBboxes.has(currentUuid) : false;
        const primary = currentBbox && currentBbox.bbox && !isCurrentNegative
            ? currentBbox.bbox
            : (selectedRecords[0] || null);
        if (!primary) {
            setSam3TextStatus("Select or draw a bbox to use as the similarity prompt.", "warn");
            return;
        }
        const targetClass = primary.class || null;
        if (!targetClass || typeof classes[targetClass] === "undefined") {
            setSam3TextStatus("The selected bbox has no valid class; pick a labeled bbox first.", "warn");
            return;
        }
        const promptCandidates = selectedRecords.length ? selectedRecords : [primary];
        const promptRects = [];
        const promptLabels = [];
        const seenUuids = new Set();
        promptCandidates.forEach((bbox) => {
            if (!bbox || bbox.class !== targetClass) {
                return;
            }
            if (bbox.uuid && seenUuids.has(bbox.uuid)) {
                return;
            }
            const width = Math.abs(bbox.width);
            const height = Math.abs(bbox.height);
            if (width < minBBoxWidth || height < minBBoxHeight) {
                return;
            }
            const left = Math.min(bbox.x, bbox.x + bbox.width);
            const top = Math.min(bbox.y, bbox.y + bbox.height);
            promptRects.push({ x: left, y: top, width, height });
            promptLabels.push(true);
            if (bbox.uuid) {
                seenUuids.add(bbox.uuid);
            }
        });
        negativeRecords.forEach((bbox) => {
            if (!bbox) {
                return;
            }
            if (bbox.uuid && seenUuids.has(bbox.uuid)) {
                return;
            }
            const width = Math.abs(bbox.width);
            const height = Math.abs(bbox.height);
            if (width < minBBoxWidth || height < minBBoxHeight) {
                return;
            }
            const left = Math.min(bbox.x, bbox.x + bbox.width);
            const top = Math.min(bbox.y, bbox.y + bbox.height);
            promptRects.push({ x: left, y: top, width, height });
            promptLabels.push(false);
            if (bbox.uuid) {
                seenUuids.add(bbox.uuid);
            }
        });
        if (!promptRects.length) {
            setSam3TextStatus("Exemplar bbox is too small or missing for similarity.", "warn");
            return;
        }
        let threshold = parseFloat(sam3TextElements.similarityThresholdInput?.value ?? sam3TextElements.thresholdInput?.value ?? "0.5");
        if (Number.isNaN(threshold)) threshold = 0.5;
        threshold = Math.min(Math.max(threshold, 0), 1);
        let maskThreshold = parseFloat(sam3TextElements.maskThresholdInput?.value || "0.5");
        if (Number.isNaN(maskThreshold)) maskThreshold = 0.5;
        maskThreshold = Math.min(Math.max(maskThreshold, 0), 1);
        let minSize = parseInt(sam3TextElements.minSizeInput?.value || "0", 10);
        if (Number.isNaN(minSize) || minSize < 0) minSize = 0;
        let maxResults = parseInt(sam3TextElements.maxResultsInput?.value || "20", 10);
        if (Number.isNaN(maxResults)) maxResults = 20;
        maxResults = Math.min(Math.max(maxResults, 1), 100);
        let simplifyEps = parseFloat(sam3TextElements.epsilonInput?.value || "1.0");
        if (Number.isNaN(simplifyEps) || simplifyEps < 0) simplifyEps = 1.0;

        function yoloBoxToPixelRect(yoloBox) {
            if (!currentImage || !Array.isArray(yoloBox) || yoloBox.length < 4) return null;
            const [cx, cy, wNorm, hNorm] = yoloBox.map(Number);
            const wPx = wNorm * currentImage.width;
            const hPx = hNorm * currentImage.height;
            return {
                x: cx * currentImage.width - wPx / 2,
                y: cy * currentImage.height - hPx / 2,
                width: wPx,
                height: hPx,
            };
        }

        function rectIoU(a, b) {
            const ax2 = a.x + a.width;
            const ay2 = a.y + a.height;
            const bx2 = b.x + b.width;
            const by2 = b.y + b.height;
            const ix = Math.max(0, Math.min(ax2, bx2) - Math.max(a.x, b.x));
            const iy = Math.max(0, Math.min(ay2, by2) - Math.max(a.y, b.y));
            const inter = ix * iy;
            if (inter <= 0) return 0;
            const union = a.width * a.height + b.width * b.height - inter;
            if (union <= 0) return 0;
            return inter / union;
        }

        function existingAnnotationRects() {
            const rects = [];
            const currentBboxes = bboxes[currentImage.name];
            if (!currentBboxes) return rects;
            for (let className in currentBboxes) {
                currentBboxes[className].forEach((bbox) => {
                    if (!bbox) return;
                    if (Array.isArray(bbox.points) && bbox.points.length >= 3) {
                        const xs = bbox.points.map((p) => p.x);
                        const ys = bbox.points.map((p) => p.y);
                        const minX = Math.min(...xs);
                        const maxX = Math.max(...xs);
                        const minY = Math.min(...ys);
                        const maxY = Math.max(...ys);
                        rects.push({ x: minX, y: minY, width: maxX - minX, height: maxY - minY });
                    } else {
                        rects.push({ x: bbox.x, y: bbox.y, width: bbox.width, height: bbox.height });
                    }
                });
            }
            return rects;
        }

        sam3SimilarityRequestActive = true;
        updateSam3TextButtons();
        const posCount = promptLabels.filter(Boolean).length;
        const negCount = promptLabels.length - posCount;
        const promptCountLabel = promptLabels.length > 1 ? ` (${posCount} pos / ${negCount} neg)` : "";
        setSam3TextStatus(`Running SAM3 similarity prompt${promptCountLabel}…`, "info");
        const similarityTaskId = enqueueTask({ kind: "sam-similarity", imageName: currentImage.name, detail: targetClass });
        const statusToken = beginSamActionStatus(`Running SAM3 similarity prompt${promptCountLabel}…`, { variant: "info" });
        try {
            const result = await invokeSam3VisualPrompt({
                bboxes: promptRects.map((rect) => [rect.x, rect.y, rect.width, rect.height]),
                bbox_labels: promptLabels,
                threshold,
                mask_threshold: maskThreshold,
                min_size: minSize,
                simplify_epsilon: simplifyEps,
                max_results: maxResults,
            });
            if (currentImage && result?.image_token) {
                rememberSamToken(currentImage.name, samVariant, result.image_token);
            }
            let detections = Array.isArray(result?.detections) ? result.detections.slice() : [];
            if (detections.length) {
                const exemplarInfos = promptRects.map((rect) => ({
                    rect,
                    cx: rect.x + rect.width / 2,
                    cy: rect.y + rect.height / 2,
                    maxDim: Math.max(rect.width, rect.height),
                }));
                const existingRects = existingAnnotationRects();
                detections = detections.filter((det) => {
                    if (!det || !det.bbox) return false;
                    const rect = yoloBoxToPixelRect(det.bbox);
                    if (!rect) return true;
                    const rectCx = rect.x + rect.width / 2;
                    const rectCy = rect.y + rect.height / 2;
                    for (const info of exemplarInfos) {
                        const dist = Math.hypot(rectCx - info.cx, rectCy - info.cy);
                        const iou = rectIoU(rect, info.rect);
                        const nearCenter = dist <= info.maxDim * 0.1;
                        const highOverlap = iou >= 0.85;
                        if (nearCenter || highOverlap) {
                            return false;
                        }
                    }
                    for (const existing of existingRects) {
                        const overlap = rectIoU(rect, existing);
                        if (overlap >= 0.75) {
                            return false;
                        }
                        const exCx = existing.x + existing.width / 2;
                        const exCy = existing.y + existing.height / 2;
                        const exMax = Math.max(existing.width, existing.height);
                        const distEx = Math.hypot(rectCx - exCx, rectCy - exCy);
                        if (distEx <= exMax * 0.1) {
                            return false;
                        }
                    }
                    return true;
                });
            }
            const added = applySegAwareDetections(detections, targetClass, "SAM3 similarity");
            if (added) {
                const shapeLabel = datasetType === "seg" ? "polygon" : "bbox";
                setSam3TextStatus(`Similarity added ${added} ${shapeLabel}${added === 1 ? "" : "es"}.`, "success");
                enqueueTaskNotice(`SAM3 similarity: added ${added} ${shapeLabel}${added === 1 ? "" : "es"} to ${targetClass}.`, { durationMs: 4500 });
            } else {
                const warning = Array.isArray(result?.warnings) && result.warnings.includes("no_results")
                    ? "SAM3 found no similar objects."
                    : "SAM3 returned no usable detections.";
                setSam3TextStatus(warning, "warn");
                enqueueTaskNotice("SAM3 similarity: no detections added.", { durationMs: 3500 });
            }
        } catch (error) {
            const detail = error?.message || error;
            setSam3TextStatus(`SAM3 similarity error: ${detail}`, "error");
            console.error("SAM3 similarity prompt failed", error);
        } finally {
            sam3SimilarityRequestActive = false;
            updateSam3TextButtons();
            completeTask(similarityTaskId);
            endSamActionStatus(statusToken);
        }
    }

    async function triggerSam3SimilarityHotkey() {
        if (!currentImage || !currentImage.name) {
            setSamStatus("Load an image before running SAM3 similarity.", { variant: "warn", duration: 2500 });
            return;
        }
        const selectedRecords = getSelectedBboxRecords({ negative: false });
        const currentUuid = currentBbox && currentBbox.bbox ? currentBbox.bbox.uuid : null;
        const isCurrentNegative = currentUuid ? negativeBboxes.has(currentUuid) : false;
        const exemplar = currentBbox && currentBbox.bbox && !isCurrentNegative
            ? currentBbox.bbox
            : (selectedRecords[0] || null);
        if (!exemplar) {
            setSamStatus("Select a bbox before running SAM3 similarity.", { variant: "warn", duration: 2500 });
            return;
        }
        const targetClass = exemplar.class;
        if (!targetClass || typeof classes[targetClass] === "undefined") {
            setSamStatus("Selected bbox has no valid class; pick a labeled bbox first.", { variant: "warn", duration: 2500 });
            return;
        }
        const slotEntry = findSlotStatusForImage(currentImage.name, "sam3");
        const sam3Loaded = !!(slotEntry && slotEntry.slot);
        if (!sam3Loaded) {
            if (samVariantSelect && samVariantSelect.value !== "sam3") {
                samVariantSelect.value = "sam3";
                samVariantSelect.dispatchEvent(new Event("change"));
            } else {
                samVariant = "sam3";
            }
            if (!samPreloadEnabled) {
                updateSamPreloadState(true);
            }
            prepareSamForCurrentImage({ messagePrefix: "Loading SAM3 predictor", immediate: true }).catch((err) => {
                console.debug("SAM3 preload for similarity failed", err);
            });
        }
        handleSam3SimilarityPrompt();
    }

    async function invokeQwenInfer(requestFields) {
        if (!currentImage) {
            throw new Error("No active image");
        }
        const imageNameForRequest = currentImage.name;
        const variantForRequest = samVariant;
        const preloadToken = await waitForSamPreloadIfActive(imageNameForRequest, variantForRequest);
        let payload = await buildSamImagePayload({ variantOverride: variantForRequest, preferredToken: preloadToken });
        if (imageNameForRequest && !payload.image_name) {
            payload.image_name = imageNameForRequest;
        }
        payload.sam_variant = variantForRequest;
        let resp = await fetch(`${API_ROOT}/qwen/infer`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ...requestFields, ...payload }),
        });
        if (resp.status === 428) {
            payload = await buildSamImagePayload({ forceBase64: true, variantOverride: variantForRequest, preferredToken: preloadToken });
            if (imageNameForRequest && !payload.image_name) {
                payload.image_name = imageNameForRequest;
            }
            payload.sam_variant = variantForRequest;
            resp = await fetch(`${API_ROOT}/qwen/infer`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ ...requestFields, ...payload }),
            });
        }
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || resp.statusText || `HTTP ${resp.status}`);
        }
        return resp.json();
    }

    async function invokeSam3TextPrompt(requestFields) {
        if (!currentImage) {
            throw new Error("No active image");
        }
        const imageNameForRequest = currentImage.name;
        const variantForRequest = "sam3";
        const preloadToken = await waitForSamPreloadIfActive(imageNameForRequest, variantForRequest);
        let payload = await buildSamImagePayload({ variantOverride: variantForRequest, preferredToken: preloadToken });
        if (imageNameForRequest && !payload.image_name) {
            payload.image_name = imageNameForRequest;
        }
        payload.sam_variant = variantForRequest;
        let resp = await fetch(`${API_ROOT}/sam3/text_prompt`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ...requestFields, ...payload }),
        });
        if (resp.status === 428) {
            payload = await buildSamImagePayload({ forceBase64: true, variantOverride: variantForRequest, preferredToken: preloadToken });
            if (imageNameForRequest && !payload.image_name) {
                payload.image_name = imageNameForRequest;
            }
            payload.sam_variant = variantForRequest;
            resp = await fetch(`${API_ROOT}/sam3/text_prompt`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ ...requestFields, ...payload }),
            });
        }
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || resp.statusText || `HTTP ${resp.status}`);
        }
        return resp.json();
    }

    async function invokeSam3VisualPrompt(requestFields) {
        if (!currentImage) {
            throw new Error("No active image");
        }
        const imageNameForRequest = currentImage.name;
        const variantForRequest = "sam3";
        const preloadToken = await waitForSamPreloadIfActive(imageNameForRequest, variantForRequest);
        let payload = await buildSamImagePayload({ variantOverride: variantForRequest, preferredToken: preloadToken });
        if (imageNameForRequest && !payload.image_name) {
            payload.image_name = imageNameForRequest;
        }
        payload.sam_variant = variantForRequest;
        if (Array.isArray(requestFields.bbox_labels) && !requestFields.bbox_labels.length) {
            delete requestFields.bbox_labels;
        }
        let resp = await fetch(`${API_ROOT}/sam3/visual_prompt`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ...requestFields, ...payload }),
        });
        if (resp.status === 428) {
            payload = await buildSamImagePayload({ forceBase64: true, variantOverride: variantForRequest, preferredToken: preloadToken });
            if (imageNameForRequest && !payload.image_name) {
                payload.image_name = imageNameForRequest;
            }
            payload.sam_variant = variantForRequest;
            resp = await fetch(`${API_ROOT}/sam3/visual_prompt`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ ...requestFields, ...payload }),
            });
        }
        if (!resp.ok) {
            const detail = await resp.text();
            throw new Error(detail || resp.statusText || `HTTP ${resp.status}`);
        }
        return resp.json();
    }

    function addYoloBoxFromQwen(yoloBox, className) {
        if (!currentImage || !Array.isArray(yoloBox) || yoloBox.length < 4) {
            return null;
        }
        const [cx, cy, wNorm, hNorm] = yoloBox.map(Number);
        if ([cx, cy, wNorm, hNorm].some((val) => Number.isNaN(val))) {
            return null;
        }
        const absW = wNorm * currentImage.width;
        const absH = hNorm * currentImage.height;
        const absX = cx * currentImage.width - absW / 2;
        const absY = cy * currentImage.height - absH / 2;
        const bboxRecord = {
            type: "bbox",
            x: absX,
            y: absY,
            width: absW,
            height: absH,
            marked: false,
            class: className,
            uuid: generateUUID(),
        };
        const valid = clampBbox(bboxRecord, currentImage.width, currentImage.height);
        if (!valid) {
            return null;
        }
        stampBboxCreation(bboxRecord);
        if (!bboxes[currentImage.name]) {
            bboxes[currentImage.name] = {};
        }
        if (!bboxes[currentImage.name][className]) {
            bboxes[currentImage.name][className] = [];
        }
        bboxes[currentImage.name][className].push(bboxRecord);
        return bboxRecord;
    }

    function addPolygonFromYoloRect(yoloBox, className) {
        if (!currentImage || !Array.isArray(yoloBox) || yoloBox.length < 4) {
            return null;
        }
        const [cx, cy, wNorm, hNorm] = yoloBox.map(Number);
        if ([cx, cy, wNorm, hNorm].some((val) => Number.isNaN(val))) {
            return null;
        }
        const absW = wNorm * currentImage.width;
        const absH = hNorm * currentImage.height;
        const absX = cx * currentImage.width - absW / 2;
        const absY = cy * currentImage.height - absH / 2;
        const pts = [
            { x: absX, y: absY },
            { x: absX + absW, y: absY },
            { x: absX + absW, y: absY + absH },
            { x: absX, y: absY + absH },
        ].map(clampPointToImage);
        const xs = pts.map((p) => p.x);
        const ys = pts.map((p) => p.y);
        const minX = Math.min(...xs);
        const maxX = Math.max(...xs);
        const minY = Math.min(...ys);
        const maxY = Math.max(...ys);
        const bboxRecord = {
            type: "polygon",
            points: pts,
            x: minX,
            y: minY,
            width: Math.max(0, maxX - minX),
            height: Math.max(0, maxY - minY),
            marked: false,
            class: className,
            uuid: generateUUID(),
        };
        stampBboxCreation(bboxRecord);
        if (!bboxes[currentImage.name]) {
            bboxes[currentImage.name] = {};
        }
        if (!bboxes[currentImage.name][className]) {
            bboxes[currentImage.name][className] = [];
        }
        bboxes[currentImage.name][className].push(bboxRecord);
        setDatasetType("seg");
        return bboxRecord;
    }

    function decodePackedMask(maskPayload) {
        if (!maskPayload || typeof maskPayload.counts !== "string") {
            return null;
        }
        const size = Array.isArray(maskPayload.size) ? maskPayload.size : [];
        if (size.length !== 2) {
            return null;
        }
        const height = parseInt(size[0], 10);
        const width = parseInt(size[1], 10);
        if (!Number.isFinite(width) || !Number.isFinite(height) || width <= 0 || height <= 0) {
            return null;
        }
        let packed;
        try {
            const raw = atob(maskPayload.counts);
            packed = new Uint8Array(raw.length);
            for (let i = 0; i < raw.length; i++) {
                packed[i] = raw.charCodeAt(i);
            }
        } catch (error) {
            console.warn("Failed to decode mask payload", error);
            return null;
        }
        const total = width * height;
        const data = new Uint8Array(total);
        let cursor = 0;
        for (let byteIdx = 0; byteIdx < packed.length && cursor < total; byteIdx++) {
            const byte = packed[byteIdx];
            for (let bit = 7; bit >= 0 && cursor < total; bit--) {
                data[cursor++] = (byte >> bit) & 1;
            }
        }
        return { data, width, height };
    }

    function getMinMaskArea() {
        const raw = sam3TextElements.minSizeInput?.value || "0";
        const parsed = parseFloat(raw);
        if (!Number.isFinite(parsed) || parsed < 0) {
            return 0;
        }
        return parsed;
    }

    function getMaxPolygonPoints() {
        const raw = sam3TextElements.maxPointsInput?.value || "500";
        const parsed = parseInt(raw, 10);
        if (!Number.isFinite(parsed) || parsed <= 3) {
            return 500;
        }
        return Math.min(parsed, 5000);
    }

    function getSimplifyEpsilon() {
        const rawSlider = polygonSimplifyInput ? parseFloat(polygonSimplifyInput.value) : null;
        const sliderValid = Number.isFinite(rawSlider);
        const sliderMin = 0;
        const sliderMax = 40;
        const clampedSlider = sliderValid ? Math.max(sliderMin, Math.min(sliderMax, rawSlider)) : null;
        // Invert: slider left (low) => higher detail (lower epsilon), slider right (high) => more simplification.
        const sliderEps = clampedSlider !== null ? sliderMax - clampedSlider : null;
        const rawFallback = sam3TextElements.epsilonInput?.value || "1.0";
        const parsedFallback = parseFloat(rawFallback);
        const fallbackEps = Number.isFinite(parsedFallback) && parsedFallback >= 0 ? parsedFallback : 1.0;
        return sliderEps !== null ? sliderEps : fallbackEps;
    }

    function simplifyPolygonPoints(points, { maxPoints = 400 } = {}) {
        if (!Array.isArray(points) || points.length === 0) {
            return [];
        }
        const deduped = [];
        points.forEach((pt) => {
            const last = deduped[deduped.length - 1];
            if (!last || Math.abs(last.x - pt.x) > 1e-6 || Math.abs(last.y - pt.y) > 1e-6) {
                deduped.push(pt);
            }
        });
        if (deduped.length > 1) {
            const first = deduped[0];
            const last = deduped[deduped.length - 1];
            if (Math.abs(first.x - last.x) < 1e-6 && Math.abs(first.y - last.y) < 1e-6) {
                deduped.pop();
            }
        }
        const reduced = [];
        for (let i = 0; i < deduped.length; i++) {
            const prev = deduped[(i - 1 + deduped.length) % deduped.length];
            const curr = deduped[i];
            const next = deduped[(i + 1) % deduped.length];
            const cross = (curr.x - prev.x) * (next.y - curr.y) - (curr.y - prev.y) * (next.x - curr.x);
            if (Math.abs(cross) > 1e-6) {
                reduced.push(curr);
            }
        }
        let result = reduced;
        if (result.length > maxPoints) {
            const step = Math.ceil(result.length / maxPoints);
            result = result.filter((_, idx) => idx % step === 0);
        }
        return result;
    }

    function polygonArea(points) {
        if (!Array.isArray(points) || points.length < 3) {
            return 0;
        }
        let area = 0;
        for (let i = 0; i < points.length; i++) {
            const j = (i + 1) % points.length;
            area += points[i].x * points[j].y - points[j].x * points[i].y;
        }
        return Math.abs(area / 2);
    }

    function douglasPeucker(points, epsilon) {
        if (!Array.isArray(points) || points.length < 3) {
            return points || [];
        }
        const sqEps = epsilon * epsilon;
        const distSqToSegment = (p, a, b) => {
            const dx = b.x - a.x;
            const dy = b.y - a.y;
            if (dx === 0 && dy === 0) {
                const ddx = p.x - a.x;
                const ddy = p.y - a.y;
                return ddx * ddx + ddy * ddy;
            }
            const t = Math.max(0, Math.min(1, ((p.x - a.x) * dx + (p.y - a.y) * dy) / (dx * dx + dy * dy)));
            const projX = a.x + t * dx;
            const projY = a.y + t * dy;
            const ddx = p.x - projX;
            const ddy = p.y - projY;
            return ddx * ddx + ddy * ddy;
        };
        const simplifySection = (pts, start, end, out) => {
            if (end <= start + 1) {
                return;
            }
            const a = pts[start];
            const b = pts[end];
            let maxDist = -1;
            let idx = -1;
            for (let i = start + 1; i < end; i++) {
                const d = distSqToSegment(pts[i], a, b);
                if (d > maxDist) {
                    maxDist = d;
                    idx = i;
                }
            }
            if (maxDist > sqEps) {
                simplifySection(pts, start, idx, out);
                out.push(pts[idx]);
                simplifySection(pts, idx, end, out);
            }
        };
        const output = [points[0]];
        simplifySection(points, 0, points.length - 1, output);
        output.push(points[points.length - 1]);
        return output;
    }

    function maskPayloadToPolygons(maskPayload, { maxPointsPerPolygon = 500, maxDim = 512, simplifyEpsilon = 1.0 } = {}) {
        const decoded = decodePackedMask(maskPayload);
        if (!decoded) {
            return [];
        }
        let { data, width, height } = decoded;
        let scaleX = 1;
        let scaleY = 1;
        const maxSide = Math.max(width, height);
        if (maxSide > maxDim) {
            const scale = maxSide / maxDim;
            const newW = Math.max(1, Math.round(width / scale));
            const newH = Math.max(1, Math.round(height / scale));
            const resized = new Uint8Array(newW * newH);
            const stride = width;
            for (let y = 0; y < newH; y++) {
                const srcY = Math.min(height - 1, Math.round(y * scale));
                for (let x = 0; x < newW; x++) {
                    const srcX = Math.min(width - 1, Math.round(x * scale));
                    resized[y * newW + x] = data[srcY * stride + srcX] ? 1 : 0;
                }
            }
            scaleX = width / newW;
            scaleY = height / newH;
            data = resized;
            width = newW;
            height = newH;
        }
        const closed = new Uint8Array(width * height);
        const getVal = (x, y) => (y >= 0 && y < height && x >= 0 && x < width && data[y * width + x]) ? 1 : 0;
        // Morphological close (3x3) with fallback to original if it erases everything
        let closedOnes = 0;
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                let ones = 0;
                for (let dy = -1; dy <= 1; dy++) {
                    for (let dx = -1; dx <= 1; dx++) {
                        if (getVal(x + dx, y + dy)) ones++;
                    }
                }
                const val = ones >= 5 ? 1 : 0;
                closed[y * width + x] = val;
                closedOnes += val;
            }
        }
        if (closedOnes === 0) {
            for (let i = 0; i < data.length; i++) {
                closed[i] = data[i];
            }
        }
        const visited = new Uint8Array(width * height);
        const components = [];
        const dirs4 = [
            [1, 0],
            [-1, 0],
            [0, 1],
            [0, -1],
        ];
        const floodFill = (sx, sy) => {
            const stack = [[sx, sy]];
            const pixels = [];
            visited[sy * width + sx] = 1;
            while (stack.length) {
                const [cx, cy] = stack.pop();
                pixels.push([cx, cy]);
                for (const [dx, dy] of dirs4) {
                    const nx = cx + dx;
                    const ny = cy + dy;
                    if (nx < 0 || ny < 0 || nx >= width || ny >= height) continue;
                    const idx = ny * width + nx;
                    if (visited[idx] || !closed[idx]) continue;
                    visited[idx] = 1;
                    stack.push([nx, ny]);
                }
            }
            return pixels;
        };
        const addEdge = (edgeMap, start, end) => {
            const key = `${start[0]},${start[1]}`;
            let bucket = edgeMap.get(key);
            if (!bucket) {
                bucket = [];
                edgeMap.set(key, bucket);
            }
            bucket.push({ end, used: false });
        };
        const buildPolygonFromEdges = (edgeMap) => {
            const polygons = [];
            for (const [startKey, edges] of edgeMap.entries()) {
                for (const edge of edges) {
                    if (edge.used) continue;
                    const startParts = startKey.split(",").map((v) => parseInt(v, 10));
                    if (startParts.length !== 2 || startParts.some((v) => Number.isNaN(v))) {
                        continue;
                    }
                    const polygon = [];
                    let current = [startParts[0], startParts[1]];
                    let guard = 0;
                    const guardLimit = edgeMap.size * 8 + 1000;
                    while (guard < guardLimit) {
                        polygon.push({ x: current[0] * scaleX, y: current[1] * scaleY });
                        const key = `${current[0]},${current[1]}`;
                        const bucket = edgeMap.get(key);
                        if (!bucket) break;
                        const nextEdge = bucket.find((e) => !e.used);
                        if (!nextEdge) break;
                        nextEdge.used = true;
                        current = nextEdge.end;
                        if (current[0] === startParts[0] && current[1] === startParts[1]) {
                            polygon.push({ x: current[0] * scaleX, y: current[1] * scaleY });
                            break;
                        }
                        guard++;
                    }
                    if (polygon.length >= 3) {
                        const simplified = douglasPeucker(polygon, simplifyEpsilon);
                        let capped = simplified;
                        if (capped.length > maxPointsPerPolygon) {
                            const step = Math.ceil(capped.length / maxPointsPerPolygon);
                            capped = capped.filter((_, idx) => idx % step === 0);
                        }
                        if (capped.length >= 3) {
                            polygons.push(capped);
                        }
                    }
                }
            }
            return polygons;
        };
        for (let y = 0; y < height; y++) {
            for (let x = 0; x < width; x++) {
                const idx = y * width + x;
                if (!closed[idx] || visited[idx]) continue;
                const pixels = floodFill(x, y);
                components.push(pixels);
            }
        }
        const allPolys = [];
        for (const pixels of components) {
            const compSet = new Set(pixels.map((p) => `${p[0]},${p[1]}`));
            const edgeMap = new Map();
            for (const [px, py] of pixels) {
                const idx = py * width + px;
                const neighbors = [
                    [px, py - 1],
                    [px + 1, py],
                    [px, py + 1],
                    [px - 1, py],
                ];
                const pts = [
                    [px, py],
                    [px + 1, py],
                    [px + 1, py + 1],
                    [px, py + 1],
                ];
                const inside = compSet.has(`${px},${py}`);
                for (let k = 0; k < neighbors.length; k++) {
                    const neighborKey = `${neighbors[k][0]},${neighbors[k][1]}`;
                    const neighborInside = compSet.has(neighborKey);
                    if (inside && !neighborInside) {
                        const start = pts[k];
                        const end = pts[(k + 1) % pts.length];
                        addEdge(edgeMap, start, end);
                    }
                }
            }
            const polys = buildPolygonFromEdges(edgeMap);
            polys.forEach((p) => allPolys.push(p));
        }
        // Deduplicate near-identical polygons
        const deduped = [];
        const seen = new Set();
        for (const poly of allPolys) {
            if (!poly || poly.length < 3) continue;
            const area = polygonArea(poly);
            const key = `${poly.length}:${poly[0].x.toFixed(1)},${poly[0].y.toFixed(1)}:${area.toFixed(1)}`;
            if (seen.has(key)) continue;
            seen.add(key);
            deduped.push(poly);
        }
        return deduped;
    }

    function addPolygonFromMask(maskPayload, className, { simplifyEpsilon = null, maxPointsPerPolygon = null, minArea = null } = {}) {
        if (!currentImage) {
            return null;
        }
        const uiEpsilon = getSimplifyEpsilon();
        const epsilon = Number.isFinite(uiEpsilon) && uiEpsilon >= 0
            ? uiEpsilon
            : (Number.isFinite(simplifyEpsilon) && simplifyEpsilon >= 0 ? simplifyEpsilon : 1.0);
        const maxPts = Number.isFinite(maxPointsPerPolygon) && maxPointsPerPolygon > 3 ? maxPointsPerPolygon : getMaxPolygonPoints();
        const minMaskArea = Number.isFinite(minArea) && minArea >= 0 ? minArea : Math.max(0, getMinMaskArea());
        const polygons = maskPayloadToPolygons(maskPayload, {
            maxPointsPerPolygon: maxPts,
            simplifyEpsilon: epsilon,
        });
        if (!Array.isArray(polygons) || polygons.length === 0) {
            return null;
        }
        const scored = polygons
            .map((pts) => {
                const clamped = pts.map(clampPointToImage);
                return { pts: clamped, area: polygonArea(clamped) };
            })
            .filter((entry) => entry.area > 0);
        if (scored.length === 0) {
            return null;
        }
        scored.sort((a, b) => b.area - a.area);
        const maxPolygons = 1;
        const minAreaThresh = minMaskArea;
        let firstRecord = null;
        if (!bboxes[currentImage.name]) {
            bboxes[currentImage.name] = {};
        }
        if (!bboxes[currentImage.name][className]) {
            bboxes[currentImage.name][className] = [];
        }
        for (let i = 0; i < scored.length && i < maxPolygons; i++) {
            const chosen = scored[i].pts;
            if (!chosen || chosen.length < 3) {
                continue;
            }
            if (scored[i].area < minAreaThresh) {
                continue;
            }
            const xs = chosen.map((p) => p.x);
            const ys = chosen.map((p) => p.y);
            const minX = Math.min(...xs);
            const maxX = Math.max(...xs);
            const minY = Math.min(...ys);
            const maxY = Math.max(...ys);
            const bboxRecord = {
                type: "polygon",
                points: chosen,
                x: minX,
                y: minY,
                width: Math.max(0, maxX - minX),
                height: Math.max(0, maxY - minY),
                marked: false,
                class: className,
                uuid: generateUUID(),
            };
            stampBboxCreation(bboxRecord);
            bboxes[currentImage.name][className].push(bboxRecord);
            if (!firstRecord) {
                firstRecord = bboxRecord;
            }
        }
        if (firstRecord) {
            setDatasetType("seg");
        }
        return firstRecord;
    }

    function addDetectionAnnotation(entry, className) {
        if (datasetType === "seg") {
            if (entry?.mask) {
                const epsVal = Number(entry.simplify_epsilon);
                const created = addPolygonFromMask(entry.mask, className, {
                    simplifyEpsilon: Number.isFinite(epsVal) && epsVal >= 0 ? epsVal : null,
                });
                if (created) {
                    return created;
                }
            }
            return addPolygonFromYoloRect(entry.bbox, className);
        }
        return addYoloBoxFromQwen(entry.bbox, className);
    }

    function applyDetectionsToClass(entries, className, sourceLabel = "Detector") {
        return applySegAwareDetections(entries, className, sourceLabel);
    }

    function applySegAwareDetections(entries, className, sourceLabel = "Detector") {
        if (!currentImage || !className || !Array.isArray(entries) || entries.length === 0) {
            return 0;
        }
        let added = 0;
        entries.forEach((entry) => {
            if (!entry || !entry.bbox) {
                return;
            }
            const created = addDetectionAnnotation(entry, className);
            if (!created) {
                return;
            }
            if (typeof entry.score === "number") {
                created.samScore = entry.score;
            }
            added += 1;
        });
        if (added > 0) {
            const shapeLabel = datasetType === "seg" ? "polygon" : "bbox";
            setSamStatus(`${sourceLabel} added ${added} ${shapeLabel}${added === 1 ? "" : "es"} to ${className}`, { variant: "success", duration: 4500 });
        }
        return added;
    }

    function applyQwenBoxes(boxes, className) {
        return applySegAwareDetections(boxes, className, "Qwen");
    }

    function applyApiRootValue(rawValue) {
        const normalized = normalizeApiRoot(rawValue);
        if (!normalized) {
            setSettingsStatus("Enter a valid http(s) URL (e.g. http://localhost:8000)", "error");
            return;
        }
        API_ROOT = normalized;
        try {
            localStorage.setItem(API_STORAGE_KEY, normalized);
        } catch (error) {
            console.debug("Failed to persist API root", error);
        }
        if (settingsElements.apiInput) {
            settingsElements.apiInput.value = normalized;
        }
        setSettingsStatus(`Backend set to ${normalized}`, "success");
        refreshQwenStatus({ silent: true }).catch((error) => {
            console.debug("Failed to refresh Qwen status", error);
        });
        loadQwenConfig(true).catch((error) => {
            console.debug("Failed to refresh Qwen config", error);
        });
    }

    async function testApiRootCandidate(rawValue) {
        const normalized = normalizeApiRoot(rawValue);
        if (!normalized) {
            setSettingsStatus("Enter a valid http(s) URL before testing", "error");
            return;
        }
        setSettingsStatus("Testing connection…", "info");
        try {
            const controller = new AbortController();
            const timeout = setTimeout(() => controller.abort(), 5000);
            const resp = await fetch(`${normalized}/sam_slots`, { signal: controller.signal });
            clearTimeout(timeout);
            if (!resp.ok) {
                throw new Error(`HTTP ${resp.status}`);
            }
            setSettingsStatus(`Connected to ${normalized}`, "success");
        } catch (error) {
            const detail = error?.name === "AbortError" ? "request timed out" : (error.message || error);
            setSettingsStatus(`Failed to reach ${normalized}: ${detail}`, "error");
        }
    }

    function handlePredictorApply(event) {
        if (event) {
            event.preventDefault();
        }
        if (!predictorElements.countInput) {
            return;
        }
        submitPredictorSettings(predictorElements.countInput.value);
    }

    function resetSamPreloadState() {
        const finishedImage = samPreloadCurrentImageName;
        const finishedVariant = samPreloadCurrentVariant;
        samPreloadCurrentImageName = null;
        samPreloadCurrentVariant = null;
        samPreloadQueuedKey = null;
        return { finishedImage, finishedVariant };
    }

    function resolveSamPreloadWaiters(imageName, variant) {
        if (imageName) {
            const variantsToNotify = new Set();
            if (variant) {
                variantsToNotify.add(variant);
            }
            variantsToNotify.add(samVariant);
            const imageKeySuffix = `::${imageName || ""}`;
            samPreloadWatchers.forEach((_, key) => {
                if (key.endsWith(imageKeySuffix)) {
                    const variantKey = key.slice(0, -imageKeySuffix.length) || "sam1";
                    variantsToNotify.add(variantKey);
                }
            });
            variantsToNotify.forEach((variantKey) => {
                notifySamPreloadWatchers(imageName, variantKey);
            });
        }
        resumeMultiPointQueueIfIdle();
    }

    function focusMultiPointPlaceholder(job) {
        if (!job?.placeholderContext) {
            currentBbox = null;
            return;
        }
        const { uuid, imageName } = job.placeholderContext;
        if (!currentImage || currentImage.name !== imageName) {
            currentBbox = null;
            return;
        }
        const classBuckets = bboxes[imageName];
        if (!classBuckets) {
            currentBbox = null;
            return;
        }
        for (const className of Object.keys(classBuckets)) {
            const bucket = classBuckets[className];
            const idx = bucket.findIndex((bbox) => bbox.uuid === uuid);
            if (idx !== -1) {
                const bbox = bucket[idx];
                currentBbox = {
                    bbox,
                    index: idx,
                    originalX: bbox.x,
                    originalY: bbox.y,
                    originalWidth: bbox.width,
                    originalHeight: bbox.height,
                    moving: false,
                    resizing: null,
                };
                return;
            }
        }
        currentBbox = null;
    }

    function scheduleMultiPointProcessing() {
        Promise.resolve()
            .then(() => processNextMultiPointJob())
            .catch((err) => {
                console.error("Multi-point queue error", err);
            });
    }

    function resumeMultiPointQueueIfIdle() {
        if (!multiPointWaitingForPreload) {
            return;
        }
        if (samPreloadCurrentImageName) {
            return;
        }
        if (multiPointPending) {
            return;
        }
        multiPointWaitingForPreload = false;
        if (multiPointQueue.length) {
            scheduleMultiPointProcessing();
        }
    }

    function enqueueMultiPointJob(job) {
        multiPointQueue.push(job);
        scheduleMultiPointProcessing();
    }

    async function processNextMultiPointJob() {
        if (multiPointPending) {
            return;
        }
        const job = multiPointQueue.shift();
        if (!job) {
            return;
        }
        if (samPreloadCurrentImageName && job.imageName && job.imageName === samPreloadCurrentImageName) {
            multiPointQueue.unshift(job);
            multiPointWaitingForPreload = true;
            return;
        }
        multiPointWaitingForPreload = false;
        if (!job.imageName || !currentImage || currentImage.name !== job.imageName) {
            if (job.placeholderContext) {
                removePendingBbox(job.placeholderContext);
            }
            return processNextMultiPointJob();
        }
        multiPointPending = true;
        multiPointPendingToken = job.requestToken;
        multiPointPendingBboxInfo = job.placeholderContext ? { ...job.placeholderContext } : null;
        focusMultiPointPlaceholder(job);
        const jobHandle = registerSamJob({
            type: job.auto ? "sam-multi-auto" : "sam-multi",
            imageName: job.imageName,
            cleanup: () => {
                if (job.placeholderContext) {
                    removePendingBbox(job.placeholderContext);
                }
            },
        });
        try {
            if (job.auto) {
                await samPointMultiAutoPrompt(job, jobHandle);
            } else {
                await samPointMultiPrompt(job, jobHandle);
            }
        } finally {
            completeSamJob(jobHandle.id);
            if (multiPointPendingToken === job.requestToken) {
                multiPointPending = false;
                multiPointPendingToken = null;
                multiPointPendingBboxInfo = null;
            }
            if (multiPointQueue.length) {
                scheduleMultiPointProcessing();
            }
        }
    }

    function getSamTokenKey(imageName, variant) {
        return `${variant || "sam1"}::${imageName || ""}`;
    }

    function rememberSamToken(imageName, variant, token) {
        if (!imageName || !token) {
            return;
        }
        samTokenCache.set(getSamTokenKey(imageName, variant), {
            token,
            timestamp: Date.now(),
        });
    }

    function forgetSamToken(imageName, variant) {
        if (!imageName) {
            return;
        }
        samTokenCache.delete(getSamTokenKey(imageName, variant));
    }

    function getSamToken(imageName, variant) {
        const entry = samTokenCache.get(getSamTokenKey(imageName, variant));
        return entry ? entry.token : null;
    }

    function getCurrentSamToken(variantOverride = null) {
        if (!currentImage) {
            return null;
        }
        const variant = variantOverride ?? samVariant;
        return getSamToken(currentImage.name, variant);
    }

    function isSamPreloadActiveFor(imageName, variant) {
        if (!imageName) {
            return false;
        }
        const targetKey = getSamTokenKey(imageName, variant || samVariant);
        if (!targetKey) {
            return false;
        }
        if (samPreloadQueuedKey && samPreloadQueuedKey === targetKey) {
            return true;
        }
        if (!samPreloadCurrentImageName) {
            return false;
        }
        const activeKey = getSamTokenKey(
            samPreloadCurrentImageName,
            samPreloadCurrentVariant || samVariant || variant,
        );
        return activeKey === targetKey;
    }

    function registerSamJob({ type, imageName, cleanup }) {
        const jobId = ++samJobSequence;
        const record = {
            id: jobId,
            type: type || "sam",
            imageName: imageName || null,
            version: samCancelVersion,
            cleanup: typeof cleanup === "function" ? cleanup : null,
            taskId: enqueueTask({ kind: type || "sam", imageName }),
        };
        samActiveJobs.set(jobId, record);
        return { id: jobId, version: record.version };
    }

    function completeSamJob(jobId) {
        const record = samActiveJobs.get(jobId);
        if (record && record.taskId) {
            completeTask(record.taskId);
        }
        samActiveJobs.delete(jobId);
    }

    function isSamJobActive(jobHandle) {
        if (!jobHandle) {
            return false;
        }
        const record = samActiveJobs.get(jobHandle.id);
        return Boolean(record) && record.version === samCancelVersion;
    }

    function cancelAllSamJobs({ reason = "cancelled", imageName = null, announce = true } = {}) {
        if (samActiveJobs.size === 0) {
            return { count: 0, message: null };
        }
        const jobs = Array.from(samActiveJobs.values());
        samActiveJobs.clear();
        samCancelVersion++;
        const count = jobs.length;
        const label = imageName ? ` from ${imageName}` : "";
        const reasonText = reason ? ` (${reason})` : "";
        const message = `Canceled ${count} SAM job${count === 1 ? "" : "s"}${label}${reasonText}`;
        jobs.forEach((job) => {
            if (job.taskId) {
                completeTask(job.taskId);
            }
            if (typeof job.cleanup === "function") {
                try {
                    job.cleanup();
                } catch (error) {
                    console.warn("SAM job cleanup failed", error);
                }
            }
        });
        if (announce && count > 0) {
            setSamStatus(message, { variant: "warn", duration: 5000 });
        }
        return { count, message };
    }

    function updateAutoModeState(checked) {
        autoMode = !!checked;
        if (autoModeCheckbox) {
            autoModeCheckbox.checked = autoMode;
        }
        syncAutoClassGuardControls();
        samAutoMode = samMode && autoMode;
        samPointAutoMode = pointMode && autoMode;
        samMultiPointAutoMode = multiPointMode && autoMode;
        console.log(
            "Auto class =>",
            autoMode,
            "samAutoMode =>",
            samAutoMode,
            "samPointAutoMode =>",
            samPointAutoMode,
            "samMultiPointAutoMode =>",
            samMultiPointAutoMode,
        );
    }

    function syncAutoClassGuardControls() {
        const autoEnabled = !!autoMode;
        if (autoClassMarginEnabledCheckbox) {
            autoClassMarginEnabledCheckbox.disabled = !autoEnabled;
        }
        const guardEnabled = autoEnabled && !!autoClassMarginEnabledCheckbox?.checked;
        if (autoClassMarginValueInput) {
            autoClassMarginValueInput.disabled = !guardEnabled;
        }
        if (autoClassMarginWarnCheckbox) {
            autoClassMarginWarnCheckbox.disabled = !guardEnabled;
        }
    }

    function getClipAutoGuardConfig() {
        const enabled = autoMode && !!autoClassMarginEnabledCheckbox?.checked;
        const marginRaw = autoClassMarginValueInput ? parseFloat(autoClassMarginValueInput.value) : NaN;
        const minMargin = Number.isFinite(marginRaw) ? Math.max(0, Math.min(1, marginRaw)) : 0;
        const warnAmbiguous = !!autoClassMarginWarnCheckbox?.checked;
        return { enabled, minMargin, warnAmbiguous };
    }

    function updatePointModeState(checked) {
        const enablePointMode = samMode && !!checked;
        pointMode = enablePointMode;
        if (pointModeCheckbox) {
            pointModeCheckbox.checked = pointMode;
            pointModeCheckbox.disabled = !samMode;
        }
        if (pointMode && multiPointMode) {
            updateMultiPointState(false);
        }
        samPointAutoMode = pointMode && autoMode;
        console.log("Point mode =>", pointMode, "samPointAutoMode =>", samPointAutoMode);
    }

    function cancelSamPreload(options = {}) {
        const preserveSet = toImageNameSet(options.preserveImages);
        samPreloadToken++;
        if (samPreloadAbortController) {
            samPreloadAbortController.abort();
            samPreloadAbortController = null;
        }
        abortSlotPreload("next", { preserveImages: preserveSet });
        abortSlotPreload("previous", { preserveImages: preserveSet });
        if (samPreloadTimer) {
            clearTimeout(samPreloadTimer);
            samPreloadTimer = null;
        }
        const label = samPreloadCurrentImageName;
        if (label) {
            setSamStatus(`Canceled SAM preload for ${label}`, { variant: "warn", duration: 2500 });
        }
        const { finishedImage, finishedVariant } = resetSamPreloadState();
        hideSamPreloadProgress();
        resolveSamPreloadWaiters(finishedImage, finishedVariant);
        scheduleSamSlotStatusRefresh(true);
    }

    function updateSamPreloadState(checked) {
        samPreloadEnabled = !!checked;
        if (samPreloadCheckbox) {
            samPreloadCheckbox.checked = samPreloadEnabled;
        }
        if (!samPreloadEnabled) {
            samPreloadLastKey = null;
            cancelSamPreload();
            abortSlotPreload("next");
            abortSlotPreload("previous");
            return;
        }
        if (currentImage && currentImage.object) {
            ensureSamSlotsSupport().finally(() => {
                scheduleSamPreload({ force: true, immediate: true });
                if (samSlotsEnabled) {
                    scheduleSamSlotStatusRefresh(true);
                }
            });
        }
        syncActiveApplyAvailability();
    }

    function scheduleSamPreload(options = {}) {
        if (!samPreloadEnabled || !currentImage || !currentImage.object) {
            hideSamPreloadProgress();
            return;
        }
        if (samPreloadTimer) {
            clearTimeout(samPreloadTimer);
        }
        const variantSnapshot = options.variant || samVariant;
        const targetKey = getSamTokenKey(currentImage.name, variantSnapshot);
        if (!options.force && targetKey) {
            const activeKey = samPreloadCurrentImageName
                ? getSamTokenKey(samPreloadCurrentImageName, samPreloadCurrentVariant || samVariant || variantSnapshot)
                : null;
            if (targetKey === samPreloadQueuedKey || targetKey === activeKey) {
                if (options.messagePrefix) {
                    setSamStatus(`${options.messagePrefix}: continuing SAM preload`, { variant: "info", duration: 2000 });
                }
                showSamPreloadProgress();
                return;
            }
        }
        const delay = typeof options.delayMs === "number"
            ? Math.max(0, options.delayMs)
            : (options.immediate ? 0 : SAM_PRELOAD_DEBOUNCE_MS);
        const targetImage = currentImage;
        const targetVersion = targetImage._loadVersion || 0;
        const generation = ++samPreloadGeneration;
        const requestOptions = {
            force: Boolean(options.force),
            messagePrefix: options.messagePrefix || null,
            imageRef: targetImage,
            version: targetVersion,
            queuedAt: Date.now(),
            generation,
            variant: variantSnapshot,
            queueKey: targetKey,
            taskId: null,
        };
        if (targetImage?.meta?.name) {
            requestOptions.taskId = enqueueTask({
                kind: "sam-preload",
                imageName: targetImage.meta.name,
                detail: options.slot || "curr",
            });
        }
        if (samSlotsEnabled) {
            requestOptions.slot = options.slot || "current";
        }
        samPreloadQueuedKey = targetKey;
        samPreloadTimer = setTimeout(() => {
            samPreloadTimer = null;
            executeSamPreload(requestOptions).catch((err) => {
                console.warn("SAM preload error", err);
            });
        }, delay);
    }

    async function executeSamPreload(options) {
        if (options.queueKey && samPreloadQueuedKey === options.queueKey) {
            samPreloadQueuedKey = null;
        }
        const startTime = Date.now();
        const elapsed = startTime - (options.queuedAt || startTime);
        if (elapsed > 3000) {
            completeTask(options.taskId);
            return;
        }
        if (options.generation && options.generation < samPreloadGeneration) {
            hideSamPreloadProgress();
            resumeMultiPointQueueIfIdle();
            completeTask(options.taskId);
            return;
        }
        if (!samPreloadEnabled) {
            hideSamPreloadProgress();
            resumeMultiPointQueueIfIdle();
            completeTask(options.taskId);
            return;
        }
        const activeImage = currentImage;
        if (!activeImage || !options || activeImage !== options.imageRef || (activeImage._loadVersion || 0) !== options.version || !activeImage.object) {
            const { finishedImage, finishedVariant } = resetSamPreloadState();
            hideSamPreloadProgress();
            resolveSamPreloadWaiters(finishedImage, finishedVariant);
            completeTask(options.taskId);
            return;
        }
        const variantSnapshot = options.variant || samVariant;
        const imageSnapshot = activeImage;
        const imageKey = `${imageSnapshot.name || ""}::${variantSnapshot}`;
        const cachedToken = getSamToken(imageSnapshot.name, variantSnapshot);
        const useTokenOnly = !options.force && Boolean(cachedToken);
        samPreloadLastKey = imageKey;

        const newToken = ++samPreloadToken;
        samPreloadLastKey = imageKey;
        let canceledLabel = null;
        if (samPreloadAbortController) {
            samPreloadAbortController.abort();
            canceledLabel = samPreloadCurrentImageName;
        }
        const controller = new AbortController();
        samPreloadAbortController = controller;
        const preloadLabel = imageSnapshot.name || "(unnamed)";
        samPreloadCurrentImageName = preloadLabel;
        samPreloadCurrentVariant = variantSnapshot;
        const prefixPieces = [];
        if (options.messagePrefix) {
            prefixPieces.push(options.messagePrefix);
        }
        if (canceledLabel) {
            prefixPieces.push(`Canceled SAM preload for ${canceledLabel}`);
        }
        const prefixText = prefixPieces.length ? `${prefixPieces.join(" — ")} — ` : "";
        setSamStatus(`${prefixText}Preloading SAM: ${preloadLabel}`, { variant: "info", duration: 0 });
        showSamPreloadProgress();

        let releaseSlotLoading = null;
        try {
            const slotLabel = samSlotsEnabled ? (options.slot || "current") : "current";
            const requestBody = { sam_variant: variantSnapshot };
            if (samSlotsEnabled && slotLabel) {
                requestBody.slot = slotLabel;
            }
            if (samSlotsEnabled && imageSnapshot?.name) {
                requestBody.image_name = imageSnapshot.name;
            }
            let tokenUsed = false;
            if (useTokenOnly) {
                requestBody.image_token = cachedToken;
                tokenUsed = true;
            } else {
                let base64Img;
                if (imageSnapshot.dataUrl && imageSnapshot.dataUrl.includes(',')) {
                    base64Img = imageSnapshot.dataUrl.split(',')[1];
                } else {
                    base64Img = await extractBase64ForImage(imageSnapshot);
                }
                if (newToken !== samPreloadToken) {
                    hideSamPreloadProgress();
                    resumeMultiPointQueueIfIdle();
                    completeTask(options.taskId);
                    return;
                }
                requestBody.image_base64 = base64Img;
            }
            if (options.generation) {
                requestBody.preload_generation = options.generation;
            }

            if (!releaseSlotLoading && imageSnapshot?.name) {
                releaseSlotLoading = beginImageSlotLoading(imageSnapshot.name, slotLabel || "current");
            }

            let resp = await fetch(`${API_ROOT}/sam_preload`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(requestBody),
                signal: controller.signal,
            });

            if (resp.status === 409) {
                const { finishedImage, finishedVariant } = resetSamPreloadState();
                hideSamPreloadProgress();
                resolveSamPreloadWaiters(finishedImage, finishedVariant);
                completeTask(options.taskId);
                return;
            }

            if (tokenUsed && resp.status === 404) {
                forgetSamToken(imageSnapshot.name, variantSnapshot);
                let base64Img;
                if (imageSnapshot.dataUrl && imageSnapshot.dataUrl.includes(',')) {
                    base64Img = imageSnapshot.dataUrl.split(',')[1];
                } else {
                    base64Img = await extractBase64ForImage(imageSnapshot);
                }
                if (newToken !== samPreloadToken) {
                    hideSamPreloadProgress();
                    resumeMultiPointQueueIfIdle();
                    return;
                }
                const fallbackBody = {
                    image_base64: base64Img,
                    sam_variant: variantSnapshot,
                    preload_generation: options.generation || null,
                };
                if (samSlotsEnabled && slotLabel) {
                    fallbackBody.slot = slotLabel;
                }
                if (samSlotsEnabled && imageSnapshot?.name) {
                    fallbackBody.image_name = imageSnapshot.name;
                }
                resp = await fetch(`${API_ROOT}/sam_preload`, {
                    method: "POST",
                    headers: { "Content-Type": "application/json" },
                    body: JSON.stringify(fallbackBody),
                    signal: controller.signal,
                });
                if (resp.status === 409) {
                    const { finishedImage, finishedVariant } = resetSamPreloadState();
                    hideSamPreloadProgress();
                    resolveSamPreloadWaiters(finishedImage, finishedVariant);
                    completeTask(options.taskId);
                    return;
                }
            }

            if (!resp.ok) {
                const text = await resp.text();
                throw new Error(text || `HTTP ${resp.status}`);
            }
            const result = await resp.json();
            if (result?.status === "superseded") {
                const { finishedImage, finishedVariant } = resetSamPreloadState();
                hideSamPreloadProgress();
                resolveSamPreloadWaiters(finishedImage, finishedVariant);
                completeTask(options.taskId);
                return;
            }
            if (newToken === samPreloadToken) {
                if (result?.token && imageSnapshot?.name) {
                    rememberSamToken(imageSnapshot.name, variantSnapshot, result.token);
                }
                const { finishedImage, finishedVariant } = resetSamPreloadState();
                setSamStatus(`Image ${preloadLabel} loaded in SAM`, { variant: "success", duration: 3000 });
                hideSamPreloadProgress();
                resolveSamPreloadWaiters(finishedImage, finishedVariant);
                if (slotLabel === "current" && imageSnapshot?.name) {
                    triggerNeighborSlotPreloads(imageSnapshot.name);
                    scheduleSamSlotStatusRefresh(true);
                }
                completeTask(options.taskId);
            }
        } catch (error) {
            if (error && error.name === "AbortError") {
                hideSamPreloadProgress();
                resumeMultiPointQueueIfIdle();
                completeTask(options.taskId);
                return;
            }
            console.warn("SAM preload failed", error);
            if (imageKey === samPreloadLastKey) {
                samPreloadLastKey = null;
            }
            const { finishedImage, finishedVariant } = resetSamPreloadState();
            if (imageSnapshot?.name) {
                forgetSamToken(imageSnapshot.name, variantSnapshot);
            }
            const detail = error && error.message ? error.message : String(error);
            setSamStatus(`SAM preload failed for ${preloadLabel}: ${detail}`, { variant: "error", duration: 6000 });
            hideSamPreloadProgress();
            resolveSamPreloadWaiters(finishedImage, finishedVariant);
            completeTask(options.taskId);
        } finally {
            if (typeof releaseSlotLoading === "function") {
                releaseSlotLoading();
            }
            if (samPreloadAbortController === controller) {
                samPreloadAbortController = null;
            }
        }
    }

    function updateMultiPointState(checked, options = {}) {
        const enableMultiPoint = samMode && !!checked;
        const { preservePoints = false } = options;
        multiPointMode = enableMultiPoint;
        if (multiPointModeCheckbox) {
            multiPointModeCheckbox.checked = multiPointMode;
            multiPointModeCheckbox.disabled = !samMode;
        }
        if (multiPointMode && pointMode) {
            updatePointModeState(false);
        }
        if (!multiPointMode) {
            cancelPendingMultiPoint({ clearMarkers: !preservePoints, removePendingBbox: true });
        }
        samMultiPointAutoMode = multiPointMode && autoMode;
        console.log("Multi-point mode =>", multiPointMode, "samMultiPointAutoMode =>", samMultiPointAutoMode);
    }

    function updateSamModeState(checked, options = {}) {
        const { preservePoints = false } = options;
        samMode = !!checked;
        if (samModeCheckbox) {
            samModeCheckbox.checked = samMode;
        }
        samAutoMode = samMode && autoMode;
        if (!samMode) {
            updatePointModeState(false);
            updateMultiPointState(false, { preservePoints });
            cancelAllSamJobs({ reason: "SAM off", imageName: currentImage ? currentImage.name : null });
        } else {
            if (pointModeCheckbox) {
                pointModeCheckbox.disabled = false;
            }
            if (multiPointModeCheckbox) {
                multiPointModeCheckbox.disabled = false;
            }
        }
        refreshPolygonDetailVisibility();
        refreshSam3SimilarityVisibility();
        console.log("SAM mode =>", samMode, "samAutoMode =>", samAutoMode);
    }

    function normalizeClassNameForMatch(name) {
        return String(name || "")
            .trim()
            .toLowerCase()
            .replace(/[^a-z0-9]+/g, "");
    }

    function findClipHeadTargetIndex(classesList, className) {
        if (!Array.isArray(classesList) || !classesList.length) {
            return null;
        }
        const target = normalizeClassNameForMatch(className);
        if (!target) {
            return null;
        }
        for (let idx = 0; idx < classesList.length; idx += 1) {
            if (normalizeClassNameForMatch(classesList[idx]) === target) {
                return idx;
            }
        }
        return null;
    }

	    function renderAgentResults(result) {
	        if (!agentElements.results) return;
	        agentElements.results.innerHTML = "";
	        if (!result || !Array.isArray(result.classes)) {
	            setAgentResultsMessage("No agent mining results yet.", "warn");
	            return;
	        }
	        const frag = document.createDocumentFragment();
		        result.classes.forEach((cls) => {
		            const card = document.createElement("details");
		            card.className = "training-card";
		            card.open = false;
		            const summaryEl = document.createElement("summary");
		            const body = document.createElement("div");
		            body.className = "training-card__body";
		            const recipe = cls.recipe || {};
		            const steps = Array.isArray(recipe.steps) ? recipe.steps : [];
		            const prompts = Array.isArray(recipe.text_prompts) ? recipe.text_prompts : [];
		            const params = recipe.params || {};
		            const summary = recipe.summary || {};
		            const schemaVersion =
		                recipe && (Number.isFinite(recipe.schema_version) ? recipe.schema_version : Number.isFinite(recipe.schemaVersion) ? recipe.schemaVersion : null);
		            const isStepRecipeV2 = recipe && (recipe.mode === "sam3_steps" || schemaVersion === 2);

	            const totalGt = Number.isFinite(summary.gts) ? summary.gts : (Number.isFinite(summary.total_gt) ? summary.total_gt : 0);
	            const matched = Number.isFinite(summary.matches) ? summary.matches : (Number.isFinite(summary.covered) ? summary.covered : 0);
	            const recall = Number.isFinite(summary.recall) ? summary.recall : (Number.isFinite(summary.coverage_rate) ? summary.coverage_rate : 0);
	            const precision = Number.isFinite(summary.precision) ? summary.precision : 0;
	            const fps = Number.isFinite(summary.fps) ? summary.fps : 0;
	            const duplicates = Number.isFinite(summary.duplicates) ? summary.duplicates : 0;
	            const detRate = Number.isFinite(summary.det_rate) ? summary.det_rate : 0;

	            const covPct = Number.isFinite(recall) ? (recall * 100).toFixed(1) : "0.0";
	            const precPct = Number.isFinite(precision) ? (precision * 100).toFixed(1) : "0.0";
	            const detPct = Number.isFinite(detRate) ? (detRate * 100).toFixed(1) : "0.0";
		            const modeLabel = isStepRecipeV2 ? "sam3_steps" : recipe.mode || (steps.length ? "legacy" : "sam3_greedy");
	            const displayName = escapeHtml(cls.name || cls.id);
	            const showIdSuffix = !!(cls.name && cls.id !== undefined && cls.id !== null && String(cls.id).length);

	            summaryEl.innerHTML = `
	                <div class="training-card__title">
	                    ${displayName}${showIdSuffix ? ` <span class="training-help" style="font-weight: 400;" title="Dataset category id (COCO category_id). This may differ from your labelmap index.">(cat id ${escapeHtml(cls.id)})</span>` : ""}
	                    <span class="badge" style="margin-left: 8px;">${escapeHtml(modeLabel)}</span>
	                </div>
	                <div class="training-help" style="font-weight: 400;">
	                    Coverage: ${matched}/${totalGt} (${covPct}%) • Precision: ${precPct}% • FPs: ${fps} • Duplicates: ${duplicates} • Det rate: ${detPct}%
	                </div>
	            `;
	            card.appendChild(summaryEl);

	            const evalGt = Number.isFinite(cls.eval_gt) ? cls.eval_gt : (Number.isFinite(summary.gts) ? summary.gts : 0);
	            body.innerHTML = `<div class="training-help">GT eval: ${evalGt}</div>`;

		            const configBits = [];
            if (recipe.clip_head) {
                const head = recipe.clip_head || {};
                const headClasses = Array.isArray(head.classes) ? head.classes : [];
                const nClasses = headClasses.length ? headClasses.length : null;
                const minProb = Number.isFinite(head.min_prob) ? head.min_prob : null;
		                const margin = Number.isFinite(head.margin) ? head.margin : null;
		                const autoTuned = !!head.auto_tuned;
		                const targetPrecision = Number.isFinite(head.target_precision) ? head.target_precision : null;
		                const meetsTarget =
		                    typeof summary.clip_head_meets_target_precision === "boolean"
		                        ? summary.clip_head_meets_target_precision
		                        : null;
		                const parts = ["pretrained CLIP head"];
		                const headIdx = findClipHeadTargetIndex(headClasses, cls.name || recipe.class_name || "");
		                if (nClasses) parts.push(`${nClasses} classes`);
		                if (headIdx !== null) parts.push(`head idx ${headIdx}`);
		                if (minProb !== null) parts.push(`p≥${minProb}`);
		                if (margin !== null && margin > 0) parts.push(`Δ≥${margin}`);
                if (autoTuned && targetPrecision !== null) {
                    const suffix = meetsTarget === false ? " (missed)" : meetsTarget === true ? " (met)" : "";
                    parts.push(`tune prec≥${targetPrecision}${suffix}`);
                }
                configBits.push(parts.join(" "));
            }
            const bgGuard =
                typeof params.clip_head_background_guard === "boolean"
                    ? params.clip_head_background_guard
                    : typeof summary.clip_head_background_guard === "boolean"
                      ? summary.clip_head_background_guard
                      : false;
            const bgMargin =
                Number.isFinite(params.clip_head_background_margin)
                    ? params.clip_head_background_margin
                    : Number.isFinite(summary.clip_head_background_margin)
                      ? summary.clip_head_background_margin
                      : null;
            const bgApply =
                typeof params.clip_head_background_apply === "string" && params.clip_head_background_apply
                    ? params.clip_head_background_apply
                    : typeof summary.clip_head_background_apply === "string" && summary.clip_head_background_apply
                      ? summary.clip_head_background_apply
                      : null;
            const bgPenalty =
                Number.isFinite(params.clip_head_background_penalty)
                    ? params.clip_head_background_penalty
                    : Number.isFinite(summary.clip_head_background_penalty)
                      ? summary.clip_head_background_penalty
                      : null;
            if (bgGuard) {
                const bgBits = ["bg guard"];
                if (bgMargin !== null && Number(bgMargin) > 0) bgBits.push(`Δbg≥${Number(bgMargin)}`);
                if (bgApply) bgBits.push(`apply ${bgApply}`);
                if (bgPenalty !== null && Number(bgPenalty) > 0) bgBits.push(`penalty ${Number(bgPenalty)}`);
                configBits.push(bgBits.join(" "));
            }
            if (typeof params.seed_threshold === "number") configBits.push(`base text thr ${params.seed_threshold}`);
            if (typeof params.expand_threshold === "number") configBits.push(`base visual thr ${params.expand_threshold}`);
            if (typeof params.max_visual_seeds === "number") configBits.push(`base candidates ${params.max_visual_seeds}`);
		            if (configBits.length) {
		                const meta = document.createElement("div");
		                meta.className = "training-help";
			                let promptBits = `Prompts: ${prompts.length}`;
			                if (isStepRecipeV2) {
			                    const uniq = new Set();
			                    steps.forEach((step) => {
			                        if (!step || typeof step !== "object") return;
		                        const p = typeof step.prompt === "string" ? step.prompt.trim() : "";
		                        if (p) uniq.add(p.toLowerCase());
		                        if (Array.isArray(step.prompts)) {
		                            step.prompts.forEach((raw) => {
		                                const s = typeof raw === "string" ? raw.trim() : "";
			                                if (s) uniq.add(s.toLowerCase());
			                            });
			                        }
			                    });
			                    promptBits = `Steps: ${steps.length} • Step prompts: ${uniq.size} • Prompt pool: ${prompts.length}`;
			                }
			                meta.textContent = `${promptBits} • ${configBits.join(" • ")}`;
		                body.appendChild(meta);
		            }

            const prefilterSummary = summary.prompt_prefilter && typeof summary.prompt_prefilter === "object" ? summary.prompt_prefilter : null;
            const promptBgDropSummary =
                summary.prompt_bg_drop && typeof summary.prompt_bg_drop === "object" ? summary.prompt_bg_drop : null;
            const earlyStopSummary = summary.early_stop && typeof summary.early_stop === "object" ? summary.early_stop : null;
            const bgSeedRate = Number.isFinite(summary.bg_veto_rate_seed) ? Number(summary.bg_veto_rate_seed) : null;
            const bgFinalRate = Number.isFinite(summary.bg_veto_rate_final) ? Number(summary.bg_veto_rate_final) : null;
            const bgSeedCount = Number.isFinite(summary.bg_veto_seed) ? Number(summary.bg_veto_seed) : null;
            const bgFinalCount = Number.isFinite(summary.bg_veto_final) ? Number(summary.bg_veto_final) : null;
            const hardNegSummary =
                summary.hard_negative_export && typeof summary.hard_negative_export === "object"
                    ? summary.hard_negative_export
                    : null;
            const bgGuardEnabled =
                typeof summary.clip_head_background_guard === "boolean"
                    ? summary.clip_head_background_guard
                    : typeof params.clip_head_background_guard === "boolean"
                      ? params.clip_head_background_guard
                      : false;
            const bgSummary = bgGuardEnabled && (bgSeedRate !== null || bgFinalRate !== null || bgSeedCount !== null || bgFinalCount !== null);
            if (prefilterSummary || promptBgDropSummary || earlyStopSummary || bgSummary || hardNegSummary) {
                const block = document.createElement("div");
                block.className = "training-subsection";
                const title = document.createElement("div");
                title.className = "training-subsection__title";
                title.textContent = "Run summary";
                block.appendChild(title);

                if (prefilterSummary) {
		                    const enabled = !!prefilterSummary.enabled;
		                    const mode = prefilterSummary.mode || "balanced";
		                    const total = Number.isFinite(prefilterSummary.total) ? prefilterSummary.total : null;
		                    const kept = Number.isFinite(prefilterSummary.kept) ? prefilterSummary.kept : null;
		                    const bits = [];
		                    bits.push("Prompt prefilter");
		                    if (enabled) {
		                        if (kept !== null && total !== null) bits.push(`kept ${kept}/${total}`);
		                        bits.push(mode);
		                    } else {
		                        const reason = prefilterSummary.disabled_reason;
		                        if (reason === "head_encoder_not_clip") {
		                            bits.push("disabled (non-CLIP head)");
		                        } else {
		                            bits.push("off");
		                        }
		                    }
		                    const line = document.createElement("div");
		                    line.className = "training-help";
		                    line.textContent = bits.join(" • ");
		                    block.appendChild(line);
		                }

                if (earlyStopSummary) {
                    const enabled = !!earlyStopSummary.enabled;
                    const mode = earlyStopSummary.mode || "balanced";
                    const maxSteps = Number.isFinite(earlyStopSummary.max_steps) ? earlyStopSummary.max_steps : null;
                    const selectedSteps =
		                        Number.isFinite(earlyStopSummary.selected_steps_final)
		                            ? earlyStopSummary.selected_steps_final
		                            : Number.isFinite(earlyStopSummary.selected_steps)
		                              ? earlyStopSummary.selected_steps
		                              : null;
		                    const triggered = typeof earlyStopSummary.triggered === "boolean" ? earlyStopSummary.triggered : null;
		                    const reason = earlyStopSummary.reason || "";
		                    const bits = [];
		                    bits.push("Early-stop");
		                    if (enabled) {
		                        if (selectedSteps !== null && maxSteps !== null) bits.push(`${selectedSteps}/${maxSteps} steps`);
		                        bits.push(mode);
		                        if (triggered === true && reason) bits.push(`triggered (${reason})`);
		                    } else {
		                        bits.push("off");
		                    }
		                    const line = document.createElement("div");
		                    line.className = "training-help";
                    line.textContent = bits.join(" • ");
                    block.appendChild(line);
                }

                if (promptBgDropSummary) {
                    const enabled = !!promptBgDropSummary.enabled;
                    const mode = promptBgDropSummary.mode || "balanced";
                    const total = Number.isFinite(promptBgDropSummary.total) ? promptBgDropSummary.total : null;
                    const dropped = Number.isFinite(promptBgDropSummary.dropped) ? promptBgDropSummary.dropped : null;
                    const bits = [];
                    bits.push("Prompt bg drop");
                    if (enabled) {
                        if (dropped !== null && total !== null) bits.push(`dropped ${dropped}/${total}`);
                        bits.push(mode);
                    } else {
                        const reason = promptBgDropSummary.disabled_reason;
                        if (reason === "no_background_classes") {
                            bits.push("disabled (no background classes)");
                        } else {
                            bits.push("off");
                        }
                    }
                    const line = document.createElement("div");
                    line.className = "training-help";
                    line.textContent = bits.join(" • ");
                    block.appendChild(line);
                }

                if (bgSummary) {
                    const bits = [];
                    bits.push("Background guard");
                    if (bgSeedRate !== null || bgSeedCount !== null) {
                        const rate = bgSeedRate !== null ? `${(bgSeedRate * 100).toFixed(1)}%` : "—";
                        const count = bgSeedCount !== null ? bgSeedCount : "—";
                        bits.push(`seed veto ${count} (${rate})`);
                    }
                    if (bgFinalRate !== null || bgFinalCount !== null) {
                        const rate = bgFinalRate !== null ? `${(bgFinalRate * 100).toFixed(1)}%` : "—";
                        const count = bgFinalCount !== null ? bgFinalCount : "—";
                        bits.push(`final veto ${count} (${rate})`);
                    }
                    const line = document.createElement("div");
                    line.className = "training-help";
                    line.textContent = bits.join(" • ");
                    block.appendChild(line);
                }

                if (hardNegSummary) {
                    const enabled = typeof hardNegSummary.enabled === "boolean" ? hardNegSummary.enabled : false;
                    const count = Number.isFinite(hardNegSummary.count) ? hardNegSummary.count : null;
                    const maxCrops = Number.isFinite(hardNegSummary.max_crops) ? hardNegSummary.max_crops : null;
                    const root = hardNegSummary.root || hardNegSummary.path || null;
                    const bits = [];
                    bits.push("Hard-neg replay");
                    if (enabled) {
                        if (count !== null) bits.push(`${count} crops`);
                        if (maxCrops !== null) bits.push(`cap ${maxCrops}`);
                        if (root) bits.push("saved");
                    } else {
                        bits.push("off");
                    }
                    const line = document.createElement("div");
                    line.className = "training-help";
                    line.textContent = bits.join(" • ");
                    block.appendChild(line);
                }

                body.appendChild(block);
            }

	            if (isStepRecipeV2) {
	                const headMinProb =
	                    recipe && recipe.clip_head && Number.isFinite(recipe.clip_head.min_prob) ? recipe.clip_head.min_prob : summary.clip_head_min_prob;
	                const headMargin =
	                    recipe && recipe.clip_head && Number.isFinite(recipe.clip_head.margin) ? recipe.clip_head.margin : summary.clip_head_margin;
	                const targetPrecision =
	                    recipe && recipe.clip_head && Number.isFinite(recipe.clip_head.target_precision)
	                        ? recipe.clip_head.target_precision
	                        : summary.clip_head_target_precision;
	                const meetsTarget =
	                    typeof summary.clip_head_meets_target_precision === "boolean"
	                        ? summary.clip_head_meets_target_precision
	                        : null;
	                const hasCleanlinessInfo =
	                    Number.isFinite(targetPrecision) ||
	                    Number.isFinite(headMinProb) ||
	                    Number.isFinite(headMargin) ||
	                    typeof meetsTarget === "boolean";

		                if (hasCleanlinessInfo) {
		                    const block = document.createElement("div");
		                    block.className = "training-subsection";
		                    const title = document.createElement("div");
	                    title.className = "training-subsection__title";
	                    title.textContent = "Cleanliness tuning";
	                    block.appendChild(title);

	                    const bits = [];
	                    if (Number.isFinite(targetPrecision)) {
	                        const suffix = meetsTarget === false ? " (missed)" : meetsTarget === true ? " (met)" : "";
	                        bits.push(`Target precision: ${Number(targetPrecision).toFixed(2)}${suffix}`);
	                    }
	                    if (Number.isFinite(precision)) bits.push(`Achieved precision: ${(Number(precision) * 100).toFixed(1)}%`);
	                    if (Number.isFinite(headMinProb) || Number.isFinite(headMargin)) {
	                        const headBits = [];
	                        if (Number.isFinite(headMinProb)) headBits.push(`p≥${Number(headMinProb).toFixed(3)}`);
	                        if (Number.isFinite(headMargin) && Number(headMargin) > 0) headBits.push(`Δ≥${Number(headMargin).toFixed(3)}`);
	                        if (headBits.length) bits.push(`CLIP head: ${headBits.join(" ")}`);
	                    }
	                    const line = document.createElement("div");
		                    line.className = "training-help";
		                    line.textContent = bits.join(" • ");
		                    block.appendChild(line);
		                    if (meetsTarget === false) {
		                        const hint = document.createElement("div");
		                        hint.className = "training-help";
		                        hint.textContent =
                            "Tip: if this misses, enable Tier‑1 or the Global optimizer to tune the step knobs (visual score + candidates/step + IoUs); CLIP thresholds alone may not remove FPs introduced by visual expansion.";
		                        block.appendChild(hint);
		                    }
		                    const debugObj = summary.debug && typeof summary.debug === "object" ? summary.debug : null;
		                    if (meetsTarget === false && debugObj) {
		                        const debugDetails = document.createElement("details");
		                        debugDetails.className = "training-help";
		                        debugDetails.open = false;
		                        const debugSummary = document.createElement("summary");
		                        debugSummary.textContent = "Debug";
		                        debugSummary.style.cursor = "pointer";
		                        debugDetails.appendChild(debugSummary);
		                        const debugBits = [];
		                        const baseDets = Number.isFinite(debugObj.base_dets) ? Number(debugObj.base_dets) : null;
		                        const withProb = Number.isFinite(debugObj.with_prob) ? Number(debugObj.with_prob) : null;
		                        const probMin = Number.isFinite(debugObj.prob_min) ? Number(debugObj.prob_min) : null;
		                        const probMax = Number.isFinite(debugObj.prob_max) ? Number(debugObj.prob_max) : null;
		                        if (baseDets !== null && withProb !== null) debugBits.push(`Head probs: ${withProb}/${baseDets}`);
		                        if (probMin !== null && probMax !== null) {
		                            debugBits.push(`prob range: ${probMin.toFixed(6)}..${probMax.toFixed(6)}`);
		                        }
		                        const debugLine = document.createElement("div");
		                        debugLine.className = "training-help";
		                        debugLine.textContent = debugBits.join(" • ") || "No debug stats.";
		                        debugDetails.appendChild(debugLine);
		                        block.appendChild(debugDetails);
		                    }
		                    body.appendChild(block);
		                }

	                const globalOpt =
	                    summary.global_optimizer && typeof summary.global_optimizer === "object" ? summary.global_optimizer : null;
	                if (globalOpt && globalOpt.enabled) {
	                    const block = document.createElement("div");
	                    block.className = "training-subsection";
	                    const title = document.createElement("div");
	                    title.className = "training-subsection__title";
	                    title.textContent = "Global optimizer";
	                    block.appendChild(title);

	                    const bits = [];
	                    const caps = Array.isArray(globalOpt.eval_caps) ? globalOpt.eval_caps : [];
	                    if (caps.length) bits.push(`budgets: ${caps.join(", ")}`);
	                    if (Number.isFinite(globalOpt.keep_ratio)) bits.push(`keep: ${Number(globalOpt.keep_ratio).toFixed(2)}`);
	                    if (Number.isFinite(globalOpt.max_trials)) bits.push(`trials: ${Number(globalOpt.max_trials)}`);
	                    if (Number.isFinite(globalOpt.rounds)) bits.push(`rounds: ${Number(globalOpt.rounds)}`);
	                    if (Number.isFinite(globalOpt.mutations_per_round))
	                        bits.push(`variants/round: ${Number(globalOpt.mutations_per_round)}`);
	                    if (globalOpt.enable_ordering) bits.push("order: on");
	                    if (globalOpt.enable_max_results) bits.push("max dets: tuned");
	                    if (globalOpt.selected_mutation && typeof globalOpt.selected_mutation === "object") {
	                        const op = typeof globalOpt.selected_mutation.op === "string" ? globalOpt.selected_mutation.op : "";
	                        if (op) bits.push(`picked: ${op}`);
	                    }
	                    const line = document.createElement("div");
	                    line.className = "training-help";
	                    line.textContent = bits.filter(Boolean).join(" • ");
	                    block.appendChild(line);
	                    body.appendChild(block);
	                }

	                const tier1 = summary.tier1_tuning && typeof summary.tier1_tuning === "object" ? summary.tier1_tuning : null;
	                if (tier1 && tier1.enabled) {
	                    const block = document.createElement("div");
	                    block.className = "training-subsection";
	                    const title = document.createElement("div");
	                    title.className = "training-subsection__title";
                    title.textContent = "Tier-1 grid search";
	                    block.appendChild(title);

	                    const base = tier1.base && typeof tier1.base === "object" ? tier1.base : {};
	                    const sel = tier1.selected && typeof tier1.selected === "object" ? tier1.selected : {};
                    const expandTxt =
                        Number.isFinite(base.expand_threshold) && Number.isFinite(sel.expand_threshold)
                            ? `visual_thr: ${Number(base.expand_threshold).toFixed(3)} → ${Number(sel.expand_threshold).toFixed(3)}`
                            : Number.isFinite(sel.expand_threshold)
                            ? `visual_thr: ${Number(sel.expand_threshold).toFixed(3)}`
                            : "";
                    const seedsTxt =
                        Number.isFinite(base.max_visual_seeds) && Number.isFinite(sel.max_visual_seeds)
                            ? `candidates: ${Number(base.max_visual_seeds)} → ${Number(sel.max_visual_seeds)}`
                            : Number.isFinite(sel.max_visual_seeds)
                            ? `candidates: ${Number(sel.max_visual_seeds)}`
                            : "";
	                    const capTxt = Number.isFinite(tier1.eval_cap) ? `eval_cap: ${Number(tier1.eval_cap)}` : "";
	                    const trialsTxt = Number.isFinite(tier1.max_trials) ? `trials: ${Number(tier1.max_trials)}` : "";
	                    const line = document.createElement("div");
	                    line.className = "training-help";
	                    line.textContent = [expandTxt, seedsTxt, capTxt, trialsTxt].filter(Boolean).join(" • ");
	                    block.appendChild(line);
	                    body.appendChild(block);
	                }

	                const tier2 = summary.tier2_tuning && typeof summary.tier2_tuning === "object" ? summary.tier2_tuning : null;
	                if (tier2 && tier2.enabled) {
	                    const block = document.createElement("div");
	                    block.className = "training-subsection";
	                    const title = document.createElement("div");
	                    title.className = "training-subsection__title";
	                    title.textContent = "Tier-2 tuning";
	                    block.appendChild(title);

	                    const base = tier2.base && typeof tier2.base === "object" ? tier2.base : {};
	                    const sel = tier2.selected && typeof tier2.selected === "object" ? tier2.selected : {};
                    const seedTxt =
                        Number.isFinite(base.seed_dedupe_iou) && Number.isFinite(sel.seed_dedupe_iou)
                            ? `cand_iou: ${Number(base.seed_dedupe_iou).toFixed(3)} → ${Number(sel.seed_dedupe_iou).toFixed(3)}`
                            : Number.isFinite(sel.seed_dedupe_iou)
                            ? `cand_iou: ${Number(sel.seed_dedupe_iou).toFixed(3)}`
                            : "";
	                    const outTxt =
	                        Number.isFinite(base.dedupe_iou) && Number.isFinite(sel.dedupe_iou)
	                            ? `out_iou: ${Number(base.dedupe_iou).toFixed(3)} → ${Number(sel.dedupe_iou).toFixed(3)}`
	                            : Number.isFinite(sel.dedupe_iou)
	                            ? `out_iou: ${Number(sel.dedupe_iou).toFixed(3)}`
	                            : "";
	                    const capTxt = Number.isFinite(tier2.eval_cap) ? `eval_cap: ${Number(tier2.eval_cap)}` : "";
	                    const trialsTxt = Number.isFinite(tier2.max_trials) ? `trials: ${Number(tier2.max_trials)}` : "";
	                    const line = document.createElement("div");
	                    line.className = "training-help";
	                    line.textContent = [seedTxt, outTxt, capTxt, trialsTxt].filter(Boolean).join(" • ");
	                    block.appendChild(line);
	                    body.appendChild(block);
	                }

	                const refine =
	                    summary.prompt_subset_refinement && typeof summary.prompt_subset_refinement === "object"
	                        ? summary.prompt_subset_refinement
	                        : null;
	                if (refine && refine.enabled) {
	                    const block = document.createElement("div");
	                    block.className = "training-subsection";
	                    const title = document.createElement("div");
	                    title.className = "training-subsection__title";
	                    title.textContent = "Prompt subset refinement";
	                    block.appendChild(title);

	                    const startSteps = Array.isArray(refine.start_steps) ? refine.start_steps : [];
	                    const finalSteps = Array.isArray(refine.final_steps) ? refine.final_steps : [];
	                    const countTxt =
	                        startSteps.length || finalSteps.length ? `Steps: ${startSteps.length} → ${finalSteps.length}` : "";
	                    const modeTxt = typeof refine.mode === "string" && refine.mode ? `mode: ${refine.mode}` : "";
	                    const itersTxt = Number.isFinite(refine.max_iters) ? `iters: ${Number(refine.max_iters)}` : "";
	                    const topKTxt = Number.isFinite(refine.top_k) ? `top_k: ${Number(refine.top_k)}` : "";
	                    const line = document.createElement("div");
	                    line.className = "training-help";
	                    line.textContent = [countTxt, modeTxt, itersTxt, topKTxt].filter(Boolean).join(" • ");
	                    block.appendChild(line);
	                    body.appendChild(block);
	                }

                const seedStats = Array.isArray(summary.seed_prompt_stats) ? summary.seed_prompt_stats : [];
                if (seedStats.length) {
                    const block = document.createElement("div");
                    block.className = "training-subsection";
                    const title = document.createElement("div");
                    title.className = "training-subsection__title";
                    title.textContent = `Candidate prompt stats (selected steps) (${seedStats.length})`;
                    block.appendChild(title);

	                    const table = document.createElement("table");
	                    table.className = "training-table";
                    table.innerHTML = `
                        <thead>
                            <tr><th>#</th><th>Prompt</th><th>Matches</th><th>FPs</th><th>Prec</th><th>Text thr</th></tr>
                        </thead>
                    `;
	                    const tbody = document.createElement("tbody");
	                    seedStats.forEach((s, idx) => {
	                        if (!s || typeof s !== "object") return;
	                        const row = document.createElement("tr");
	                        const p = typeof s.prompt === "string" ? s.prompt : "";
	                        const matches = Number.isFinite(s.matches) ? s.matches : 0;
	                        const fps = Number.isFinite(s.fps) ? s.fps : 0;
	                        const pPrec = Number.isFinite(s.precision) ? (Number(s.precision) * 100).toFixed(1) : "";
	                        const thr = s.selected_seed_threshold ?? s.seed_threshold_recommended ?? s.seed_threshold_base ?? "";
	                        row.innerHTML = `
	                            <td>${idx + 1}</td>
	                            <td>${escapeHtml(String(p))}</td>
	                            <td>${escapeHtml(String(matches))}</td>
	                            <td>${escapeHtml(String(fps))}</td>
	                            <td>${escapeHtml(String(pPrec ? `${pPrec}%` : ""))}</td>
	                            <td>${escapeHtml(String(thr))}</td>
	                        `;
	                        tbody.appendChild(row);
	                    });
	                    table.appendChild(tbody);
                    block.appendChild(table);
                    body.appendChild(block);
                }

                const similarityFlow =
                    summary.similarity_flow && typeof summary.similarity_flow === "object" ? summary.similarity_flow : null;
                if (similarityFlow && Array.isArray(similarityFlow.steps) && similarityFlow.steps.length) {
                    const block = document.createElement("div");
                    block.className = "training-subsection";
                    const title = document.createElement("div");
                    title.className = "training-subsection__title";
                    title.textContent = "Similarity-based search stats";
                    block.appendChild(title);

                    const totalImages = Number.isFinite(similarityFlow.images) ? Number(similarityFlow.images) : null;
                    const formatCount = (val) => {
                        const total = Number.isFinite(val) ? Number(val) : 0;
                        if (totalImages && totalImages > 0) {
                            return `${(total / totalImages).toFixed(2)} avg (${total})`;
                        }
                        return String(total);
                    };
                    const bgGuardOn =
                        typeof summary.clip_head_background_guard === "boolean"
                            ? summary.clip_head_background_guard
                            : typeof params.clip_head_background_guard === "boolean"
                              ? params.clip_head_background_guard
                              : false;
                    const showBg = bgGuardOn;
                    const formatBg = (vetoRaw, checkedRaw) => {
                        const veto = Number.isFinite(vetoRaw) ? Number(vetoRaw) : 0;
                        const checked = Number.isFinite(checkedRaw) ? Number(checkedRaw) : 0;
                        const rate = checked > 0 ? ((veto / checked) * 100).toFixed(1) : "0.0";
                        if (totalImages && totalImages > 0) {
                            return `${(veto / totalImages).toFixed(2)} avg (${veto}/${checked}, ${rate}%)`;
                        }
                        return `${veto}/${checked} (${rate}%)`;
                    };

                    const table = document.createElement("table");
                    table.className = "training-table";
                    table.innerHTML = `
                        <thead>
                            <tr>
                                <th>#</th>
                                <th>Prompt</th>
                                <th>Text candidates</th>
                                <th>Kept candidates</th>
                                <th>Expand candidates</th>
                                <th>Expanded dets</th>
                                <th>Final dets</th>
                                ${showBg ? "<th>BG veto (seed)</th><th>BG veto (final)</th>" : ""}
                            </tr>
                        </thead>
                    `;
                    const tbody = document.createElement("tbody");
                    similarityFlow.steps.forEach((step, idx) => {
                        if (!step || typeof step !== "object") return;
                        const row = document.createElement("tr");
                        const prompt = typeof step.prompt === "string" ? step.prompt : "";
                        row.innerHTML = `
                            <td>${idx + 1}</td>
                            <td>${escapeHtml(String(prompt))}</td>
                            <td>${escapeHtml(formatCount(step.text_candidates_total))}</td>
                            <td>${escapeHtml(formatCount(step.candidates_kept))}</td>
                            <td>${escapeHtml(formatCount(step.expand_candidates))}</td>
                            <td>${escapeHtml(formatCount(step.expanded_total))}</td>
                            <td>${escapeHtml(formatCount(step.final_total))}</td>
                            ${
                                showBg
                                    ? `<td>${escapeHtml(formatBg(step.seed_bg_veto, step.seed_bg_checked))}</td>
                                       <td>${escapeHtml(formatBg(step.final_bg_veto, step.final_bg_checked))}</td>`
                                    : ""
                            }
                        `;
                        tbody.appendChild(row);
                    });
                    table.appendChild(tbody);
                    block.appendChild(table);
                    if (totalImages && totalImages > 0) {
                        const note = document.createElement("div");
                        note.className = "training-help";
                        note.textContent = `Counts are averages per image with totals in parentheses (sample images: ${totalImages}).`;
                        block.appendChild(note);
                    }
                    body.appendChild(block);
                }
            }

		            if (prompts.length) {
		                const block = document.createElement("div");
		                block.className = "training-subsection";
		                const title = document.createElement("div");
		                title.className = "training-subsection__title";
		                title.textContent = `Prompt pool (${prompts.length})`;
		                block.appendChild(title);
		                if (isStepRecipeV2) {
		                    const help = document.createElement("div");
		                    help.className = "training-help";
		                    help.textContent =
		                        "These are the prompts considered during mining. The optimizer chooses a smaller subset to use as recipe steps.";
		                    block.appendChild(help);
		                }

	                const table = document.createElement("table");
	                table.className = "training-table";
	                table.innerHTML = `
	                    <thead>
	                        <tr><th>#</th><th>Type</th><th>Prompt</th></tr>
	                    </thead>
	                `;
	                const tbody = document.createElement("tbody");
	                prompts.forEach((prompt, idx) => {
	                    const row = document.createElement("tr");
	                    const colIdx = document.createElement("td");
	                    colIdx.textContent = String(idx + 1);
	                    const colType = document.createElement("td");
	                    colType.textContent = "text";
	                    const colPrompt = document.createElement("td");
	                    colPrompt.textContent = String(prompt);
	                    row.appendChild(colIdx);
	                    row.appendChild(colType);
	                    row.appendChild(colPrompt);
	                    tbody.appendChild(row);
	                });
	                table.appendChild(tbody);
	                block.appendChild(table);
	                body.appendChild(block);
	            }

		            if (!isStepRecipeV2 && steps.length) {
		                const table = document.createElement("table");
		                table.className = "training-table";
		                table.innerHTML = `
		                    <thead>
		                        <tr><th>#</th><th>Type</th><th>Prompt/Exemplar</th><th>Thr</th><th>Adds</th><th>Cov after %</th><th>FPs (step)</th><th>FPs (total)</th><th>Prec</th></tr>
		                    </thead>
		                `;
	                const tbody = document.createElement("tbody");
	                steps.forEach((step, idx) => {
	                    const covVal =
	                        Number.isFinite(step.cum_coverage) && step.cum_coverage >= 0
	                            ? (step.cum_coverage * 100).toFixed(1)
	                            : Number.isFinite(step.coverage_after)
	                            ? (step.coverage_after * 100).toFixed(1)
	                            : "";
	                    const label =
	                        step.type === "visual" && step.exemplar
	                            ? `Exemplar img ${step.exemplar.image_id} bbox ${Array.isArray(step.exemplar.bbox) ? step.exemplar.bbox.join(",") : ""}`
	                            : step.prompt || "";
	                    const row = document.createElement("tr");
	                    if (idx === 0) row.classList.add("metric-table__highlight");
	                    row.innerHTML = `
	                        <td>${idx + 1}</td>
	                        <td>${step.type || "text"}</td>
	                        <td>${escapeHtml(label)}</td>
	                        <td>${(step.threshold ?? "").toString()}</td>
	                        <td>${step.gain ?? ""}</td>
	                        <td>${covVal}</td>
	                        <td>${step.fps ?? 0}</td>
	                        <td>${step.cum_fps ?? step.fps ?? 0}</td>
	                        <td>${formatMetric(step.precision, 3)}</td>
	                    `;
	                    tbody.appendChild(row);
	                });
	                table.appendChild(tbody);
		                body.appendChild(table);
		            }

			            if (isStepRecipeV2 && steps.length) {
			                const block = document.createElement("div");
			                block.className = "training-subsection";
			                const title = document.createElement("div");
			                title.className = "training-subsection__title";
			                title.textContent = `Recipe steps (${steps.length})`;
			                block.appendChild(title);
			                const help = document.createElement("div");
			                help.className = "training-help";
                    help.textContent =
                        "Each step runs: text candidates → pick diverse expansion candidates → similarity-based search (SAM3 visual expansion) → de-dupe. Per-step text thresholds are auto-selected from candidate curves by default. Visual score/candidate counts start from base settings unless tuned by Tier‑1 or Global.";
			                block.appendChild(help);

			                const table = document.createElement("table");
			                table.className = "training-table";
			                table.innerHTML = `
			                    <thead>
			                        <tr>
			                            <th>#</th>
                            <th title="Text prompt(s) used for the text-candidate stage.">Prompt(s)</th>
                            <th title="Minimum SAM3 text score for a candidate box. Higher = fewer candidates, typically cleaner but can miss objects.">Text thr</th>
                            <th title="SAM3 visual expansion score threshold (similarity-based search). Higher = stricter expansion, fewer boxes.">Visual thr</th>
                            <th title="Max number of candidate boxes per image used for similarity-based search (picked to be diverse). 0 disables visual expansion.">Candidates</th>
                            <th title="Candidate de-dupe IoU (remove near-duplicate candidate boxes).">Candidate IoU</th>
                            <th title="Output de-dupe IoU (remove near-duplicate final boxes).">Out IoU</th>
                            <th title="Optional per-step CLIP gating during candidate selection (advanced). Empty means no extra gate.">Candidate CLIP</th>
                            <th title="Optional per-step extra CLIP gating after expansion (advanced). Empty means only the recipe’s baked-in CLIP-head cleanliness filter applies.">Final CLIP</th>
                        </tr>
                    </thead>
                `;
		                const tbody = document.createElement("tbody");

		                function formatClipCfg(cfg) {
		                    if (!cfg || typeof cfg !== "object") return "";
		                    const bits = [];
		                    if (Number.isFinite(cfg.similarity_floor)) bits.push(`sim≥${cfg.similarity_floor}`);
		                    if (Number.isFinite(cfg.min_prob)) bits.push(`p≥${cfg.min_prob}`);
		                    if (Number.isFinite(cfg.margin) && cfg.margin > 0) bits.push(`Δ≥${cfg.margin}`);
		                    return bits.join(" ");
		                }

		                steps.forEach((step, idx) => {
		                    if (!step || typeof step !== "object") return;
		                    const stepPrompts = [];
		                    if (typeof step.prompt === "string" && step.prompt.trim()) stepPrompts.push(step.prompt.trim());
		                    if (Array.isArray(step.prompts)) {
		                        step.prompts.forEach((raw) => {
		                            if (typeof raw === "string" && raw.trim()) stepPrompts.push(raw.trim());
		                        });
		                    }
		                    const seedThr = step.seed_threshold ?? params.seed_threshold ?? "";
		                    const expandThr = step.expand_threshold ?? params.expand_threshold ?? "";
                    const seeds = step.max_visual_seeds ?? params.max_visual_seeds ?? "";
                    const seedIou = step.seed_dedupe_iou ?? params.seed_dedupe_iou ?? "";
		                    const outIou = step.dedupe_iou ?? step.step_dedupe_iou ?? params.dedupe_iou ?? "";
		                    const seedClip = formatClipCfg(step.clip_seed);
		                    const finalClip = formatClipCfg(step.clip_final);
		                    const row = document.createElement("tr");
		                    row.innerHTML = `
		                        <td>${idx + 1}</td>
		                        <td>${escapeHtml(stepPrompts.join(", "))}</td>
		                        <td>${escapeHtml(String(seedThr))}</td>
		                        <td>${escapeHtml(String(expandThr))}</td>
                        <td>${escapeHtml(String(seeds))}</td>
                        <td>${escapeHtml(String(seedIou))}</td>
		                        <td>${escapeHtml(String(outIou))}</td>
		                        <td>${escapeHtml(seedClip)}</td>
		                        <td>${escapeHtml(finalClip)}</td>
		                    `;
		                    tbody.appendChild(row);
		                });
		                table.appendChild(tbody);
		                block.appendChild(table);
		                body.appendChild(block);
		            }

	            if (!prompts.length && !steps.length) {
	                const empty = document.createElement("div");
	                empty.className = "training-help";
	                empty.textContent = "No recipe produced for this class (try increasing crops/prompts or lowering thresholds).";
	                body.appendChild(empty);
	            }

	            const foot = document.createElement("div");
	            foot.className = "training-actions";
	            const saveBtn = document.createElement("button");
	            saveBtn.type = "button";
	            saveBtn.className = "training-button secondary";
	            saveBtn.textContent = "Save recipe";
	            saveBtn.addEventListener("click", async () => {
	                const datasetId = agentElements.datasetSelect?.value;
	                if (!datasetId) {
	                    setAgentStatus("Select a dataset before saving.", "warn");
	                    return;
	                }
	                const label = prompt(`Recipe label for ${cls.name || cls.id}?`, `${cls.name || cls.id} recipe`);
	                if (!label) return;
	                try {
	                    const resp = await fetch(`${API_ROOT}/agent_mining/recipes`, {
	                        method: "POST",
	                        headers: { "Content-Type": "application/json" },
	                        body: JSON.stringify({
	                            dataset_id: datasetId,
	                            class_id: cls.id,
	                            class_name: cls.name,
	                            label,
	                            recipe,
	                        }),
	                    });
	                    if (!resp.ok) throw new Error(await resp.text());
	                    setAgentStatus(`Saved recipe "${label}".`, "success");
	                    fetchAgentRecipes().catch((err) => console.error("Agent recipe refresh failed", err));
	                } catch (err) {
	                    console.error("Save recipe failed", err);
	                    setAgentStatus(`Save failed: ${err.message || err}`, "error");
	                }
	            });
	            foot.appendChild(saveBtn);
	            body.appendChild(foot);
	            card.appendChild(body);
	            frag.appendChild(card);
	        });
	        agentElements.results.appendChild(frag);
	    }

	    function renderAgentLogs(job) {
	        if (!agentElements.logs) return;
	        const logs = job && Array.isArray(job.logs) ? job.logs : [];
	        const jobId = job?.job_id || "";
	        const lastEntry = logs.length ? logs[logs.length - 1] : null;
	        const lastMsgRaw = lastEntry ? lastEntry.msg || lastEntry.message || lastEntry : "";
	        const lastMsg = typeof lastMsgRaw === "string" ? lastMsgRaw : JSON.stringify(lastMsgRaw);
	        const logKey = `${jobId}:${logs.length}:${lastEntry?.ts ?? ""}:${lastMsg}`;

	        if (agentState.lastRenderedLogKey === logKey) {
	            if (agentElements.purgeCacheBtn) {
	                const disabled = job && job.status === "running";
	                agentElements.purgeCacheBtn.disabled = disabled;
	                agentElements.purgeCacheBtn.title = disabled ? "Purge disabled while a job is running." : "Purge cached detections to free disk space.";
	            }
	            return;
	        }

	        const distanceFromBottom =
	            agentElements.logs.scrollHeight - agentElements.logs.scrollTop - agentElements.logs.clientHeight;
	        const stickToBottom = distanceFromBottom < 40;
	        const prevScrollTop = agentElements.logs.scrollTop;

	        agentElements.logs.innerHTML = "";
	        if (logs.length) {
	            const frag = document.createDocumentFragment();
	            logs.slice(-200).forEach((entry) => {
	                const div = document.createElement("div");
	                div.className = "training-log-line";
	                const ts = entry.ts ? new Date(entry.ts * 1000).toLocaleTimeString() : "";
	                div.textContent = `${ts ? `[${ts}] ` : ""}${entry.msg || entry.message || entry}`;
	                frag.appendChild(div);
	            });
	            agentElements.logs.appendChild(frag);
	            agentElements.logs.scrollTop = stickToBottom ? agentElements.logs.scrollHeight : prevScrollTop;
	        }
	        agentState.lastRenderedLogKey = logKey;
	        if (agentElements.purgeCacheBtn) {
	            const disabled = job && job.status === "running";
	            agentElements.purgeCacheBtn.disabled = disabled;
	            agentElements.purgeCacheBtn.title = disabled ? "Purge disabled while a job is running." : "Purge cached detections to free disk space.";
	        }
	    }

	    function updateAgentProgress(job) {
	        if (!agentElements.progressFill) return;
	        const pct = Number.isFinite(job?.progress) ? Math.max(0, Math.min(1, job.progress)) * 100 : 0;
	        agentElements.progressFill.style.width = `${pct}%`;
	        if (agentElements.progressText) {
	            const extra = job?.message ? ` • ${job.message}` : job?.current_class ? ` • Class: ${job.current_class}` : "";
	            agentElements.progressText.textContent = `Progress: ${pct.toFixed(1)}%${extra}`;
	        }
	    }

	    function getAgentSelectedDatasetMeta() {
	        const datasetId = agentElements.datasetSelect?.value;
	        if (!datasetId) return null;
	        return agentState.datasetsById[datasetId] || null;
	    }

    async function loadAgentDatasets() {
        if (!agentElements.datasetSelect || !agentElements.datasetSummary) return;
        agentElements.datasetSelect.disabled = true;
        agentElements.datasetSelect.innerHTML = "";
        agentElements.datasetSummary.textContent = "Loading datasets…";
        try {
            const resp = await fetch(`${API_ROOT}/sam3/datasets`);
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            const list = Array.isArray(data) ? data : [];
            agentState.datasetsById = {};
            agentElements.datasetSelect.innerHTML = "";
            list.forEach((entry) => {
                const opt = document.createElement("option");
                opt.value = entry.id || entry.label || entry.path || "";
                opt.textContent = entry.label || entry.id || opt.value;
                agentElements.datasetSelect.appendChild(opt);
                if (opt.value) {
                    agentState.datasetsById[opt.value] = entry;
                }
            });
	            if (list.length) {
	                agentElements.datasetSelect.selectedIndex = 0;
	                const first = list[0];
	                const parts = [];
	                if (first.source) parts.push(first.source);
	                if (first.image_count) parts.push(`${first.image_count} images`);
	                agentElements.datasetSummary.textContent = parts.join(" • ") || "Dataset ready";
	                prefillExtraPrompts();
	                updateAgentStepsComputeEstimate();
	            } else {
	                agentElements.datasetSummary.textContent = "No datasets found.";
	                if (agentElements.extraPrompts) agentElements.extraPrompts.value = "{}";
	                updateAgentStepsComputeEstimate();
	            }
        } catch (err) {
            console.error("Agent datasets load failed", err);
            agentElements.datasetSummary.textContent = `Failed: ${err.message || err}`;
        } finally {
            agentElements.datasetSelect.disabled = false;
        }
    }

    function updateAgentDatasetSummary() {
        if (!agentElements.datasetSummary) return;
        const meta = getAgentSelectedDatasetMeta();
        if (!meta) {
            agentElements.datasetSummary.textContent = "Pick a converted SAM3/Qwen dataset.";
            return;
        }
        const parts = [];
        if (meta.source) parts.push(meta.source);
        if (meta.image_count) parts.push(`${meta.image_count} images`);
	        agentElements.datasetSummary.textContent = parts.join(" • ") || "Dataset ready";
	    }

    function getAgentSelectedClipHeadEntry() {
        if (!agentElements.clipHeadSelect) return null;
        const selected = agentElements.clipHeadSelect.value || "";
        if (!selected) return null;
        if (!Array.isArray(agentState.clipHeads)) return null;
        return (
            agentState.clipHeads.find((entry) => entry && (entry.rel_path === selected || entry.path === selected)) || null
        );
    }

    function isAgentPromptPrefilterAllowed() {
        const entry = getAgentSelectedClipHeadEntry();
        const encoderType = entry && entry.encoder_type ? String(entry.encoder_type).toLowerCase().trim() : "clip";
        return !encoderType || encoderType === "clip";
    }

    function getAgentClipHeadBackgroundInfo() {
        const entry = getAgentSelectedClipHeadEntry();
        if (!entry) return { count: 0, known: false };
        if (Number.isFinite(entry.background_class_count)) {
            return { count: Math.max(0, Math.floor(entry.background_class_count)), known: true };
        }
        if (Array.isArray(entry.classes)) {
            const count = entry.classes.filter((name) => String(name || "").trim().startsWith("__bg_")).length;
            return { count, known: true };
        }
        return { count: 0, known: false };
    }

    function hasAgentClipHeadBackgroundClasses() {
        const info = getAgentClipHeadBackgroundInfo();
        return !!(info && info.known && info.count > 0);
    }

    function updateAgentClipHeadMeta() {
        if (!agentElements.clipHeadMeta) return;
        const entry = getAgentSelectedClipHeadEntry();
        if (!entry) {
            agentElements.clipHeadMeta.textContent = "";
            return;
        }
        const encoderTypeRaw = entry.encoder_type || "clip";
        const encoderType = String(encoderTypeRaw).toLowerCase().trim();
        const encoderModel = entry.encoder_model || entry.clip_model || "";
        const hasMeta = !!entry.encoder_type;
        const label = encoderType === "clip" ? "CLIP" : encoderType.toUpperCase();
        const bits = [`Encoder: ${label}${encoderModel ? ` (${encoderModel})` : ""}`];
        if (!hasMeta) {
            bits.push("Legacy head (missing metadata). DINOv3 requires a .meta.pkl file.");
        }
        if (encoderType !== "clip") {
            bits.push("CLIP prompt prefilter is unavailable for image-only heads.");
        }
        const bgInfo = getAgentClipHeadBackgroundInfo();
        if (bgInfo.known) {
            bits.push(bgInfo.count > 0 ? `Background classes: ${bgInfo.count}` : "No background classes");
        }
        agentElements.clipHeadMeta.textContent = bits.join(" ");
    }

    function syncAgentClipHeadControls() {
        const hasHead = !!(agentElements.clipHeadSelect && agentElements.clipHeadSelect.value);
        const autoTune = !!(agentElements.clipHeadAutoTune && agentElements.clipHeadAutoTune.checked);
        const tuneMargin = !!(agentElements.clipHeadTuneMargin && agentElements.clipHeadTuneMargin.checked);
        const prefilterAllowed = isAgentPromptPrefilterAllowed();
        const hasBgClasses = hasAgentClipHeadBackgroundClasses();

        if (agentElements.clipHeadAutoTune) agentElements.clipHeadAutoTune.disabled = !hasHead;
        if (agentElements.clipHeadTuneMargin) {
            const enabled = hasHead && autoTune;
            agentElements.clipHeadTuneMargin.disabled = !enabled;
            if (!enabled && !autoTune) agentElements.clipHeadTuneMargin.checked = false;
        }
        if (agentElements.clipHeadTargetPrecision) agentElements.clipHeadTargetPrecision.disabled = !hasHead || !autoTune;
        if (agentElements.clipHeadAllowLowPrecision) agentElements.clipHeadAllowLowPrecision.disabled = !hasHead || !autoTune;
        if (agentElements.clipHeadMinProb) agentElements.clipHeadMinProb.disabled = !hasHead || autoTune;
        if (agentElements.clipHeadMargin) {
            const enabled = hasHead && (!autoTune || !tuneMargin);
            agentElements.clipHeadMargin.disabled = !enabled;
        }

        if (agentElements.clipHeadBgGuard) {
            const enabled = hasHead && hasBgClasses;
            agentElements.clipHeadBgGuard.disabled = !enabled;
            if (!enabled) agentElements.clipHeadBgGuard.checked = false;
            agentElements.clipHeadBgGuard.title = enabled
                ? ""
                : "Disabled because the selected head has no __bg_* background classes.";
        }
        if (agentElements.clipHeadBgMargin) {
            const enabled = hasHead && hasBgClasses;
            agentElements.clipHeadBgMargin.disabled = !enabled;
        }
        if (agentElements.clipHeadBgApply) {
            const enabled = hasHead && hasBgClasses;
            agentElements.clipHeadBgApply.disabled = !enabled;
        }
        if (agentElements.clipHeadBgPenalty) {
            const enabled = hasHead && hasBgClasses;
            agentElements.clipHeadBgPenalty.disabled = !enabled;
        }
        if (agentElements.clipHeadBgAutoTune) {
            const enabled = hasHead && hasBgClasses && autoTune;
            agentElements.clipHeadBgAutoTune.disabled = !enabled;
            if (!enabled && !autoTune) agentElements.clipHeadBgAutoTune.checked = false;
        }

        if (agentElements.stepsPromptPrefilter) {
            agentElements.stepsPromptPrefilter.disabled = !hasHead || !prefilterAllowed;
            if (!prefilterAllowed) {
                agentElements.stepsPromptPrefilter.checked = false;
                agentElements.stepsPromptPrefilter.title =
                    "Disabled because the selected head uses DINOv3 (prefilter requires CLIP embeddings).";
            } else {
                agentElements.stepsPromptPrefilter.title = "";
            }
        }
        if (agentElements.stepsPromptPrefilterMode) {
            const enabled = !!(
                prefilterAllowed &&
                agentElements.stepsPromptPrefilter &&
                agentElements.stepsPromptPrefilter.checked
            );
            agentElements.stepsPromptPrefilterMode.disabled = !enabled;
        }

        if (agentElements.stepsPromptBgDrop) {
            const enabled = hasHead && hasBgClasses;
            agentElements.stepsPromptBgDrop.disabled = !enabled;
            if (!enabled) agentElements.stepsPromptBgDrop.checked = false;
            agentElements.stepsPromptBgDrop.title = enabled
                ? ""
                : "Disabled because the selected head has no __bg_* background classes.";
        }
        if (agentElements.stepsPromptBgDropMode) {
            const enabled =
                agentElements.stepsPromptBgDrop &&
                !agentElements.stepsPromptBgDrop.disabled &&
                agentElements.stepsPromptBgDrop.checked;
            agentElements.stepsPromptBgDropMode.disabled = !enabled;
        }

        if (agentElements.stepsHardNegExport) {
            agentElements.stepsHardNegExport.disabled = !hasHead;
            if (!hasHead) agentElements.stepsHardNegExport.checked = false;
        }
        if (agentElements.stepsHardNegMaxCrops) {
            const enabled =
                agentElements.stepsHardNegExport &&
                !agentElements.stepsHardNegExport.disabled &&
                agentElements.stepsHardNegExport.checked;
            agentElements.stepsHardNegMaxCrops.disabled = !enabled;
        }
        if (agentElements.stepsHardNegMinProb) {
            const enabled =
                agentElements.stepsHardNegExport &&
                !agentElements.stepsHardNegExport.disabled &&
                agentElements.stepsHardNegExport.checked;
            agentElements.stepsHardNegMinProb.disabled = !enabled;
        }

        syncAgentStepsOptimizationControls();
        syncAgentRunButtonAvailability();
        updateAgentClipHeadMeta();
    }

	    function syncAgentRunButtonAvailability() {
	        if (!agentElements.runButton) return;
        const hasSelectedHead = !!(agentElements.clipHeadSelect && agentElements.clipHeadSelect.value);
        const hasAnyHead = !!(
            agentElements.clipHeadSelect &&
            Array.from(agentElements.clipHeadSelect.options || []).some((opt) => opt && opt.value)
        );
        const running = agentState.lastJob && agentState.lastJob.status === "running";
        const disabled = running || !hasSelectedHead;
        agentElements.runButton.disabled = disabled;
        if (disabled) {
            if (running) {
                agentElements.runButton.title = "A recipe mining job is already running.";
            } else if (!hasAnyHead) {
                agentElements.runButton.title = "No pretrained heads found. Train a class predictor first, then select the head here.";
            } else {
                agentElements.runButton.title = "Select a pretrained CLIP head to run recipe mining.";
            }
	        } else {
	            agentElements.runButton.title = "Run SAM3 Recipe Mining";
	        }
	    }

	    function getAgentStepsGlobalPreset() {
	        const raw = agentElements.stepsGlobalPreset ? String(agentElements.stepsGlobalPreset.value || "").trim() : "";
	        const preset = raw ? raw.toLowerCase() : "off";
	        return ["off", "fast", "balanced", "best", "custom"].includes(preset) ? preset : "off";
	    }

	    function markAgentStepsGlobalPresetCustom() {
	        if (agentStepsGlobalPresetLock) return;
	        if (!agentElements.stepsGlobalPreset) return;
	        const preset = getAgentStepsGlobalPreset();
	        if (preset !== "off" && preset !== "custom") {
	            agentElements.stepsGlobalPreset.value = "custom";
	        }
	    }

		    function applyAgentStepsGlobalPreset(presetRaw) {
		        if (!agentElements.stepsGlobalPreset) return;
		        const preset = String(presetRaw || "").trim().toLowerCase();
		        const key = ["off", "fast", "balanced", "best", "custom"].includes(preset) ? preset : "off";
		        agentStepsGlobalPresetLock = true;
	        try {
	            agentElements.stepsGlobalPreset.value = key;
			            if (key === "fast") {
			                if (agentElements.stepsGlobalEvalCap1) agentElements.stepsGlobalEvalCap1.value = "25";
			                if (agentElements.stepsGlobalEvalCap2) agentElements.stepsGlobalEvalCap2.value = "100";
			                if (agentElements.stepsGlobalEvalCap3) agentElements.stepsGlobalEvalCap3.value = "300";
			                if (agentElements.stepsGlobalMaxTrials) agentElements.stepsGlobalMaxTrials.value = "16";
			                if (agentElements.stepsGlobalKeepRatio) agentElements.stepsGlobalKeepRatio.value = "0.4";
			                if (agentElements.stepsGlobalRounds) agentElements.stepsGlobalRounds.value = "1";
			                if (agentElements.stepsGlobalMutationsPerRound) agentElements.stepsGlobalMutationsPerRound.value = "12";
			                if (agentElements.stepsGlobalMaxStepsMutated) agentElements.stepsGlobalMaxStepsMutated.value = "1";
			            } else if (key === "balanced") {
		                if (agentElements.stepsGlobalEvalCap1) agentElements.stepsGlobalEvalCap1.value = "50";
		                if (agentElements.stepsGlobalEvalCap2) agentElements.stepsGlobalEvalCap2.value = "200";
		                if (agentElements.stepsGlobalEvalCap3) agentElements.stepsGlobalEvalCap3.value = "1000";
		                if (agentElements.stepsGlobalMaxTrials) agentElements.stepsGlobalMaxTrials.value = "36";
		                if (agentElements.stepsGlobalKeepRatio) agentElements.stepsGlobalKeepRatio.value = "0.5";
		                if (agentElements.stepsGlobalRounds) agentElements.stepsGlobalRounds.value = "2";
		                if (agentElements.stepsGlobalMutationsPerRound) agentElements.stepsGlobalMutationsPerRound.value = "24";
		                if (agentElements.stepsGlobalMaxStepsMutated) agentElements.stepsGlobalMaxStepsMutated.value = "2";
			            } else if (key === "best") {
			                if (agentElements.stepsGlobalEvalCap1) agentElements.stepsGlobalEvalCap1.value = "100";
			                if (agentElements.stepsGlobalEvalCap2) agentElements.stepsGlobalEvalCap2.value = "500";
			                if (agentElements.stepsGlobalEvalCap3) agentElements.stepsGlobalEvalCap3.value = "2000";
			                if (agentElements.stepsGlobalMaxTrials) agentElements.stepsGlobalMaxTrials.value = "64";
			                if (agentElements.stepsGlobalKeepRatio) agentElements.stepsGlobalKeepRatio.value = "0.6";
			                if (agentElements.stepsGlobalRounds) agentElements.stepsGlobalRounds.value = "3";
			                if (agentElements.stepsGlobalMutationsPerRound) agentElements.stepsGlobalMutationsPerRound.value = "40";
			                if (agentElements.stepsGlobalMaxStepsMutated) agentElements.stepsGlobalMaxStepsMutated.value = "3";
			            }
			        } finally {
			            agentStepsGlobalPresetLock = false;
			        }
			        if (agentElements.stepsAdvancedDetails && agentElements.stepsAdvancedDetails.tagName === "DETAILS") {
			            agentElements.stepsAdvancedDetails.open = key !== "off";
			        }
			        updateAgentStepsComputeEstimate();
			    }

		    function formatCompactCount(value) {
		        if (!Number.isFinite(value)) {
		            return "—";
		        }
		        const abs = Math.abs(value);
		        const sign = value < 0 ? "-" : "";
		        const fmt = (num, suffix) => {
		            const digits = num >= 100 ? 0 : num >= 10 ? 1 : 2;
		            const txt = num
		                .toFixed(digits)
		                .replace(/\.0+$/, "")
		                .replace(/(\.\d*[1-9])0+$/, "$1");
		            return `${sign}${txt}${suffix}`;
		        };
		        if (abs >= 1e9) return fmt(abs / 1e9, "B");
		        if (abs >= 1e6) return fmt(abs / 1e6, "M");
		        if (abs >= 1e3) return fmt(abs / 1e3, "k");
		        return `${sign}${Math.round(abs)}`;
		    }

		    function parseAgentClassIdList(raw) {
		        const text = String(raw || "").trim();
		        if (!text) return null;
		        const tokens = text
		            .split(/[^0-9]+/g)
		            .map((v) => v.trim())
		            .filter(Boolean);
		        const ids = [];
		        const seen = new Set();
		        tokens.forEach((tok) => {
		            const n = parseInt(tok, 10);
		            if (!Number.isFinite(n)) return;
		            if (seen.has(n)) return;
		            seen.add(n);
		            ids.push(n);
		        });
		        return ids.length ? ids : null;
		    }

			    function estimateAgentGlobalOptimizerImageEvals({ valImages, evalCaps, keepRatio, rounds, maxTrials, mutationsPerRound }) {
			        const parsed = [];
			        for (const cap of evalCaps || []) {
			            const b = parseInt(String(cap || "").trim(), 10);
			            if (!Number.isFinite(b) || b <= 0) continue;
			            parsed.push(b);
			        }
			        const budgets = Array.from(new Set(parsed)).sort((a, b) => a - b);
			        if (!budgets.length) {
			            return { imageEvals: 0, budgets: [], invalidBudgets: true };
			        }

		        const valN = Number.isFinite(valImages) && valImages > 0 ? Math.max(1, Math.floor(valImages)) : null;
		        const keep = Number.isFinite(keepRatio) ? Math.max(0.0, Math.min(1.0, keepRatio)) : 0.5;
		        const roundsI = Number.isFinite(rounds) ? Math.max(1, Math.floor(rounds)) : 1;
		        const maxTrialsI = Number.isFinite(maxTrials) ? Math.max(1, Math.floor(maxTrials)) : 1;
		        const mutationsI = Number.isFinite(mutationsPerRound) ? Math.max(1, Math.floor(mutationsPerRound)) : 1;

		        let candidatesPerRound = 1;
		        if (maxTrialsI > 1) {
		            const maxMut = Math.max(1, Math.min(mutationsI, maxTrialsI - 1));
		            candidatesPerRound = 1 + maxMut;
		        }

		        let total = 0;
		        for (let r = 0; r < roundsI; r += 1) {
		            let active = Math.max(1, candidatesPerRound);
		            for (let s = 0; s < budgets.length; s += 1) {
		                const budgetCap = budgets[s];
		                const effBudget = valN !== null ? Math.min(budgetCap, valN) : budgetCap;
		                total += active * effBudget;
		                if (s < budgets.length - 1) {
		                    active = Math.max(1, Math.ceil(active * keep));
		                }
		            }
		        }
			        return { imageEvals: total, budgets, invalidBudgets: false };
			    }

		    function updateAgentStepsComputeEstimate() {
		        if (!agentElements.stepsBudgetText || !agentElements.stepsBudgetFill || !agentElements.stepsBudgetBadge) return;
		        const meta = getAgentSelectedDatasetMeta();
		        const isSteps = (agentElements.searchMode ? String(agentElements.searchMode.value || "").trim() : "steps") === "steps";
		        const hasHead = !!(agentElements.clipHeadSelect && agentElements.clipHeadSelect.value);
		        const preset = getAgentStepsGlobalPreset();
		        const globalRequested = preset !== "off";
		        const globalEnabled = !!(isSteps && hasHead && globalRequested);

		        const evalCountRaw = readNumberInput(agentElements.evalImageCount, { integer: true });
		        const evalCount = Number.isFinite(evalCountRaw) ? Math.max(1, Math.min(50000, evalCountRaw)) : null;
		        const totalImagesRaw = meta && meta.image_count !== undefined && meta.image_count !== null ? parseInt(meta.image_count, 10) : NaN;
		        const totalImages = Number.isFinite(totalImagesRaw) && totalImagesRaw > 0 ? totalImagesRaw : null;
		        const sampleImages = evalCount !== null ? (totalImages !== null ? Math.min(evalCount, totalImages) : evalCount) : null;

	        const stepsRaw = readNumberInput(agentElements.stepsMaxSteps, { integer: true });
        const steps = Number.isFinite(stepsRaw) ? Math.max(1, Math.min(50, stepsRaw)) : 6;
        const seedsRaw = readNumberInput(agentElements.stepsMaxSeedsPerStep, { integer: true });
        const seeds = Number.isFinite(seedsRaw) ? Math.max(0, Math.min(500, seedsRaw)) : 10;
	        const perImageUnits = steps * (1 + seeds);
	        const earlyStopEnabled = !!(agentElements.stepsEarlyStop && agentElements.stepsEarlyStop.checked);
	        const earlyStopMode =
	            agentElements.stepsEarlyStopMode && agentElements.stepsEarlyStopMode.value
	                ? agentElements.stepsEarlyStopMode.value
	                : "balanced";
	        const prefilterAllowed = isAgentPromptPrefilterAllowed();
	        const prefilterEnabled = !!(
	            prefilterAllowed &&
	            agentElements.stepsPromptPrefilter &&
	            agentElements.stepsPromptPrefilter.checked
	        );
        const prefilterMode =
            agentElements.stepsPromptPrefilterMode && agentElements.stepsPromptPrefilterMode.value
                ? agentElements.stepsPromptPrefilterMode.value
                : "balanced";
        const bgDropAllowed = hasHead && hasAgentClipHeadBackgroundClasses();
        const bgDropEnabled = !!(
            bgDropAllowed &&
            agentElements.stepsPromptBgDrop &&
            agentElements.stepsPromptBgDrop.checked
        );
        const bgDropMode =
            agentElements.stepsPromptBgDropMode && agentElements.stepsPromptBgDropMode.value
                ? agentElements.stepsPromptBgDropMode.value
                : "balanced";
        const earlyStopFactor = earlyStopEnabled
            ? earlyStopMode === "conservative"
                ? 0.9
                : earlyStopMode === "aggressive"
                  ? 0.65
                  : 0.8
            : 1.0;
        const prefilterFactor = prefilterEnabled
            ? prefilterMode === "conservative"
                ? 0.85
                : prefilterMode === "aggressive"
                  ? 0.55
                  : 0.7
            : 1.0;
        const bgDropFactor = bgDropEnabled
            ? bgDropMode === "conservative"
                ? 0.92
                : bgDropMode === "aggressive"
                  ? 0.7
                  : 0.82
            : 1.0;
        const speedFactor = earlyStopFactor * prefilterFactor * bgDropFactor;

		        const classIds = parseAgentClassIdList(agentElements.classesInput ? agentElements.classesInput.value : "");
		        const classCount =
		            classIds && classIds.length
		                ? classIds.length
		                : meta && Array.isArray(meta.classes) && meta.classes.length
		                  ? meta.classes.length
		                  : null;

		        if (sampleImages === null) {
		            agentElements.stepsBudgetBadge.textContent = "—";
		            agentElements.stepsBudgetBadge.style.background = "#e2e8f0";
		            agentElements.stepsBudgetBadge.style.color = "#0f172a";
		            agentElements.stepsBudgetText.textContent = "Select a dataset to estimate compute.";
		            agentElements.stepsBudgetFill.style.width = "0%";
		            agentElements.stepsBudgetFill.style.background = "linear-gradient(90deg, #94a3b8 0%, #cbd5e1 100%)";
		            return;
		        }

	        const baseUnitsPerClass = sampleImages * perImageUnits * speedFactor;

		        const evalCap1 = readNumberInput(agentElements.stepsGlobalEvalCap1, { integer: true });
		        const evalCap2 = readNumberInput(agentElements.stepsGlobalEvalCap2, { integer: true });
		        const evalCap3 = readNumberInput(agentElements.stepsGlobalEvalCap3, { integer: true });
		        const maxTrials = readNumberInput(agentElements.stepsGlobalMaxTrials, { integer: true });
		        const keepRatio = readNumberInput(agentElements.stepsGlobalKeepRatio, { integer: false });
		        const rounds = readNumberInput(agentElements.stepsGlobalRounds, { integer: true });
		        const mutations = readNumberInput(agentElements.stepsGlobalMutationsPerRound, { integer: true });

		        const globalEstimate = globalEnabled
		            ? estimateAgentGlobalOptimizerImageEvals({
		                  valImages: sampleImages,
		                  evalCaps: [evalCap1, evalCap2, evalCap3],
		                  keepRatio,
		                  rounds,
		                  maxTrials,
		                  mutationsPerRound: mutations,
		              })
		            : { imageEvals: 0, budgets: [], invalidBudgets: false };

	        const globalUnitsPerClass =
	            globalEnabled && !globalEstimate.invalidBudgets ? globalEstimate.imageEvals * perImageUnits * speedFactor : 0;
		        const totalUnitsPerClass = baseUnitsPerClass + globalUnitsPerClass;
		        const totalUnitsAllClasses = classCount !== null ? totalUnitsPerClass * classCount : null;
		        const displayUnits = totalUnitsAllClasses !== null ? totalUnitsAllClasses : totalUnitsPerClass;

		        const pct = Math.max(0, Math.min(100, 15 * Math.log10(displayUnits + 1)));
		        agentElements.stepsBudgetFill.style.width = `${pct.toFixed(1)}%`;

		        let badge = "Low";
		        let badgeBg = "#dcfce7";
		        let badgeFg = "#166534";
		        let fillBg = "linear-gradient(90deg, #16a34a 0%, #86efac 100%)";
			        if (globalEnabled && globalEstimate.invalidBudgets) {
			            badge = "Invalid";
			            badgeBg = "#fee2e2";
			            badgeFg = "#991b1b";
			            fillBg = "linear-gradient(90deg, #94a3b8 0%, #cbd5e1 100%)";
		        } else if (pct >= 75) {
		            badge = "Very high";
		            badgeBg = "#fee2e2";
		            badgeFg = "#991b1b";
		            fillBg = "linear-gradient(90deg, #ef4444 0%, #fca5a5 100%)";
		        } else if (pct >= 55) {
		            badge = "High";
		            badgeBg = "#ffedd5";
		            badgeFg = "#9a3412";
		            fillBg = "linear-gradient(90deg, #f97316 0%, #fdba74 100%)";
		        } else if (pct >= 35) {
		            badge = "Medium";
		            badgeBg = "#fef9c3";
		            badgeFg = "#854d0e";
		            fillBg = "linear-gradient(90deg, #eab308 0%, #fde047 100%)";
		        }
		        agentElements.stepsBudgetBadge.textContent = badge;
		        agentElements.stepsBudgetBadge.style.background = badgeBg;
		        agentElements.stepsBudgetBadge.style.color = badgeFg;
		        agentElements.stepsBudgetFill.style.background = fillBg;

			        const lines = [];
        lines.push(`Sample images: ${sampleImages} • steps: ${steps} • candidates/step: ${seeds}`);
        if (earlyStopEnabled || prefilterEnabled || !prefilterAllowed || bgDropEnabled || (hasHead && !bgDropAllowed)) {
            const speedBits = [];
            if (earlyStopEnabled) speedBits.push(`early-stop ${earlyStopMode}`);
            if (prefilterEnabled) {
                speedBits.push(`CLIP prefilter ${prefilterMode}`);
            } else if (!prefilterAllowed) {
                speedBits.push("CLIP prefilter disabled (non-CLIP head)");
            }
            if (bgDropEnabled) {
                speedBits.push(`bg drop ${bgDropMode}`);
            } else if (hasHead && !bgDropAllowed) {
                speedBits.push("bg drop disabled (no background classes)");
            }
            speedBits.push(`est. ${(speedFactor * 100).toFixed(0)}% base work`);
            lines.push(`Speed helpers: ${speedBits.join(" • ")}`);
        }
				        const globalLine = globalRequested
				            ? globalEnabled
				                ? globalEstimate.invalidBudgets
				                    ? "Global optimizer: invalid Stage caps."
				                    : `Global optimizer: +${formatCompactCount(globalUnitsPerClass)} work (per class)`
				                : !isSteps
				                  ? "Global optimizer: only available in Multi-step mode."
				                  : !hasHead
				                    ? "Global optimizer: requires a pretrained CLIP head."
			                    : "Global optimizer: off"
			            : "Global optimizer: off";
			        lines.push(globalLine);
			        if (globalRequested) {
			            const breadthBits = [];
			            breadthBits.push(`trials=${Number.isFinite(maxTrials) ? Math.max(1, Math.floor(maxTrials)) : "?"}`);
			            breadthBits.push(`rounds=${Number.isFinite(rounds) ? Math.max(1, Math.floor(rounds)) : "?"}`);
			            breadthBits.push(`variants/round=${Number.isFinite(mutations) ? Math.max(1, Math.floor(mutations)) : "?"}`);
			            const maxStepsMutated = readNumberInput(agentElements.stepsGlobalMaxStepsMutated, { integer: true });
			            breadthBits.push(`max step changes=${Number.isFinite(maxStepsMutated) ? Math.max(1, Math.floor(maxStepsMutated)) : "?"}`);
			            lines.push(`Breadth: ${breadthBits.join(" • ")}`);

			            if (globalEstimate.invalidBudgets) {
			                lines.push("Depth: invalid stage caps");
			            } else {
			                const depthBits = [];
			                const cap1 = Number.isFinite(evalCap1) ? Math.max(1, Math.floor(evalCap1)) : "?";
			                const cap2 = Number.isFinite(evalCap2) ? Math.max(1, Math.floor(evalCap2)) : "?";
			                const cap3 = Number.isFinite(evalCap3) ? Math.max(1, Math.floor(evalCap3)) : "?";
			                depthBits.push(`caps=[${cap1}, ${cap2}, ${cap3}]`);
			                depthBits.push(`keep=${Number.isFinite(keepRatio) ? Math.max(0.1, Math.min(0.9, keepRatio)).toFixed(2) : "?"}`);
			                lines.push(`Depth: ${depthBits.join(" • ")}`);
			            }
			        }
			        lines.push(
			            `Work (per class): ${formatCompactCount(totalUnitsPerClass)} (base ${formatCompactCount(baseUnitsPerClass)} + global ${formatCompactCount(
			                globalUnitsPerClass
			            )})`
			        );
		        if (totalUnitsAllClasses !== null) {
		            lines.push(`All classes (~${classCount}): ${formatCompactCount(totalUnitsAllClasses)} work`);
		        }
		        agentElements.stepsBudgetText.textContent = lines.join("\n");
		    }

		    function syncAgentStepsOptimizationControls() {
		        const mode = agentElements.searchMode ? String(agentElements.searchMode.value || "").trim() : "steps";
		        const isSteps = mode === "steps";
		        const hasHead = !!(agentElements.clipHeadSelect && agentElements.clipHeadSelect.value);
		        const allowGlobal = isSteps && hasHead;
	        const reason = !isSteps ? "Only available in Multi-step mode." : !hasHead ? "Requires a pretrained CLIP head." : "";
	        const preset = getAgentStepsGlobalPreset();
	        const globalEnabled = !!(allowGlobal && preset !== "off");
	        if (agentElements.stepsGlobalPreset) {
	            agentElements.stepsGlobalPreset.disabled = !isSteps;
	            agentElements.stepsGlobalPreset.title = !isSteps ? "Only available in Multi-step mode." : "";
	        }

		        const globalFields = [
		            agentElements.stepsGlobalEvalCap1,
		            agentElements.stepsGlobalEvalCap2,
		            agentElements.stepsGlobalEvalCap3,
	            agentElements.stepsGlobalMaxTrials,
	            agentElements.stepsGlobalKeepRatio,
	            agentElements.stepsGlobalRounds,
	            agentElements.stepsGlobalMutationsPerRound,
	            agentElements.stepsGlobalMaxStepsMutated,
		            agentElements.stepsGlobalEnableOrdering,
		            agentElements.stepsGlobalEnableMaxResults,
		        ];
	        globalFields.forEach((el) => {
	            if (!el) return;
	            el.disabled = !globalEnabled;
	        });

        const allowTier1 = isSteps && hasHead;
        if (agentElements.stepsTier1Optimize) {
            agentElements.stepsTier1Optimize.disabled = !allowTier1 || globalEnabled;
            agentElements.stepsTier1Optimize.title = globalEnabled ? "Disabled because Global optimization is enabled." : reason;
            if (globalEnabled) agentElements.stepsTier1Optimize.checked = false;
        }
        const enabled = !!(allowTier1 && agentElements.stepsTier1Optimize && agentElements.stepsTier1Optimize.checked);
        if (agentElements.stepsTier1EvalCap) agentElements.stepsTier1EvalCap.disabled = !enabled;
        if (agentElements.stepsTier1MaxTrials) agentElements.stepsTier1MaxTrials.disabled = !enabled;

        const allowTier2 = isSteps && hasHead;
        if (agentElements.stepsTier2Optimize) {
            agentElements.stepsTier2Optimize.disabled = !allowTier2 || globalEnabled;
            agentElements.stepsTier2Optimize.title = globalEnabled ? "Disabled because Global optimization is enabled." : reason;
            if (globalEnabled) agentElements.stepsTier2Optimize.checked = false;
        }
        const enabled2 = !!(allowTier2 && agentElements.stepsTier2Optimize && agentElements.stepsTier2Optimize.checked);
        if (agentElements.stepsTier2EvalCap) agentElements.stepsTier2EvalCap.disabled = !enabled2;
        if (agentElements.stepsTier2MaxTrials) agentElements.stepsTier2MaxTrials.disabled = !enabled2;

        const allowRefine = isSteps;
        const refineReason = !isSteps ? "Only available in Multi-step mode." : "";
        if (agentElements.stepsRefinePromptSubset) {
            agentElements.stepsRefinePromptSubset.disabled = !allowRefine || globalEnabled;
            agentElements.stepsRefinePromptSubset.title = globalEnabled ? "Disabled because Global optimization is enabled." : refineReason;
            if (globalEnabled) agentElements.stepsRefinePromptSubset.checked = false;
        }
	        const refineEnabled = !!(allowRefine && agentElements.stepsRefinePromptSubset && agentElements.stepsRefinePromptSubset.checked);
	        if (agentElements.stepsRefineMaxIters) agentElements.stepsRefineMaxIters.disabled = !refineEnabled;
	        if (agentElements.stepsRefineTopK) agentElements.stepsRefineTopK.disabled = !refineEnabled;
	        updateAgentStepsComputeEstimate();
	    }

    async function loadAgentClipClassifiers() {
        if (!agentElements.clipHeadSelect) return;
        try {
            const prev = agentElements.clipHeadSelect.value || "";
            const resp = await fetch(`${API_ROOT}/clip/classifiers`);
            if (!resp.ok) throw new Error(await resp.text());
            const data = await resp.json();
            const list = Array.isArray(data) ? data : [];
            agentState.clipHeads = list;
            agentElements.clipHeadSelect.innerHTML = "";
            const empty = document.createElement("option");
            empty.value = "";
            empty.textContent = list.length ? "Select a CLIP head…" : "No CLIP heads found (train CLIP first)";
            agentElements.clipHeadSelect.appendChild(empty);
            list.forEach((entry) => {
                const rel = entry.rel_path || "";
                if (!rel) return;
                const opt = document.createElement("option");
                opt.value = rel;
                const bits = [];
                if (entry.filename) bits.push(entry.filename);
                if (entry.n_classes) bits.push(`${entry.n_classes} classes`);
                const encoderTypeRaw = entry.encoder_type || "clip";
                const encoderType = String(encoderTypeRaw).toUpperCase();
                const encoderModel = entry.encoder_model || entry.clip_model;
                if (encoderModel) {
                    bits.push(`${encoderType}:${encoderModel}`);
                } else if (encoderType) {
                    bits.push(encoderType);
                }
                opt.textContent = bits.join(" • ") || rel;
                agentElements.clipHeadSelect.appendChild(opt);
            });
            const hasPrev = prev && Array.from(agentElements.clipHeadSelect.options || []).some((opt) => opt && opt.value === prev);
            if (hasPrev) {
                agentElements.clipHeadSelect.value = prev;
            } else if (list.length === 1 && list[0] && list[0].rel_path) {
                agentElements.clipHeadSelect.value = String(list[0].rel_path);
            } else {
                agentElements.clipHeadSelect.value = "";
            }
        } catch (err) {
            console.warn("Failed to load CLIP classifiers", err);
        } finally {
            syncAgentClipHeadControls();
            updateAgentClipHeadMeta();
        }
    }

    function parseAgentExtraPrompts(rawText) {
        const extraRaw = (rawText || "").trim();
        if (!extraRaw) return { data: null, mode: "empty" };

        const normalize = (parsed) => {
            if (!parsed || typeof parsed !== "object") return null;
            const cleaned = {};
            Object.entries(parsed).forEach(([key, val]) => {
                if (!key || typeof key !== "string") return;
                const name = key.trim();
                if (!name) return;
                if (Array.isArray(val)) {
                    const items = val
                        .filter((v) => typeof v === "string")
                        .map((v) => v.trim())
                        .filter(Boolean);
                    if (items.length) cleaned[name] = items;
                } else if (typeof val === "string") {
                    const items = val
                        .split(/[,\n]+/)
                        .map((v) => v.trim())
                        .filter(Boolean);
                    if (items.length) cleaned[name] = items;
                }
            });
            return Object.keys(cleaned).length ? cleaned : null;
        };

        try {
            const parsed = JSON.parse(extraRaw);
            const cleaned = normalize(parsed);
            return cleaned ? { data: cleaned, mode: "json" } : { data: null, mode: "empty" };
        } catch (_err) {
            // Lenient fallback: accept `"class": [a, b, c]` (items may be unquoted).
            const cleaned = {};
            const rx = /["']([^"']+)["']\s*:\s*\[([^\]]*)\]/g;
            let match;
            while ((match = rx.exec(extraRaw)) !== null) {
                const key = (match[1] || "").trim();
                const inner = (match[2] || "").trim();
                if (!key) continue;
                if (!inner) continue;
                const items = inner
                    .split(",")
                    .map((v) => v.trim())
                    .map((v) => {
                        if ((v.startsWith("\"") && v.endsWith("\"")) || (v.startsWith("'") && v.endsWith("'"))) {
                            return v.slice(1, -1).trim();
                        }
                        return v;
                    })
                    .filter(Boolean);
                if (items.length) cleaned[key] = items;
            }
            return Object.keys(cleaned).length ? { data: cleaned, mode: "loose" } : { data: null, mode: "invalid" };
        }
    }

			    function parseAgentPayload() {
			        const datasetId = agentElements.datasetSelect?.value;
			        if (!datasetId) {
			            setAgentStatus("Select a dataset.", "warn");
			            return null;
			        }

			        const searchMode = "steps";
			        const stepsMaxStepsRaw = readNumberInput(agentElements.stepsMaxSteps, { integer: true });
        const stepsMaxSteps = Number.isFinite(stepsMaxStepsRaw) ? Math.max(1, Math.min(50, stepsMaxStepsRaw)) : 6;
        const stepsMaxSeedsRaw = readNumberInput(agentElements.stepsMaxSeedsPerStep, { integer: true });
        const stepsMaxSeedsPerStep = Number.isFinite(stepsMaxSeedsRaw) ? Math.max(0, Math.min(500, stepsMaxSeedsRaw)) : 10;
			        const stepsGlobalPreset = getAgentStepsGlobalPreset();
			        const stepsGlobalOptimizeRaw = stepsGlobalPreset !== "off";
		        const stepsGlobalCap1Raw = readNumberInput(agentElements.stepsGlobalEvalCap1, { integer: true });
		        const stepsGlobalCap1 = Number.isFinite(stepsGlobalCap1Raw) ? Math.max(1, Math.min(50000, stepsGlobalCap1Raw)) : 50;
		        const stepsGlobalCap2Raw = readNumberInput(agentElements.stepsGlobalEvalCap2, { integer: true });
		        const stepsGlobalCap2 = Number.isFinite(stepsGlobalCap2Raw) ? Math.max(1, Math.min(50000, stepsGlobalCap2Raw)) : 200;
		        const stepsGlobalCap3Raw = readNumberInput(agentElements.stepsGlobalEvalCap3, { integer: true });
		        const stepsGlobalCap3 = Number.isFinite(stepsGlobalCap3Raw) ? Math.max(1, Math.min(50000, stepsGlobalCap3Raw)) : 1000;
		        const stepsGlobalEvalCaps = [stepsGlobalCap1, stepsGlobalCap2, stepsGlobalCap3];
		        const stepsGlobalMaxTrialsRaw = readNumberInput(agentElements.stepsGlobalMaxTrials, { integer: true });
		        const stepsGlobalMaxTrials = Number.isFinite(stepsGlobalMaxTrialsRaw)
		            ? Math.max(1, Math.min(4096, stepsGlobalMaxTrialsRaw))
		            : 36;
		        const stepsGlobalKeepRatioRaw = readNumberInput(agentElements.stepsGlobalKeepRatio, { integer: false });
		        const stepsGlobalKeepRatio = Number.isFinite(stepsGlobalKeepRatioRaw)
		            ? Math.max(0.1, Math.min(0.9, stepsGlobalKeepRatioRaw))
		            : 0.5;
			        const stepsGlobalRoundsRaw = readNumberInput(agentElements.stepsGlobalRounds, { integer: true });
			        const stepsGlobalRounds = Number.isFinite(stepsGlobalRoundsRaw) ? Math.max(1, Math.min(20, stepsGlobalRoundsRaw)) : 2;
			        const stepsGlobalMutationsRaw = readNumberInput(agentElements.stepsGlobalMutationsPerRound, { integer: true });
			        const stepsGlobalMutationsPerRound = Number.isFinite(stepsGlobalMutationsRaw)
			            ? Math.max(1, Math.min(10000, stepsGlobalMutationsRaw))
			            : 24;
			        const stepsGlobalMaxStepsMutatedRaw = readNumberInput(agentElements.stepsGlobalMaxStepsMutated, { integer: true });
			        const stepsGlobalMaxStepsMutated = Number.isFinite(stepsGlobalMaxStepsMutatedRaw)
			            ? Math.max(1, Math.min(10, stepsGlobalMaxStepsMutatedRaw))
			            : 2;
			        const stepsGlobalEnableOrdering = !!(agentElements.stepsGlobalEnableOrdering && agentElements.stepsGlobalEnableOrdering.checked);
			        const stepsGlobalEnableMaxResults = !!(agentElements.stepsGlobalEnableMaxResults && agentElements.stepsGlobalEnableMaxResults.checked);

		        const evalCountRaw = readNumberInput(agentElements.evalImageCount, { integer: true });
		        const evalImageCount = Number.isFinite(evalCountRaw) ? Math.max(1, Math.min(50000, evalCountRaw)) : 100;
		        const splitSeed = readNumberInput(agentElements.splitSeed, { integer: true });
		        const reuseCache = agentElements.reuseCache ? !!agentElements.reuseCache.checked : true;
		        const workersPerGpuRaw = readNumberInput(agentElements.workersPerGpu, { integer: true });
		        const workersPerGpu = Number.isFinite(workersPerGpuRaw) ? Math.max(1, Math.min(8, workersPerGpuRaw)) : 1;
		        const maxWorkersRaw = readNumberInput(agentElements.maxWorkers, { integer: true });
		        const maxWorkers = Number.isFinite(maxWorkersRaw) ? Math.max(1, Math.min(256, maxWorkersRaw)) : null;

		        const iouThresholdRaw = readNumberInput(agentElements.iouThreshold, { integer: false });
		        const iouThreshold = Number.isFinite(iouThresholdRaw) ? Math.max(0, Math.min(1, iouThresholdRaw)) : 0.5;

        const seedThrRaw = readNumberInput(agentElements.seedThreshold, { integer: false });
        const seedThreshold = Number.isFinite(seedThrRaw) ? Math.max(0, Math.min(1, seedThrRaw)) : 0.02;
        const expandThrRaw = readNumberInput(agentElements.expandThreshold, { integer: false });
        const expandThreshold = Number.isFinite(expandThrRaw) ? Math.max(0, Math.min(1, expandThrRaw)) : 0.15;
	        const seedDedupeIouRaw = readNumberInput(agentElements.seedDedupeIou, { integer: false });
	        const seedDedupeIou = Number.isFinite(seedDedupeIouRaw) ? Math.max(0, Math.min(1, seedDedupeIouRaw)) : 0.9;
	        const dedupeIouRaw = readNumberInput(agentElements.dedupeIou, { integer: false });
	        const dedupeIou = Number.isFinite(dedupeIouRaw) ? Math.max(0, Math.min(1, dedupeIouRaw)) : 0.5;

	        const maskThresholdRaw = readNumberInput(agentElements.maskThreshold, { integer: false });
	        const maskThreshold = Number.isFinite(maskThresholdRaw) ? Math.max(0, Math.min(1, maskThresholdRaw)) : 0.5;
	        const maxResultsRaw = readNumberInput(agentElements.maxResults, { integer: true });
	        const maxResults = Number.isFinite(maxResultsRaw) ? Math.max(1, Math.min(5000, maxResultsRaw)) : 1000;
	        const minSizeRaw = readNumberInput(agentElements.minSize, { integer: true });
	        const minSize = Number.isFinite(minSizeRaw) ? Math.max(0, Math.min(10000, minSizeRaw)) : 0;
	        const simplifyEpsRaw = readNumberInput(agentElements.simplifyEps, { integer: false });
	        const simplifyEps = Number.isFinite(simplifyEpsRaw) ? Math.max(0, Math.min(1000, simplifyEpsRaw)) : 0.0;


	        const promptReasoning =
	            agentElements.promptReasoning && agentElements.promptReasoning.value ? agentElements.promptReasoning.value : "none";
	        const promptMaxTokensRaw = readNumberInput(agentElements.promptMaxTokens, { integer: true });
	        const promptMaxTokens = Number.isFinite(promptMaxTokensRaw) ? Math.max(16, Math.min(800, promptMaxTokensRaw)) : 160;
	        const promptMaxPromptsRaw = readNumberInput(agentElements.qwenMaxPrompts, { integer: true });
	        const promptMaxPrompts = Number.isFinite(promptMaxPromptsRaw) ? Math.max(0, Math.min(50, promptMaxPromptsRaw)) : 0;

	        const clipHeadPathRaw = agentElements.clipHeadSelect?.value || "";
	        const clipHeadClassifierPath = clipHeadPathRaw ? clipHeadPathRaw : null;
	        const clipHeadAutoTune = !!(agentElements.clipHeadAutoTune && agentElements.clipHeadAutoTune.checked);
        const clipHeadTuneMargin = agentElements.clipHeadTuneMargin
            ? !!agentElements.clipHeadTuneMargin.checked
            : true;
	        const clipHeadTargetPrecisionRaw = readNumberInput(agentElements.clipHeadTargetPrecision, { integer: false });
        const clipHeadTargetPrecision = Number.isFinite(clipHeadTargetPrecisionRaw)
            ? Math.max(0, Math.min(1, clipHeadTargetPrecisionRaw))
            : 0.75;
        const clipHeadMinProbRaw = readNumberInput(agentElements.clipHeadMinProb, { integer: false });
        const clipHeadMinProb = Number.isFinite(clipHeadMinProbRaw) ? Math.max(0, Math.min(1, clipHeadMinProbRaw)) : 0.5;
        const clipHeadMarginRaw = readNumberInput(agentElements.clipHeadMargin, { integer: false });
        const clipHeadMargin = Number.isFinite(clipHeadMarginRaw) ? Math.max(0, Math.min(1, clipHeadMarginRaw)) : 0.0;
        const clipHeadBgGuard = !!(agentElements.clipHeadBgGuard && agentElements.clipHeadBgGuard.checked);
        const clipHeadBgMarginRaw = readNumberInput(agentElements.clipHeadBgMargin, { integer: false });
        const clipHeadBgMargin = Number.isFinite(clipHeadBgMarginRaw) ? Math.max(0, Math.min(1, clipHeadBgMarginRaw)) : 0.0;
        let clipHeadBgApply =
            agentElements.clipHeadBgApply && agentElements.clipHeadBgApply.value
                ? String(agentElements.clipHeadBgApply.value)
                : "final";
        if (!["seed", "final", "both"].includes(clipHeadBgApply)) {
            clipHeadBgApply = "final";
        }
        const clipHeadBgPenaltyRaw = readNumberInput(agentElements.clipHeadBgPenalty, { integer: false });
        const clipHeadBgPenalty = Number.isFinite(clipHeadBgPenaltyRaw) ? Math.max(0, clipHeadBgPenaltyRaw) : 0.0;
        const clipHeadBgAutoTune = !!(
            clipHeadAutoTune &&
            hasAgentClipHeadBackgroundClasses() &&
            agentElements.clipHeadBgAutoTune &&
            agentElements.clipHeadBgAutoTune.checked
        );
        const hasClipHead = !!clipHeadClassifierPath;
	        if (!hasClipHead) {
	            setAgentStatus("Select a pretrained CLIP head (required). Train one in the CLIP tab first.", "warn");
	            return null;
	        }

	        const stepsTier1Optimize = !!(agentElements.stepsTier1Optimize && agentElements.stepsTier1Optimize.checked);
	        const stepsTier1EvalCapRaw = readNumberInput(agentElements.stepsTier1EvalCap, { integer: true });
	        const stepsTier1EvalCap = Number.isFinite(stepsTier1EvalCapRaw)
	            ? Math.max(10, Math.min(50000, stepsTier1EvalCapRaw))
	            : 200;
	        const stepsTier1MaxTrialsRaw = readNumberInput(agentElements.stepsTier1MaxTrials, { integer: true });
	        const stepsTier1MaxTrials = Number.isFinite(stepsTier1MaxTrialsRaw)
	            ? Math.max(1, Math.min(256, stepsTier1MaxTrialsRaw))
	            : 9;
	        const stepsOptimizeGlobal = !!(stepsGlobalOptimizeRaw && searchMode === "steps" && hasClipHead);
	        const stepsOptimizeTier1 = !!(stepsTier1Optimize && searchMode === "steps" && hasClipHead && !stepsOptimizeGlobal);

	        const stepsTier2Optimize = !!(agentElements.stepsTier2Optimize && agentElements.stepsTier2Optimize.checked);
	        const stepsTier2EvalCapRaw = readNumberInput(agentElements.stepsTier2EvalCap, { integer: true });
	        const stepsTier2EvalCap = Number.isFinite(stepsTier2EvalCapRaw)
	            ? Math.max(10, Math.min(50000, stepsTier2EvalCapRaw))
	            : 200;
	        const stepsTier2MaxTrialsRaw = readNumberInput(agentElements.stepsTier2MaxTrials, { integer: true });
	        const stepsTier2MaxTrials = Number.isFinite(stepsTier2MaxTrialsRaw)
	            ? Math.max(1, Math.min(256, stepsTier2MaxTrialsRaw))
	            : 12;
	        const stepsOptimizeTier2 = !!(stepsTier2Optimize && searchMode === "steps" && hasClipHead && !stepsOptimizeGlobal);

	        const stepsRefinePromptSubset = !!(agentElements.stepsRefinePromptSubset && agentElements.stepsRefinePromptSubset.checked);
	        const stepsRefineMaxItersRaw = readNumberInput(agentElements.stepsRefineMaxIters, { integer: true });
	        const stepsRefineMaxIters = Number.isFinite(stepsRefineMaxItersRaw)
	            ? Math.max(0, Math.min(100, stepsRefineMaxItersRaw))
	            : 6;
	        const stepsRefineTopKRaw = readNumberInput(agentElements.stepsRefineTopK, { integer: true });
        const stepsRefineTopK = Number.isFinite(stepsRefineTopKRaw) ? Math.max(1, Math.min(50, stepsRefineTopKRaw)) : 6;
        const stepsEnableRefine = !!(stepsRefinePromptSubset && searchMode === "steps" && !stepsOptimizeGlobal);

        const stepsHardNegExport = !!(
            hasClipHead &&
            agentElements.stepsHardNegExport &&
            agentElements.stepsHardNegExport.checked
        );
        const stepsHardNegMaxCropsRaw = readNumberInput(agentElements.stepsHardNegMaxCrops, { integer: true });
        const stepsHardNegMaxCrops = Number.isFinite(stepsHardNegMaxCropsRaw)
            ? Math.max(0, Math.min(5000, stepsHardNegMaxCropsRaw))
            : 200;
        const stepsHardNegMinProbRaw = readNumberInput(agentElements.stepsHardNegMinProb, { integer: false });
        const stepsHardNegMinProb = Number.isFinite(stepsHardNegMinProbRaw)
            ? Math.max(0, Math.min(1, stepsHardNegMinProbRaw))
            : 0.1;

	        const stepsSeedEvalFloorRaw = readNumberInput(agentElements.stepsSeedEvalFloor, { integer: false });
	        const stepsSeedEvalFloor = Number.isFinite(stepsSeedEvalFloorRaw)
	            ? Math.max(0, Math.min(1, stepsSeedEvalFloorRaw))
	            : null;
	        const stepsSeedEvalMaxResultsRaw = readNumberInput(agentElements.stepsSeedEvalMaxResults, { integer: true });
	        const stepsSeedEvalMaxResults = Number.isFinite(stepsSeedEvalMaxResultsRaw)
	            ? Math.max(1, Math.min(5000, stepsSeedEvalMaxResultsRaw))
	            : null;
	        const stepsEarlyStop = !!(agentElements.stepsEarlyStop && agentElements.stepsEarlyStop.checked);
	        let stepsEarlyStopMode =
	            agentElements.stepsEarlyStopMode && agentElements.stepsEarlyStopMode.value
	                ? agentElements.stepsEarlyStopMode.value
	                : "balanced";
	        if (!["conservative", "balanced", "aggressive"].includes(stepsEarlyStopMode)) {
	            stepsEarlyStopMode = "balanced";
	        }
	        const prefilterAllowed = isAgentPromptPrefilterAllowed();
	        const stepsPromptPrefilter = !!(
	            prefilterAllowed &&
	            agentElements.stepsPromptPrefilter &&
	            agentElements.stepsPromptPrefilter.checked
	        );
	        let stepsPromptPrefilterMode =
	            agentElements.stepsPromptPrefilterMode && agentElements.stepsPromptPrefilterMode.value
	                ? agentElements.stepsPromptPrefilterMode.value
	                : "balanced";
        if (!["conservative", "balanced", "aggressive"].includes(stepsPromptPrefilterMode)) {
            stepsPromptPrefilterMode = "balanced";
        }

        const bgDropAllowed = hasAgentClipHeadBackgroundClasses();
        const stepsPromptBgDrop = !!(
            bgDropAllowed &&
            agentElements.stepsPromptBgDrop &&
            agentElements.stepsPromptBgDrop.checked
        );
        let stepsPromptBgDropMode =
            agentElements.stepsPromptBgDropMode && agentElements.stepsPromptBgDropMode.value
                ? agentElements.stepsPromptBgDropMode.value
                : "balanced";
        if (!["conservative", "balanced", "aggressive"].includes(stepsPromptBgDropMode)) {
            stepsPromptBgDropMode = "balanced";
        }

	        const classesRaw = agentElements.classesInput?.value || "";
		        const classes =
		            classesRaw
		                .split(/[,\\s]+/)
	                .map((p) => parseInt(p.trim(), 10))
	                .filter((v) => Number.isInteger(v)) || [];
		        let extraPromptsByClass = null;
		        const extraParse = parseAgentExtraPrompts(agentElements.extraPrompts?.value || "");
		        if (extraParse.data) extraPromptsByClass = extraParse.data;
		        if (agentElements.extraPromptsStatus) {
		            const hasBasePrompts = !!(extraPromptsByClass && Object.prototype.hasOwnProperty.call(extraPromptsByClass, "__base__"));
		            const classCount = extraPromptsByClass ? Object.keys(extraPromptsByClass).filter((k) => k !== "__base__").length : 0;
		            const baseSuffix = hasBasePrompts ? " + base prompts" : "";
		            if (extraParse.mode === "empty") {
		                agentElements.extraPromptsStatus.textContent = "";
		                agentElements.extraPromptsStatus.style.color = "";
		            } else if (extraParse.mode === "json") {
		                agentElements.extraPromptsStatus.textContent = `Extra prompts loaded for ${classCount} class(es)${baseSuffix}.`;
		                agentElements.extraPromptsStatus.style.color = "";
		            } else if (extraParse.mode === "loose") {
		                agentElements.extraPromptsStatus.textContent =
		                    `Extra prompts parsed (lenient mode) for ${classCount} class(es)${baseSuffix}. Tip: use JSON quotes for clarity.`;
		                agentElements.extraPromptsStatus.style.color = "#b45309";
		            } else {
		                agentElements.extraPromptsStatus.textContent = "Extra prompts format invalid; ignored.";
		                agentElements.extraPromptsStatus.style.color = "#b91c1c";
		            }
		        }

			        return {
			            dataset_id: datasetId,
			            search_mode: searchMode,
			            steps_max_steps_per_recipe: stepsMaxSteps,
			            steps_max_visual_seeds_per_step: stepsMaxSeedsPerStep,
			            steps_optimize_global: stepsOptimizeGlobal,
			            steps_optimize_global_eval_caps: stepsGlobalEvalCaps,
			            steps_optimize_global_max_trials: stepsGlobalMaxTrials,
			            steps_optimize_global_keep_ratio: stepsGlobalKeepRatio,
			            steps_optimize_global_rounds: stepsGlobalRounds,
			            steps_optimize_global_mutations_per_round: stepsGlobalMutationsPerRound,
			            steps_optimize_global_max_steps_mutated: stepsGlobalMaxStepsMutated,
			            steps_optimize_global_enable_max_results: stepsGlobalEnableMaxResults,
			            steps_optimize_global_enable_ordering: stepsGlobalEnableOrdering,
			            steps_seed_eval_floor: stepsSeedEvalFloor,
			            steps_seed_eval_max_results: stepsSeedEvalMaxResults,
                    steps_early_stop: stepsEarlyStop,
                    steps_early_stop_mode: stepsEarlyStopMode,
                    steps_prompt_prefilter: stepsPromptPrefilter,
                    steps_prompt_prefilter_mode: stepsPromptPrefilterMode,
                    steps_prompt_bg_drop: stepsPromptBgDrop,
                    steps_prompt_bg_drop_mode: stepsPromptBgDropMode,
                    steps_optimize_tier1: stepsOptimizeTier1,
		            steps_optimize_tier1_eval_cap: stepsTier1EvalCap,
		            steps_optimize_tier1_max_trials: stepsTier1MaxTrials,
		            steps_optimize_tier2: stepsOptimizeTier2,
		            steps_optimize_tier2_eval_cap: stepsTier2EvalCap,
			            steps_optimize_tier2_max_trials: stepsTier2MaxTrials,
			            steps_refine_prompt_subset: stepsEnableRefine,
			            steps_refine_prompt_subset_max_iters: stepsRefineMaxIters,
			            steps_refine_prompt_subset_top_k: stepsRefineTopK,
		            reuse_cache: reuseCache,
		            eval_image_count: evalImageCount,
		            split_seed: Number.isFinite(splitSeed) ? splitSeed : 42,
		            max_workers_per_device: workersPerGpu,
		            max_workers: maxWorkers,
		            iou_threshold: iouThreshold,

	            prompt_llm_max_prompts: promptMaxPrompts,
	            prompt_reasoning: ["none", "low", "medium", "high"].includes(promptReasoning) ? promptReasoning : "none",
	            prompt_max_new_tokens: promptMaxTokens,
		            extra_prompts_by_class: extraPromptsByClass,
            clip_head_classifier_path: clipHeadClassifierPath,
            clip_head_min_prob: clipHeadMinProb,
            clip_head_margin: clipHeadMargin,
            clip_head_auto_tune: clipHeadAutoTune,
            clip_head_tune_margin: clipHeadTuneMargin,
            clip_head_target_precision: clipHeadTargetPrecision,
            clip_head_background_guard: clipHeadBgGuard,
            clip_head_background_margin: clipHeadBgMargin,
            clip_head_background_apply: clipHeadBgApply,
            clip_head_background_penalty: clipHeadBgPenalty,
            clip_head_background_auto_tune: clipHeadBgAutoTune,
            steps_hard_negative_export: stepsHardNegExport,
            steps_hard_negative_max_crops: stepsHardNegMaxCrops,
            steps_hard_negative_min_prob: stepsHardNegMinProb,

	            seed_threshold: seedThreshold,
	            expand_threshold: expandThreshold,
	            seed_dedupe_iou: seedDedupeIou,
	            dedupe_iou: dedupeIou,
	            mask_threshold: maskThreshold,
	            max_results: maxResults,
	            min_size: minSize,
	            simplify_epsilon: simplifyEps,

	            classes: classes.length ? classes : null,
	        };
	    }

    async function startAgentMiningJob() {
        const payload = parseAgentPayload();
        if (!payload) return;
        setAgentStatus("Starting agent mining…", "info");
        if (agentElements.runButton) agentElements.runButton.disabled = true;
        updateAgentProgress({ progress: 0 });
        stopAgentPoll();
        try {
            const resp = await fetch(`${API_ROOT}/agent_mining/jobs`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) throw new Error(await resp.text());
            const job = await resp.json();
            agentState.lastJob = job;
            setAgentStatus(`Job ${job.job_id} started`, "success");
            updateAgentProgress(job);
            scheduleAgentPoll();
        } catch (err) {
            console.error("Agent mining start failed", err);
            setAgentStatus(`Start failed: ${err.message || err}`, "error");
        } finally {
            syncAgentRunButtonAvailability();
        }
    }

    function stopAgentPoll() {
        if (agentState.pollTimer) {
            clearInterval(agentState.pollTimer);
            agentState.pollTimer = null;
        }
        agentState.pollInFlight = false;
    }

    function scheduleAgentPoll() {
        stopAgentPoll();
        agentState.pollTimer = setInterval(() => {
            refreshAgentLatest({ silent: true }).catch((err) => console.error("Agent mining refresh failed", err));
        }, 2000);
    }

    async function refreshAgentLatest(options = {}) {
        const { silent = false } = options;
        if (agentState.pollInFlight) return;
        agentState.pollInFlight = true;
        if (!silent) setAgentStatus("Fetching latest result…", "info");
        if (!silent && agentElements.refreshButton) agentElements.refreshButton.disabled = true;
        try {
            const jobId = agentState.lastJob?.job_id;
            const url = jobId ? `${API_ROOT}/agent_mining/jobs/${jobId}` : `${API_ROOT}/agent_mining/results/latest`;
            const resp = await fetch(url);
            if (!resp.ok) throw new Error(await resp.text());
            const job = await resp.json();
            agentState.lastJob = job;
            if (!silent) setAgentStatus(`Latest job: ${job.status}`, "success");
            updateAgentProgress(job);
            renderAgentResults(job.result);
            renderAgentLogs(job);
            refreshAgentCacheSize();
            syncAgentRunButtonAvailability();
            const keepPolling = !["completed", "failed", "cancelled"].includes(job.status || "");
            if (keepPolling) {
                scheduleAgentPoll();
            } else {
                stopAgentPoll();
            }
        } catch (err) {
            console.error("Agent mining latest failed", err);
            setAgentResultsMessage(`Fetch failed: ${err.message || err}`, "error");
            setAgentStatus(`Fetch failed: ${err.message || err}`, "error");
            stopAgentPoll();
        } finally {
            agentState.pollInFlight = false;
            if (!silent && agentElements.refreshButton) agentElements.refreshButton.disabled = false;
        }
    }

    async function cancelAgentJob() {
        const jobId = agentState.lastJob?.job_id;
        if (!jobId) {
            setAgentStatus("No running job to cancel.", "warn");
            return;
        }
        setAgentStatus("Cancelling job…", "info");
        try {
            const resp = await fetch(`${API_ROOT}/agent_mining/jobs/${jobId}/cancel`, { method: "POST" });
            if (!resp.ok) throw new Error(await resp.text());
            const job = await resp.json();
            agentState.lastJob = job;
            setAgentStatus(`Job ${jobId} cancelled`, "success");
            updateAgentProgress(job);
            renderAgentLogs(job);
            syncAgentRunButtonAvailability();
            stopAgentPoll();
        } catch (err) {
            console.error("Agent cancel failed", err);
            setAgentStatus(`Cancel failed: ${err.message || err}`, "error");
        }
    }

	    async function fetchAgentRecipes() {
	        if (!agentElements.recipeSelect) return;
	        agentElements.recipeSelect.innerHTML = "";
	        try {
	            const resp = await fetch(`${API_ROOT}/agent_mining/recipes`);
	            if (!resp.ok) throw new Error(await resp.text());
	            const data = await resp.json();
	            const list = Array.isArray(data) ? data : [];
            list.forEach((rec) => {
                const opt = document.createElement("option");
                opt.value = rec.id || "";
                const labelParts = [];
                if (rec.label) labelParts.push(rec.label);
                if (rec.class_name) labelParts.push(`(${rec.class_name})`);
                opt.textContent = labelParts.join(" ") || rec.id;
                agentElements.recipeSelect.appendChild(opt);
            });
            if (!list.length) {
                const opt = document.createElement("option");
                opt.value = "";
                opt.textContent = "No saved recipes";
                agentElements.recipeSelect.appendChild(opt);
            }
        } catch (err) {
            console.error("Fetch recipes failed", err);
            setAgentStatus(`Recipe list failed: ${err.message || err}`, "error");
	        }
	    }

	    async function downloadSelectedAgentRecipe() {
	        const recipeId = agentElements.recipeSelect?.value;
	        if (!recipeId) {
            setAgentStatus("Select a recipe to download.", "warn");
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/agent_mining/recipes/${recipeId}/export`);
            if (!resp.ok) throw new Error(await resp.text());
            const blob = await resp.blob();
            const url = URL.createObjectURL(blob);
            const a = document.createElement("a");
            a.href = url;
            a.download = `${recipeId}.zip`;
            document.body.appendChild(a);
            a.click();
            a.remove();
            URL.revokeObjectURL(url);
            setAgentStatus("Downloaded recipe package.", "success");
        } catch (err) {
            console.error("Recipe download failed", err);
            setAgentStatus(`Download failed: ${err.message || err}`, "error");
	        }
	    }

	    async function deleteSelectedAgentRecipe() {
	        const recipeId = agentElements.recipeSelect?.value;
	        if (!recipeId) {
	            setAgentStatus("Select a recipe to delete.", "warn");
	            return;
	        }
	        const label = agentElements.recipeSelect?.selectedOptions?.[0]?.textContent || recipeId;
	        const ok = window.confirm(`Delete recipe "${label}"?\n\nThis removes it from the backend and cannot be undone.`);
	        if (!ok) return;
	        setAgentStatus("Deleting recipe…", "info");
	        try {
	            const resp = await fetch(`${API_ROOT}/agent_mining/recipes/${encodeURIComponent(recipeId)}`, { method: "DELETE" });
	            if (!resp.ok) throw new Error(await resp.text());
	            setAgentStatus(`Deleted recipe ${label}.`, "success");
	            await fetchAgentRecipes();
	        } catch (err) {
	            console.error("Recipe delete failed", err);
	            setAgentStatus(`Delete failed: ${err.message || err}`, "error");
	        }
	    }

	    async function importAgentRecipe() {
	        if (!agentElements.recipeFile || !agentElements.recipeFile.files?.length) {
	            setAgentStatus("Choose a recipe file (.zip) to import.", "warn");
	            return;
        }
        const file = agentElements.recipeFile.files[0];
        const formData = new FormData();
        formData.append("file", file);
        setAgentStatus("Importing recipe…", "info");
        try {
            const resp = await fetch(`${API_ROOT}/agent_mining/recipes/import`, {
                method: "POST",
                body: formData,
	            });
	            if (!resp.ok) throw new Error(await resp.text());
	            const data = await resp.json();
	            const importedId = data?.id;
	            setAgentStatus(`Imported recipe ${data.label || data.id}`, "success");
	            await fetchAgentRecipes();
	            if (importedId && agentElements.recipeSelect) {
	                agentElements.recipeSelect.value = importedId;
	            }
	        } catch (err) {
	            console.error("Recipe import failed", err);
	            setAgentStatus(`Import failed: ${err.message || err}`, "error");
	        } finally {
            agentElements.recipeFile.value = "";
	        }
	    }

			    function initAgentMiningUi() {
			        agentElements.datasetSelect = document.getElementById("agentDatasetSelect");
		        agentElements.datasetRefresh = document.getElementById("agentDatasetRefresh");
		        agentElements.datasetSummary = document.getElementById("agentDatasetSummary");
		        agentElements.evalImageCount = document.getElementById("agentEvalImageCount");
		        agentElements.splitSeed = document.getElementById("agentSplitSeed");
		        agentElements.reuseCache = document.getElementById("agentReuseCache");
			        agentElements.workersPerGpu = document.getElementById("agentWorkersPerGpu");
			        agentElements.maxWorkers = document.getElementById("agentMaxWorkers");
				        agentElements.searchMode = document.getElementById("agentSearchMode");
				        agentElements.stepsOptions = document.getElementById("agentStepsOptions");
				        agentElements.howItWorksDetails = document.getElementById("agentMiningHowItWorks");
				        agentElements.stepsAdvancedDetails = document.getElementById("agentStepsAdvancedDetails");
				        agentElements.stepsMaxSteps = document.getElementById("agentStepsMaxSteps");
				        agentElements.stepsMaxSeedsPerStep = document.getElementById("agentStepsMaxSeedsPerStep");
		        agentElements.stepsGlobalPreset = document.getElementById("agentStepsGlobalPreset");
		        agentElements.stepsBudgetBadge = document.getElementById("agentStepsBudgetBadge");
	        agentElements.stepsBudgetText = document.getElementById("agentStepsBudgetText");
	        agentElements.stepsBudgetFill = document.getElementById("agentStepsBudgetFill");
        agentElements.stepsEarlyStop = document.getElementById("agentStepsEarlyStop");
        agentElements.stepsEarlyStopMode = document.getElementById("agentStepsEarlyStopMode");
        agentElements.stepsPromptPrefilter = document.getElementById("agentStepsPromptPrefilter");
        agentElements.stepsPromptPrefilterMode = document.getElementById("agentStepsPromptPrefilterMode");
        agentElements.stepsPromptBgDrop = document.getElementById("agentStepsPromptBgDrop");
        agentElements.stepsPromptBgDropMode = document.getElementById("agentStepsPromptBgDropMode");
        agentElements.stepsGlobalEvalCap1 = document.getElementById("agentStepsGlobalEvalCap1");
	        agentElements.stepsGlobalEvalCap2 = document.getElementById("agentStepsGlobalEvalCap2");
	        agentElements.stepsGlobalEvalCap3 = document.getElementById("agentStepsGlobalEvalCap3");
	        agentElements.stepsGlobalMaxTrials = document.getElementById("agentStepsGlobalMaxTrials");
		        agentElements.stepsGlobalKeepRatio = document.getElementById("agentStepsGlobalKeepRatio");
		        agentElements.stepsGlobalRounds = document.getElementById("agentStepsGlobalRounds");
		        agentElements.stepsGlobalMutationsPerRound = document.getElementById("agentStepsGlobalMutationsPerRound");
		        agentElements.stepsGlobalMaxStepsMutated = document.getElementById("agentStepsGlobalMaxStepsMutated");
		        agentElements.stepsGlobalEnableOrdering = document.getElementById("agentStepsGlobalEnableOrdering");
		        agentElements.stepsGlobalEnableMaxResults = document.getElementById("agentStepsGlobalEnableMaxResults");
	        agentElements.stepsTier1Optimize = document.getElementById("agentStepsTier1Optimize");
	        agentElements.stepsTier1EvalCap = document.getElementById("agentStepsTier1EvalCap");
	        agentElements.stepsTier1MaxTrials = document.getElementById("agentStepsTier1MaxTrials");
	        agentElements.stepsTier2Optimize = document.getElementById("agentStepsTier2Optimize");
	        agentElements.stepsTier2EvalCap = document.getElementById("agentStepsTier2EvalCap");
	        agentElements.stepsTier2MaxTrials = document.getElementById("agentStepsTier2MaxTrials");
	        agentElements.stepsRefinePromptSubset = document.getElementById("agentStepsRefinePromptSubset");
	        agentElements.stepsRefineMaxIters = document.getElementById("agentStepsRefineMaxIters");
		        agentElements.stepsRefineTopK = document.getElementById("agentStepsRefineTopK");
		        agentElements.stepsSeedEvalFloor = document.getElementById("agentStepsSeedEvalFloor");
		        agentElements.stepsSeedEvalMaxResults = document.getElementById("agentStepsSeedEvalMaxResults");
		        agentElements.iouThreshold = document.getElementById("agentIouThreshold");
	        agentElements.seedThreshold = document.getElementById("agentSeedThreshold");
	        agentElements.expandThreshold = document.getElementById("agentExpandThreshold");
	        agentElements.seedDedupeIou = document.getElementById("agentSeedDedupeIou");
	        agentElements.dedupeIou = document.getElementById("agentDedupeIou");
	        agentElements.maskThreshold = document.getElementById("agentMaskThreshold");
	        agentElements.maxResults = document.getElementById("agentMaxResults");
	        agentElements.minSize = document.getElementById("agentMinSize");
	        agentElements.simplifyEps = document.getElementById("agentSimplifyEps");
	        agentElements.clipHeadSelect = document.getElementById("agentClipHeadSelect");
        agentElements.clipHeadRefresh = document.getElementById("agentClipHeadRefresh");
        agentElements.clipHeadMeta = document.getElementById("agentClipHeadMeta");
        agentElements.clipHeadAutoTune = document.getElementById("agentClipHeadAutoTune");
        agentElements.clipHeadTuneMargin = document.getElementById("agentClipHeadTuneMargin");
        agentElements.clipHeadTargetPrecision = document.getElementById("agentClipHeadTargetPrecision");
        agentElements.clipHeadTargetPrecisionValue = document.getElementById("agentClipHeadTargetPrecisionValue");
        agentElements.clipHeadAllowLowPrecision = document.getElementById("agentClipHeadAllowLowPrecision");
        agentElements.clipHeadMinProb = document.getElementById("agentClipHeadMinProb");
        agentElements.clipHeadMargin = document.getElementById("agentClipHeadMargin");
        agentElements.clipHeadBgGuard = document.getElementById("agentClipHeadBgGuard");
        agentElements.clipHeadBgMargin = document.getElementById("agentClipHeadBgMargin");
        agentElements.clipHeadBgApply = document.getElementById("agentClipHeadBgApply");
        agentElements.clipHeadBgPenalty = document.getElementById("agentClipHeadBgPenalty");
        agentElements.clipHeadBgAutoTune = document.getElementById("agentClipHeadBgAutoTune");
        agentElements.stepsHardNegExport = document.getElementById("agentStepsHardNegExport");
        agentElements.stepsHardNegMaxCrops = document.getElementById("agentStepsHardNegMaxCrops");
        agentElements.stepsHardNegMinProb = document.getElementById("agentStepsHardNegMinProb");
	        agentElements.classesInput = document.getElementById("agentClasses");
		        agentElements.extraPrompts = document.getElementById("agentExtraPrompts");
		        agentElements.extraPromptsStatus = document.getElementById("agentExtraPromptsParseStatus");
		        agentElements.qwenMaxPrompts = document.getElementById("agentQwenMaxPrompts");
		        agentElements.promptReasoning = document.getElementById("agentPromptReasoning");
		        agentElements.promptMaxTokens = document.getElementById("agentPromptMaxTokens");
	        agentElements.cacheSize = document.getElementById("agentCacheSize");
	        agentElements.purgeCacheBtn = document.getElementById("agentPurgeCacheBtn");
        agentElements.runButton = document.getElementById("agentRunBtn");
        agentElements.refreshButton = document.getElementById("agentRefreshBtn");
        agentElements.cancelButton = document.getElementById("agentCancelBtn");
	        agentElements.status = document.getElementById("agentStatus");
	        agentElements.results = document.getElementById("agentResults");
	        agentElements.recipeSelect = document.getElementById("agentRecipeSelect");
	        agentElements.recipeRefresh = document.getElementById("agentRecipeRefresh");
	        agentElements.recipeDownload = document.getElementById("agentRecipeDownload");
	        agentElements.recipeDelete = document.getElementById("agentRecipeDelete");
	        agentElements.recipeImport = document.getElementById("agentRecipeImport");
	        agentElements.recipeFile = document.getElementById("agentRecipeFile");
	        agentElements.logs = document.getElementById("agentLogs");
	        agentElements.progressFill = document.getElementById("agentProgressFill");
	        agentElements.progressText = document.getElementById("agentProgressText");
	        if (agentElements.logs) agentElements.logs.innerHTML = "";
	        if (agentElements.progressFill) agentElements.progressFill.style.width = "0%";
        if (agentElements.clipHeadSelect) agentElements.clipHeadSelect.addEventListener("change", syncAgentClipHeadControls);
        if (agentElements.clipHeadRefresh) {
            agentElements.clipHeadRefresh.addEventListener("click", () => loadAgentClipClassifiers().catch((err) => console.warn("Agent CLIP classifier refresh failed", err)));
        }
        if (agentElements.clipHeadAutoTune) agentElements.clipHeadAutoTune.addEventListener("change", syncAgentClipHeadControls);
        if (agentElements.clipHeadTuneMargin) agentElements.clipHeadTuneMargin.addEventListener("change", syncAgentClipHeadControls);
        if (agentElements.clipHeadBgAutoTune) agentElements.clipHeadBgAutoTune.addEventListener("change", syncAgentClipHeadControls);
		        if (agentElements.stepsGlobalPreset) {
		            agentElements.stepsGlobalPreset.addEventListener("change", () => {
		                applyAgentStepsGlobalPreset(agentElements.stepsGlobalPreset.value);
		                syncAgentStepsOptimizationControls();
		            });
		        }
		        const markCustomAndUpdateBudget = () => {
		            markAgentStepsGlobalPresetCustom();
		            updateAgentStepsComputeEstimate();
		        };
		        const updateBudget = () => updateAgentStepsComputeEstimate();
			        [
			            agentElements.stepsGlobalEvalCap1,
			            agentElements.stepsGlobalEvalCap2,
			            agentElements.stepsGlobalEvalCap3,
		            agentElements.stepsGlobalMaxTrials,
		            agentElements.stepsGlobalKeepRatio,
		            agentElements.stepsGlobalRounds,
			            agentElements.stepsGlobalMutationsPerRound,
			            agentElements.stepsGlobalMaxStepsMutated,
			        ].forEach((el) => {
			            if (!el) return;
			            el.addEventListener("input", markCustomAndUpdateBudget);
			        });
		        [agentElements.stepsGlobalEnableOrdering, agentElements.stepsGlobalEnableMaxResults].forEach((el) => {
		            if (!el) return;
		            el.addEventListener("change", markCustomAndUpdateBudget);
		        });
	        if (agentElements.stepsMaxSteps) agentElements.stepsMaxSteps.addEventListener("input", updateBudget);
	        if (agentElements.stepsMaxSeedsPerStep) agentElements.stepsMaxSeedsPerStep.addEventListener("input", updateBudget);
        if (agentElements.stepsEarlyStop) agentElements.stepsEarlyStop.addEventListener("change", updateBudget);
        if (agentElements.stepsEarlyStopMode) agentElements.stepsEarlyStopMode.addEventListener("change", updateBudget);
        if (agentElements.stepsPromptPrefilter) agentElements.stepsPromptPrefilter.addEventListener("change", updateBudget);
        if (agentElements.stepsPromptPrefilterMode) agentElements.stepsPromptPrefilterMode.addEventListener("change", updateBudget);
        if (agentElements.stepsPromptBgDrop) {
            agentElements.stepsPromptBgDrop.addEventListener("change", () => {
                syncAgentClipHeadControls();
                updateBudget();
            });
        }
        if (agentElements.stepsPromptBgDropMode) agentElements.stepsPromptBgDropMode.addEventListener("change", updateBudget);
        if (agentElements.stepsHardNegExport) agentElements.stepsHardNegExport.addEventListener("change", syncAgentClipHeadControls);
        if (agentElements.evalImageCount) agentElements.evalImageCount.addEventListener("input", updateBudget);
		        if (agentElements.classesInput) agentElements.classesInput.addEventListener("input", updateBudget);
		        if (agentElements.stepsTier1Optimize) agentElements.stepsTier1Optimize.addEventListener("change", syncAgentStepsOptimizationControls);
		        if (agentElements.stepsTier2Optimize) agentElements.stepsTier2Optimize.addEventListener("change", syncAgentStepsOptimizationControls);
		        if (agentElements.stepsRefinePromptSubset)
		            agentElements.stepsRefinePromptSubset.addEventListener("change", syncAgentStepsOptimizationControls);
        const syncPrecisionLabel = () => {
            if (!agentElements.clipHeadTargetPrecisionValue) return;
            const val = agentElements.clipHeadTargetPrecision ? parseFloat(agentElements.clipHeadTargetPrecision.value) : NaN;
            agentElements.clipHeadTargetPrecisionValue.textContent = Number.isFinite(val) ? val.toFixed(2) : "";
        };
        const updatePrecisionTargetRange = () => {
            if (!agentElements.clipHeadTargetPrecision) return;
            const allowLow = !!(agentElements.clipHeadAllowLowPrecision && agentElements.clipHeadAllowLowPrecision.checked);
            const min = allowLow ? 0.1 : 0.5;
            agentElements.clipHeadTargetPrecision.min = String(min);
            const current = parseFloat(agentElements.clipHeadTargetPrecision.value);
            if (Number.isFinite(current) && current < min) {
                agentElements.clipHeadTargetPrecision.value = String(min);
            }
            syncPrecisionLabel();
        };
        if (agentElements.clipHeadTargetPrecision) {
            agentElements.clipHeadTargetPrecision.addEventListener("input", syncPrecisionLabel);
        }
	        if (agentElements.clipHeadAllowLowPrecision) {
	            agentElements.clipHeadAllowLowPrecision.addEventListener("change", updatePrecisionTargetRange);
	        }
	        updatePrecisionTargetRange();
	        if (agentElements.howItWorksDetails && agentElements.howItWorksDetails.tagName === "DETAILS") {
	            const key = "tator.agentMining.howItWorksOpen";
	            let open = null;
	            try {
	                const raw = window.localStorage ? window.localStorage.getItem(key) : null;
	                if (raw === "1") open = true;
	                if (raw === "0") open = false;
	            } catch (_err) {
	                open = null;
	            }
	            if (open === null) {
	                open = false;
	            }
	            agentElements.howItWorksDetails.open = !!open;
	            agentElements.howItWorksDetails.addEventListener("toggle", () => {
	                try {
	                    if (!window.localStorage) return;
	                    window.localStorage.setItem(key, agentElements.howItWorksDetails.open ? "1" : "0");
	                } catch (_err) {
	                    // ignore
	                }
	            });
	        }
		        applyAgentStepsGlobalPreset(getAgentStepsGlobalPreset());
		        syncAgentClipHeadControls();
		        loadAgentClipClassifiers().catch((err) => console.warn("Agent CLIP classifier load failed", err));
			        const syncSearchModeUi = () => {
		            const mode = agentElements.searchMode ? agentElements.searchMode.value : "steps";
		            const isSteps = mode === "steps";
		            if (agentElements.stepsOptions) agentElements.stepsOptions.style.display = isSteps ? "block" : "none";
		            syncAgentStepsOptimizationControls();
		        };
	        if (agentElements.searchMode) agentElements.searchMode.addEventListener("change", syncSearchModeUi);
	        syncSearchModeUi();
	        stopAgentPoll();
        if (agentElements.datasetRefresh) {
            agentElements.datasetRefresh.addEventListener("click", () => loadAgentDatasets());
        }
		        if (agentElements.datasetSelect) {
		            agentElements.datasetSelect.addEventListener("change", () => {
		                updateAgentDatasetSummary();
		                updateAgentStepsComputeEstimate();
		                fetchAgentRecipes().catch((err) => console.error("Agent recipe refresh failed", err));
		                prefillExtraPrompts();
		                refreshAgentCacheSize().catch((err) => console.error("Agent cache size refresh failed", err));
		            });
		        }
        if (agentElements.purgeCacheBtn) {
            agentElements.purgeCacheBtn.addEventListener("click", () => purgeAgentCache().catch((err) => console.error("Agent cache purge failed", err)));
        }
        if (agentElements.runButton) {
            agentElements.runButton.addEventListener("click", () => startAgentMiningJob().catch((err) => console.error("Agent mining start failed", err)));
        }
        if (agentElements.refreshButton) {
            agentElements.refreshButton.addEventListener("click", () => refreshAgentLatest().catch((err) => console.error("Agent mining refresh failed", err)));
        }
        if (agentElements.cancelButton) {
            agentElements.cancelButton.addEventListener("click", () => cancelAgentJob().catch((err) => console.error("Agent mining cancel failed", err)));
        }
	        if (agentElements.recipeRefresh) {
	            agentElements.recipeRefresh.addEventListener("click", () => fetchAgentRecipes().catch((err) => console.error("Agent recipe refresh failed", err)));
	        }
	        if (agentElements.recipeDownload) {
	            agentElements.recipeDownload.addEventListener("click", () => downloadSelectedAgentRecipe().catch((err) => console.error("Agent recipe download failed", err)));
	        }
	        if (agentElements.recipeDelete) {
	            agentElements.recipeDelete.addEventListener("click", () => deleteSelectedAgentRecipe().catch((err) => console.error("Agent recipe delete failed", err)));
	        }
	        if (agentElements.recipeImport && agentElements.recipeFile) {
	            agentElements.recipeImport.addEventListener("click", () => importAgentRecipe().catch((err) => console.error("Agent recipe import failed", err)));
	        }
	        loadAgentDatasets().catch((err) => console.error("Agent dataset load failed", err));
	        fetchAgentRecipes().catch((err) => console.error("Agent recipe init failed", err));
	        prefillExtraPrompts();
	        refreshAgentCacheSize().catch((err) => console.error("Agent cache size refresh failed", err));
	    }

	    function prefillExtraPrompts() {
	        if (!agentElements.extraPrompts) return;
	        const datasetId = agentElements.datasetSelect?.value;
	        if (!datasetId) return;
	        fetch(`${API_ROOT}/sam3/datasets/${encodeURIComponent(datasetId)}/classes`)
            .then((resp) => {
                if (!resp.ok) throw new Error("Failed to load classes");
                return resp.json();
	            })
	            .then((data) => {
	                const names = Array.isArray(data?.classes) ? data.classes : [];
	                const template = {};
	                template["__base__"] = ["object", "small object"];
	                if (names.length) {
	                    names.forEach((name) => {
                        template[String(name)] = [];
                    });
	                }
	                agentElements.extraPrompts.value = JSON.stringify(template, null, 2);
	                agentElements.extraPrompts.removeAttribute("readonly");
	            })
	            .catch((err) => {
	                console.warn("Failed to prefill extra prompts", err);
	                agentElements.extraPrompts.value = "{}";
	            });
	    }

    document.addEventListener("DOMContentLoaded", () => {
        initHelpTooltips();
        autoModeCheckbox = document.getElementById("autoMode");
        autoClassMarginEnabledCheckbox = document.getElementById("autoClassMarginEnabled");
        autoClassMarginValueInput = document.getElementById("autoClassMarginValue");
        autoClassMarginWarnCheckbox = document.getElementById("autoClassMarginWarn");
        samModeCheckbox = document.getElementById("samMode");
        pointModeCheckbox = document.getElementById("pointMode");
        multiPointModeCheckbox = document.getElementById("multiPointMode");
        samVariantSelect = document.getElementById("samVariant");
        samPreloadCheckbox = document.getElementById("samPreload");
        regionDetectorSelect = document.getElementById("regionDetector");
        yoloRegionConfInput = document.getElementById("yoloRegionConf");
        yoloRegionIouInput = document.getElementById("yoloRegionIou");
        yoloRegionMaxDetInput = document.getElementById("yoloRegionMaxDet");
        detectorRunModeSelect = document.getElementById("detectorRunMode");
        detectorSliceSizeInput = document.getElementById("detectorSliceSize");
        detectorSliceOverlapInput = document.getElementById("detectorSliceOverlap");
        detectorMergeIouInput = document.getElementById("detectorMergeIou");
        detectorWindowOptions = document.getElementById("detectorWindowOptions");
        detectorRunButton = document.getElementById("detectorRunButton");
        detectorBatchCountInput = document.getElementById("detectorBatchCount");
        detectorBatchIncludeCurrentToggle = document.getElementById("detectorBatchIncludeCurrent");
        detectorBatchRunButton = document.getElementById("detectorBatchRunButton");
        detectorBatchStopButton = document.getElementById("detectorBatchStopButton");
        detectorBatchAllButton = document.getElementById("detectorBatchAllButton");
        polygonSimplifyInput = document.getElementById("polygonSimplifyEpsilon");
        polygonSimplifyField = document.getElementById("polygonSimplifyField");
        imagesSelectButton = document.getElementById("imagesSelect");
        classesSelectButton = document.getElementById("classesSelect");
        bboxesSelectButton = document.getElementById("bboxesSelect");
        bboxesFolderSelectButton = document.getElementById("bboxesSelectFolder");
        samStatusEl = document.getElementById("samStatus");
        samStatusProgressEl = document.getElementById("samStatusProgress");
        polygonDrawToggle = document.getElementById("polygonDrawToggle");
        predictorElements.countInput = document.getElementById("predictorCount");
        predictorElements.applyButton = document.getElementById("predictorApply");
        predictorElements.message = document.getElementById("predictorMessage");
        predictorElements.activeCount = document.getElementById("predictorActiveCount");
        predictorElements.loadedCount = document.getElementById("predictorLoadedCount");
        predictorElements.processRam = document.getElementById("predictorProcessRam");
        predictorElements.imageRam = document.getElementById("predictorImageRam");
        predictorElements.systemFreeRam = document.getElementById("predictorSystemFreeRam");
        initQwenPanel();
        initQwenTrainingTab();
        initQwenModelTab();
        initAgentMiningUi();

        registerFileLabel(imagesSelectButton, document.getElementById("images"));
        registerFileLabel(classesSelectButton, document.getElementById("classes"));
        registerFileLabel(bboxesFolderSelectButton, document.getElementById("bboxesFolder"));
        hideSamPreloadProgress();

        if (autoModeCheckbox) {
            autoModeCheckbox.addEventListener("change", () => {
                updateAutoModeState(autoModeCheckbox.checked);
            });
        }
        if (autoClassMarginEnabledCheckbox) {
            autoClassMarginEnabledCheckbox.addEventListener("change", syncAutoClassGuardControls);
        }

        if (samModeCheckbox) {
            samModeCheckbox.addEventListener("change", () => {
                updateSamModeState(samModeCheckbox.checked);
            });
        }

        if (pointModeCheckbox) {
            pointModeCheckbox.addEventListener("change", () => {
                updatePointModeState(pointModeCheckbox.checked);
            });
        }

        if (multiPointModeCheckbox) {
            multiPointModeCheckbox.addEventListener("change", () => {
                updateMultiPointState(multiPointModeCheckbox.checked);
            });
        }

        if (polygonDrawToggle) {
            polygonDrawToggle.addEventListener("click", () => {
                if (datasetType !== "seg") {
                    setDatasetType("seg");
                    setPolygonDrawEnabled(true, { silent: true });
                } else {
                    setPolygonDrawEnabled(!polygonDrawEnabled);
                }
            });
        }
        if (polygonSimplifyInput) {
            polygonSimplifyInput.addEventListener("input", () => {
                const val = parseFloat(polygonSimplifyInput.value);
                const msg = Number.isFinite(val)
                    ? `Polygon detail: ${val.toFixed(1)} (left = simpler, right = more detail)`
                    : "Polygon detail";
                setSamStatus(msg, { variant: "info", duration: 1500 });
            });
        }
        refreshPolygonDetailVisibility();

        syncAutoClassGuardControls();

        if (samPreloadCheckbox) {
            samPreloadCheckbox.addEventListener("change", () => {
                updateSamPreloadState(samPreloadCheckbox.checked);
            });
        }

        if (regionDetectorSelect && yoloRegionIouInput) {
            regionDetectorSelect.addEventListener("change", syncRegionDetectorInputs);
            syncRegionDetectorInputs();
        }
        if (detectorRunModeSelect) {
            detectorRunModeSelect.addEventListener("change", syncDetectorRunModeInputs);
            syncDetectorRunModeInputs();
        }
        if (detectorRunButton) {
            detectorRunButton.addEventListener("click", () => handleDetectorRun());
        }
        if (detectorBatchRunButton) {
            detectorBatchRunButton.addEventListener("click", () => startDetectorBatch({ all: false }));
        }
        if (detectorBatchStopButton) {
            detectorBatchStopButton.addEventListener("click", () => stopDetectorBatch());
        }
        if (detectorBatchAllButton) {
            detectorBatchAllButton.addEventListener("click", () => startDetectorBatch({ all: true }));
        }
        updateDetectorBatchButtons();


        if (samVariantSelect) {
            samVariant = samVariantSelect.value || "sam3";
            updateSam3TextButtons();
            samVariantSelect.addEventListener("change", () => {
                samVariant = samVariantSelect.value || "sam3";
                console.log("SAM variant =>", samVariant);
                samPreloadLastKey = null;
                if (samPreloadCurrentImageName) {
                    samPreloadCurrentVariant = samVariant;
                }
                if (samPreloadEnabled && currentImage && currentImage.object) {
                    scheduleSamPreload({ force: true, immediate: true });
                }
                updateSam3TextButtons();
                refreshSam3SimilarityVisibility();
            });
        }

        if (predictorElements.applyButton) {
            predictorElements.applyButton.addEventListener("click", handlePredictorApply);
        }
        if (predictorElements.countInput) {
            predictorElements.countInput.addEventListener("keydown", (event) => {
                if (event.key === "Enter") {
                    handlePredictorApply(event);
                }
            });
        }

        updateSamModeState(Boolean(samModeCheckbox?.checked));
        updateAutoModeState(Boolean(autoModeCheckbox?.checked));
        updatePointModeState(Boolean(pointModeCheckbox?.checked));
        updateMultiPointState(Boolean(multiPointModeCheckbox?.checked));
        updateSamPreloadState(Boolean(samPreloadCheckbox?.checked));
        setPolygonDrawEnabled(datasetType === "seg", { silent: true });
        applyDatasetModeConstraints();

        initDetectorPanel().catch((err) => console.warn("Detector panel init failed", err));
    });

    // Helper that extracts base64 from currentImage
    async function extractBase64Image() {
        const offCan = document.createElement("canvas");
        offCan.width = currentImage.width;
        offCan.height = currentImage.height;
        const ctx = offCan.getContext("2d");
        ctx.drawImage(currentImage.object, 0, 0);
        const dataUrl = offCan.toDataURL("image/jpeg");
        return dataUrl.split(",")[1];
    }

    async function extractBase64Region(region) {
        const left = Math.max(0, Math.min(currentImage.width, region.x));
        const top = Math.max(0, Math.min(currentImage.height, region.y));
        const width = Math.max(1, Math.min(currentImage.width - left, region.width));
        const height = Math.max(1, Math.min(currentImage.height - top, region.height));
        const offCan = document.createElement("canvas");
        offCan.width = Math.round(width);
        offCan.height = Math.round(height);
        const ctx = offCan.getContext("2d");
        ctx.drawImage(
            currentImage.object,
            left,
            top,
            width,
            height,
            0,
            0,
            offCan.width,
            offCan.height
        );
        const dataUrl = offCan.toDataURL("image/jpeg");
        return {
            base64: dataUrl.split(",")[1],
            region: { x: left, y: top, width, height },
        };
    }

    const getRegionDetectorMode = () => {
        return (regionDetectorSelect?.value || "yolo").toLowerCase();
    };

    const getRegionDetectConfig = () => {
        const conf = parseFloat(yoloRegionConfInput?.value);
        const iou = parseFloat(yoloRegionIouInput?.value);
        const maxDet = parseInt(yoloRegionMaxDetInput?.value, 10);
        return {
            mode: getRegionDetectorMode(),
            conf: Number.isFinite(conf) ? conf : 0.25,
            iou: Number.isFinite(iou) ? iou : 0.45,
            max_det: Number.isFinite(maxDet) ? Math.max(1, maxDet) : 100,
        };
    };

    const getClassNameById = (classId) => {
        for (const [name, idx] of Object.entries(classes)) {
            if (idx === classId) {
                return name;
            }
        }
        return null;
    };

    const getExpectedLabelmap = () => {
        if (Array.isArray(loadedClassList) && loadedClassList.length) {
            return [...loadedClassList];
        }
        return Object.entries(classes)
            .sort((a, b) => a[1] - b[1])
            .map(([name]) => name);
    };

    const summarizeRegionWarnings = (warnings, labelPrefix) => {
        const prefix = labelPrefix || "Region";
        const messages = [];
            warnings.forEach((code) => {
                switch (code) {
                    case "labelmap_mismatch":
                        messages.push(`${prefix}: labelmap mismatch (labels may be wrong).`);
                        break;
                    case "labelmap_shifted":
                        messages.push(`${prefix}: class ids shifted to fit labelmap (verify labels).`);
                        break;
                    case "labelmap_missing":
                        messages.push(`${prefix}: labelmap missing on active model.`);
                        break;
                case "conf_clamped":
                    messages.push(`${prefix}: conf clamped to [0,1].`);
                    break;
                case "iou_clamped":
                    messages.push(`${prefix}: IoU clamped to [0,1].`);
                    break;
                case "max_det_clamped":
                    messages.push(`${prefix}: max dets clamped.`);
                    break;
                case "region_crop_mismatch":
                    messages.push(`${prefix}: crop size mismatch; results may be offset.`);
                    break;
                case "full_size_missing":
                    messages.push(`${prefix}: full image size missing; results may be offset.`);
                    break;
                case "slice_size_clamped":
                    messages.push(`${prefix}: window size clamped.`);
                    break;
                case "overlap_clamped":
                    messages.push(`${prefix}: window overlap clamped.`);
                    break;
                case "merge_iou_clamped":
                    messages.push(`${prefix}: merge IoU clamped.`);
                    break;
                case "sahi_unavailable":
                    messages.push(`${prefix}: SAHI not available on backend.`);
                    break;
                case "sahi_slice_failed":
                    messages.push(`${prefix}: SAHI slicing failed.`);
                    break;
                default:
                    messages.push(`${prefix} warning: ${code}`);
                    break;
            }
        });
        return messages;
    };

    const applyRegionDetections = (detections, labelPrefix) => {
        let added = 0;
        const perClassCounts = {};
        let droppedUnmapped = 0;
        detections.forEach((det) => {
            const classId = typeof det.class_id === "number" ? det.class_id : -1;
            let className = det.class_name && typeof classes[det.class_name] !== "undefined"
                ? det.class_name
                : null;
            if (!className && classId >= 0) {
                className = getClassNameById(classId);
            }
            if (!className) {
                droppedUnmapped += 1;
                return;
            }
            const [x, y, width, height] = det.bbox || [];
            if (!Number.isFinite(x) || !Number.isFinite(y) || !Number.isFinite(width) || !Number.isFinite(height)) {
                return;
            }
            const bbox = {
                type: "bbox",
                x,
                y,
                width,
                height,
                marked: true,
                class: className,
                uuid: generateUUID(),
            };
            stampBboxCreation(bbox);
            if (!bboxes[currentImage.name]) {
                bboxes[currentImage.name] = {};
            }
            if (!bboxes[currentImage.name][className]) {
                bboxes[currentImage.name][className] = [];
            }
            bboxes[currentImage.name][className].push(bbox);
            currentBbox = {
                bbox,
                index: bboxes[currentImage.name][className].length - 1,
                originalX: bbox.x,
                originalY: bbox.y,
                originalWidth: bbox.width,
                originalHeight: bbox.height,
                moving: false,
                resizing: null,
            };
            added += 1;
            perClassCounts[className] = (perClassCounts[className] || 0) + 1;
        });
        if (added > 0) {
            updateBboxAfterTransform();
            const classSummary = Object.entries(perClassCounts)
                .sort((a, b) => b[1] - a[1])
                .slice(0, 5)
                .map(([name, count]) => `${name} ${count}`)
                .join(", ");
            const extraClasses = Object.keys(perClassCounts).length - 5;
            const suffix = extraClasses > 0 ? ` +${extraClasses} more` : "";
            enqueueTaskNotice(`${labelPrefix}: added ${added} box${added === 1 ? "" : "es"} (${classSummary}${suffix}).`, { durationMs: 5000 });
        } else {
            enqueueTaskNotice(`${labelPrefix}: no detections.`, { durationMs: 3500 });
        }
        if (droppedUnmapped > 0) {
            enqueueTaskNotice(`${labelPrefix}: skipped ${droppedUnmapped} unmapped detections.`, { durationMs: 5000 });
        }
        return { added, droppedUnmapped };
    };

    const runYoloRegionDetect = async (region) => {
        if (!currentImage) {
            setSamStatus("Load an image before running region detect.", { variant: "warn", duration: 3000 });
            enqueueTaskNotice("YOLO region: load an image first.");
            return;
        }
        if (!Object.keys(classes).length) {
            setSamStatus("Load classes before running region detect.", { variant: "warn", duration: 3000 });
            enqueueTaskNotice("YOLO region: load classes first.");
            return;
        }
        if (datasetType === "seg") {
            setSamStatus("Region detect is only available in bbox mode.", { variant: "warn", duration: 3500 });
            enqueueTaskNotice("YOLO region: bbox mode only.");
            return;
        }
        if (!region || region.width <= 1 || region.height <= 1) {
            setSamStatus("Draw a larger region to run region detect.", { variant: "warn", duration: 2500 });
            enqueueTaskNotice("YOLO region: draw a larger region.");
            return;
        }
        const { base64, region: croppedRegion } = await extractBase64Region(region);
        const { conf, iou, max_det } = getRegionDetectConfig();
        const expectedLabelmap = getExpectedLabelmap();
        const statusToken = beginSamActionStatus("Running YOLO region detect…", { variant: "info" });
        try {
            const payload = {
                image_base64: base64,
                region: [croppedRegion.x, croppedRegion.y, croppedRegion.width, croppedRegion.height],
                conf,
                iou,
                max_det,
                center_only: true,
                image_is_cropped: true,
                full_width: currentImage.width,
                full_height: currentImage.height,
                expected_labelmap: expectedLabelmap,
            };
            const resp = await fetch(`${API_ROOT}/yolo/predict_region`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) {
                const err = await resp.json().catch(() => ({}));
                const detail = err.detail || `YOLO region detect failed (${resp.status})`;
                throw new Error(detail);
            }
            const data = await resp.json();
            const detections = Array.isArray(data?.detections) ? data.detections : [];
            const warnings = Array.isArray(data?.warnings) ? data.warnings : [];
            applyRegionDetections(detections, "YOLO region");
            if (warnings.length) {
                summarizeRegionWarnings(warnings, "YOLO region").forEach((message) => {
                    enqueueTaskNotice(message, { durationMs: 5000 });
                });
            }
        } catch (err) {
            const message = String(err?.message || err || "");
            if (message.includes("yolo_active_missing")) {
                enqueueTaskNotice("YOLO region: no active model selected.");
                setSamStatus("Select an active YOLO model before running region detect.", { variant: "warn", duration: 5000 });
            } else if (message.includes("yolo_task_unknown")) {
                enqueueTaskNotice("YOLO region: model task unknown.");
                setSamStatus("Active YOLO model task could not be determined.", { variant: "error", duration: 5000 });
            } else if (message.startsWith("yolo_unavailable")) {
                enqueueTaskNotice("YOLO region: backend not ready.");
                setSamStatus("YOLO backend unavailable (Ultralytics missing).", { variant: "error", duration: 6000 });
            } else {
                enqueueTaskNotice("YOLO region: failed.");
                setSamStatus(`YOLO region detect error: ${message}`, { variant: "error", duration: 5000 });
            }
        } finally {
            endSamActionStatus(statusToken);
        }
    };

    const runRfDetrRegionDetect = async (region) => {
        if (!currentImage) {
            setSamStatus("Load an image before running region detect.", { variant: "warn", duration: 3000 });
            enqueueTaskNotice("RF-DETR region: load an image first.");
            return;
        }
        if (!Object.keys(classes).length) {
            setSamStatus("Load classes before running region detect.", { variant: "warn", duration: 3000 });
            enqueueTaskNotice("RF-DETR region: load classes first.");
            return;
        }
        if (datasetType === "seg") {
            setSamStatus("Region detect is only available in bbox mode.", { variant: "warn", duration: 3500 });
            enqueueTaskNotice("RF-DETR region: bbox mode only.");
            return;
        }
        if (!region || region.width <= 1 || region.height <= 1) {
            setSamStatus("Draw a larger region to run region detect.", { variant: "warn", duration: 2500 });
            enqueueTaskNotice("RF-DETR region: draw a larger region.");
            return;
        }
        const { base64, region: croppedRegion } = await extractBase64Region(region);
        const { conf, max_det } = getRegionDetectConfig();
        const expectedLabelmap = getExpectedLabelmap();
        const statusToken = beginSamActionStatus("Running RF-DETR region detect…", { variant: "info" });
        try {
            const payload = {
                image_base64: base64,
                region: [croppedRegion.x, croppedRegion.y, croppedRegion.width, croppedRegion.height],
                conf,
                max_det,
                center_only: true,
                image_is_cropped: true,
                full_width: currentImage.width,
                full_height: currentImage.height,
                expected_labelmap: expectedLabelmap,
            };
            const resp = await fetch(`${API_ROOT}/rfdetr/predict_region`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) {
                const err = await resp.json().catch(() => ({}));
                const detail = err.detail || `RF-DETR region detect failed (${resp.status})`;
                throw new Error(detail);
            }
            const data = await resp.json();
            const detections = Array.isArray(data?.detections) ? data.detections : [];
            const warnings = Array.isArray(data?.warnings) ? data.warnings : [];
            applyRegionDetections(detections, "RF-DETR region");
            if (warnings.length) {
                summarizeRegionWarnings(warnings, "RF-DETR region").forEach((message) => {
                    enqueueTaskNotice(message, { durationMs: 5000 });
                });
            }
        } catch (err) {
            const message = String(err?.message || err || "");
            if (message.includes("rfdetr_active_missing")) {
                enqueueTaskNotice("RF-DETR region: no active model selected.");
                setSamStatus("Select an active RF-DETR model before running region detect.", { variant: "warn", duration: 5000 });
            } else if (message.includes("rfdetr_task_unknown")) {
                enqueueTaskNotice("RF-DETR region: model task unknown.");
                setSamStatus("Active RF-DETR model task could not be determined.", { variant: "error", duration: 5000 });
            } else if (message.startsWith("rfdetr_unavailable")) {
                enqueueTaskNotice("RF-DETR region: backend not ready.");
                setSamStatus("RF-DETR backend unavailable.", { variant: "error", duration: 6000 });
            } else if (message.includes("rfdetr_region_detect_requires_bbox")) {
                enqueueTaskNotice("RF-DETR region: bbox-only model required.");
                setSamStatus("RF-DETR segmentation models are not supported for bbox region detect.", { variant: "warn", duration: 5000 });
            } else {
                enqueueTaskNotice("RF-DETR region: failed.");
                setSamStatus(`RF-DETR region detect error: ${message}`, { variant: "error", duration: 5000 });
            }
        } finally {
            endSamActionStatus(statusToken);
        }
    };

    const runRegionDetect = async (region) => {
        const mode = getRegionDetectorMode();
        if (mode === "rfdetr") {
            await runRfDetrRegionDetect(region);
        } else {
            await runYoloRegionDetect(region);
        }
    };

    const shortcutToastState = {
        lastShown: {},
        cooldownMs: 1200,
    };

    const showShortcutToast = (key, message, { durationMs = 2500, cooldownMs = null } = {}) => {
        const now = Date.now();
        const last = shortcutToastState.lastShown[key] || 0;
        const windowMs = Number.isFinite(cooldownMs) ? cooldownMs : shortcutToastState.cooldownMs;
        if (now - last < windowMs) {
            return;
        }
        shortcutToastState.lastShown[key] = now;
        enqueueTaskNotice(message, { durationMs });
    };

    const getDetectorRunMode = () => {
        return (detectorRunModeSelect?.value || "full").toLowerCase();
    };

    const getDetectorWindowConfig = () => {
        const sliceSize = parseInt(detectorSliceSizeInput?.value, 10);
        const overlap = parseFloat(detectorSliceOverlapInput?.value);
        const mergeIou = parseFloat(detectorMergeIouInput?.value);
        return {
            slice_size: Number.isFinite(sliceSize) ? sliceSize : 640,
            overlap: Number.isFinite(overlap) ? overlap : 0.2,
            merge_iou: Number.isFinite(mergeIou) ? mergeIou : 0.5,
        };
    };

    function getDetectorImageList() {
        const imageList = document.getElementById("imageList");
        if (!imageList) {
            return [];
        }
        return Array.from(imageList.options || []).map((opt) => getOptionImageName(opt)).filter(Boolean);
    }

    function getDetectorBatchSelection({ all = false } = {}) {
        const imageList = document.getElementById("imageList");
        if (!imageList || !imageList.options.length) {
            return null;
        }
        const includeCurrent = !!detectorBatchIncludeCurrentToggle?.checked;
        if (all) {
            const names = getDetectorImageList();
            const filtered = includeCurrent
                ? names
                : names.filter((name) => !currentImage || name !== currentImage.name);
            return filtered.length ? { names: filtered, includeCurrent } : null;
        }
        const countRaw = parseInt(detectorBatchCountInput?.value || "1", 10);
        const count = Number.isFinite(countRaw) ? Math.max(1, Math.min(999, countRaw)) : 1;
        const startIndex = Math.max(0, imageList.selectedIndex || 0);
        const names = [];
        for (let i = 0; i < count; i += 1) {
            const idx = includeCurrent ? startIndex + i : startIndex + i + 1;
            if (idx >= imageList.options.length) {
                break;
            }
            const name = getOptionImageName(imageList.options[idx]);
            if (name) {
                names.push(name);
            }
        }
        return names.length ? { names, includeCurrent } : null;
    }

    function updateDetectorBatchButtons() {
        if (detectorRunButton) {
            detectorRunButton.disabled = detectorBatchActive;
        }
        if (detectorBatchRunButton) {
            detectorBatchRunButton.disabled = detectorBatchActive;
        }
        if (detectorBatchAllButton) {
            detectorBatchAllButton.disabled = detectorBatchActive;
        }
        if (detectorBatchStopButton) {
            detectorBatchStopButton.disabled = !detectorBatchActive;
        }
        if (detectorBatchCountInput) {
            detectorBatchCountInput.disabled = detectorBatchActive;
        }
        if (detectorBatchIncludeCurrentToggle) {
            detectorBatchIncludeCurrentToggle.disabled = detectorBatchActive;
        }
    }

    async function runDetectorForCurrentImage({ modeOverride = null } = {}) {
        if (!currentImage) {
            setSamStatus("Load an image before running detection.", { variant: "warn", duration: 3000 });
            enqueueTaskNotice("Detector: load an image first.");
            return { added: 0 };
        }
        if (!Object.keys(classes).length) {
            setSamStatus("Load classes before running detection.", { variant: "warn", duration: 3000 });
            enqueueTaskNotice("Detector: load classes first.");
            return { added: 0 };
        }
        if (datasetType === "seg") {
            setSamStatus("Detector runs are only available in bbox mode.", { variant: "warn", duration: 3500 });
            enqueueTaskNotice("Detector: bbox mode only.");
            return { added: 0 };
        }
        const mode = (modeOverride || getDetectorRunMode()).toLowerCase();
        const detectorMode = getRegionDetectorMode();
        const base64 = await extractBase64Image();
        const { conf, iou, max_det } = getRegionDetectConfig();
        const windowConfig = getDetectorWindowConfig();
        const expectedLabelmap = getExpectedLabelmap();
        const detectorLabel = detectorMode === "rfdetr" ? "RF-DETR" : "YOLO";
        const labelPrefix = mode === "windowed" ? `${detectorLabel} windowed` : `${detectorLabel} full`;
        const statusToken = beginSamActionStatus(`Running ${labelPrefix} detect…`, { variant: "info" });
        try {
            let endpoint = "";
            const payload = {
                image_base64: base64,
                conf,
                max_det,
                expected_labelmap: expectedLabelmap,
            };
            if (detectorMode === "yolo") {
                payload.iou = iou;
                endpoint = mode === "windowed" ? `${API_ROOT}/yolo/predict_windowed` : `${API_ROOT}/yolo/predict_full`;
            } else {
                endpoint = mode === "windowed" ? `${API_ROOT}/rfdetr/predict_windowed` : `${API_ROOT}/rfdetr/predict_full`;
            }
            if (mode === "windowed") {
                Object.assign(payload, windowConfig);
            }
            const resp = await fetch(endpoint, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) {
                const err = await resp.json().catch(() => ({}));
                const detail = err.detail || `${labelPrefix} detect failed (${resp.status})`;
                throw new Error(detail);
            }
            const data = await resp.json();
            const detections = Array.isArray(data?.detections) ? data.detections : [];
            const warnings = Array.isArray(data?.warnings) ? data.warnings : [];
            const { added } = applyRegionDetections(detections, labelPrefix);
            if (warnings.length) {
                summarizeRegionWarnings(warnings, labelPrefix).forEach((message) => {
                    enqueueTaskNotice(message, { durationMs: 5000 });
                });
            }
            return { added };
        } catch (err) {
            const message = String(err?.message || err || "");
            if (message.includes("yolo_active_missing") || message.includes("rfdetr_active_missing")) {
                enqueueTaskNotice(`${labelPrefix}: no active model selected.`);
                setSamStatus(`Select an active ${detectorLabel} model before running detection.`, { variant: "warn", duration: 5000 });
            } else if (message.includes("task_unknown")) {
                enqueueTaskNotice(`${labelPrefix}: model task unknown.`);
                setSamStatus(`Active ${detectorLabel} model task could not be determined.`, { variant: "error", duration: 5000 });
            } else if (message.startsWith("yolo_unavailable") || message.startsWith("rfdetr_unavailable")) {
                enqueueTaskNotice(`${labelPrefix}: backend not allowed.`);
                setSamStatus(`${detectorLabel} backend unavailable.`, { variant: "error", duration: 6000 });
            } else if (message.includes("requires_bbox")) {
                enqueueTaskNotice(`${labelPrefix}: bbox-only model required.`);
                setSamStatus(`${detectorLabel} segmentation models are not supported for bbox detect.`, { variant: "warn", duration: 5000 });
            } else if (message.startsWith("sahi_unavailable")) {
                enqueueTaskNotice(`${labelPrefix}: SAHI missing.`);
                setSamStatus("SAHI is not available on the backend.", { variant: "error", duration: 5000 });
            } else {
                enqueueTaskNotice(`${labelPrefix}: failed.`);
                setSamStatus(`${labelPrefix} detect error: ${message}`, { variant: "error", duration: 5000 });
            }
            return { added: 0 };
        } finally {
            endSamActionStatus(statusToken);
        }
    }

    async function handleDetectorRun() {
        if (detectorBatchActive) {
            setSamStatus("Detector batch running; wait for it to finish.", { variant: "warn", duration: 3000 });
            return;
        }
        await runDetectorForCurrentImage();
    }

    async function startDetectorBatch({ all = false } = {}) {
        if (detectorBatchActive) {
            return;
        }
        if (!currentImage || !currentImage.name) {
            setSamStatus("Load an image before starting detector batch.", { variant: "warn", duration: 3000 });
            return;
        }
        const batchConfig = getDetectorBatchSelection({ all });
        if (!batchConfig) {
            setSamStatus("No images found for detector batch.", { variant: "warn", duration: 3000 });
            return;
        }
        if (all) {
            const ok = window.confirm(`Run detector on all ${batchConfig.names.length} images? This can take a while.`);
            if (!ok) {
                return;
            }
        }
        if (sam3TextBatchActive || sam3TextCascadeActive || sam3TextRequestActive || sam3SimilarityRequestActive) {
            setSamStatus("SAM3 is busy; wait for it to finish.", { variant: "warn", duration: 3000 });
            return;
        }
        detectorBatchActive = true;
        detectorBatchCancel = false;
        updateDetectorBatchButtons();
        const { names } = batchConfig;
        const originalName = currentImage.name;
        const batchTaskId = enqueueTask({ kind: "detector-batch", imageName: originalName, detail: { count: names.length } });
        let totalAdded = 0;
        try {
            for (let idx = 0; idx < names.length; idx += 1) {
                if (detectorBatchCancel) {
                    break;
                }
                const name = names[idx];
                setSamStatus(`Detector batch ${idx + 1}/${names.length}: ${name}`, { variant: "info", duration: 0 });
                const record = images[name];
                if (!record) {
                    continue;
                }
                await ensureImageRecordReady(record);
                if (!currentImage || currentImage.name !== name) {
                    setCurrentImage(record);
                }
                const ready = await waitForCurrentImageReady(name);
                if (!ready) {
                    setSamStatus(`Detector batch ${idx + 1}/${names.length}: failed to load ${name}`, { variant: "warn", duration: 3000 });
                    continue;
                }
                const result = await runDetectorForCurrentImage();
                totalAdded += Number(result?.added || 0);
            }
        } finally {
            detectorBatchActive = false;
            updateDetectorBatchButtons();
            completeTask(batchTaskId);
            if (originalName && images[originalName] && (!currentImage || currentImage.name !== originalName)) {
                setCurrentImage(images[originalName]);
            }
            const doneMessage = detectorBatchCancel
                ? "Detector batch cancelled."
                : `Detector batch complete: added ${totalAdded} box${totalAdded === 1 ? "" : "es"}.`;
            setSamStatus(doneMessage, { variant: detectorBatchCancel ? "warn" : "success", duration: 3500 });
            enqueueTaskNotice(doneMessage, { durationMs: 5000 });
        }
    }

    function stopDetectorBatch() {
        if (!detectorBatchActive) {
            return;
        }
        detectorBatchCancel = true;
        setSamStatus("Stopping detector batch after current image…", { variant: "warn", duration: 3000 });
    }

    async function buildSamImagePayload({ forceBase64 = false, variantOverride = null, preferredToken = null } = {}) {
        const token = preferredToken ?? getCurrentSamToken(variantOverride);
        if (token && !forceBase64) {
            return { image_token: token };
        }
        const base64Img = await extractBase64Image();
        const payload = { image_base64: base64Img };
        if (token) {
            payload.image_token = token;
        }
        return payload;
    }

    async function postSamEndpoint(url, fields, { signal } = {}) {
        const imageNameForRequest = currentImage ? currentImage.name : null;
        const variantForRequest = samVariant;
        const preloadToken = await waitForSamPreloadIfActive(imageNameForRequest, variantForRequest);
        let payload = await buildSamImagePayload({ variantOverride: variantForRequest, preferredToken: preloadToken });
        if (samSlotsEnabled && imageNameForRequest && !payload.image_name) {
            payload.image_name = imageNameForRequest;
        }
        let resp = await fetch(url, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({ ...fields, ...payload }),
            signal,
        });
        if (resp.status === 428) {
            payload = await buildSamImagePayload({ forceBase64: true, variantOverride: variantForRequest, preferredToken: preloadToken });
            resp = await fetch(url, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify({ ...fields, ...payload }),
                signal,
            });
        }
        return resp;
    }

    function applySamResultToSegDataset(result, targetBbox, classNameOverride = null) {
        if (!currentImage) return false;
        const className = classNameOverride || (targetBbox ? targetBbox.class : currentClass);
        if (!className) return false;
        const epsVal = Number.isFinite(Number(result?.simplify_epsilon)) && Number(result.simplify_epsilon) >= 0
            ? Number(result.simplify_epsilon)
            : null;
        let created = null;
        if (result?.mask) {
            created = addPolygonFromMask(result.mask, className, { simplifyEpsilon: epsVal });
        }
        if (!created && result?.bbox) {
            created = addPolygonFromYoloRect(result.bbox, className);
        }
        if (!created) {
            return false;
        }
        const bucket = bboxes[currentImage.name]?.[className] || [];
        const idx = bucket.indexOf(created);
        currentBbox = {
            bbox: created,
            index: idx >= 0 ? idx : bucket.length - 1,
            originalX: created.x,
            originalY: created.y,
            originalWidth: created.width,
            originalHeight: created.height,
            moving: false,
            resizing: null,
        };
        return true;
    }

    /*****************************************************
     * Existing SAM / CLIP calls
     *****************************************************/
    async function samBboxPrompt(bbox) {
        const statusToken = beginSamActionStatus("Running SAM box prompt…");
        const imageName = currentImage ? currentImage.name : null;
        const placeholderContext = bbox ? { uuid: bbox.uuid, imageName } : null;
        const jobHandle = registerSamJob({
            type: "sam-bbox",
            imageName,
            cleanup: () => {
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
            },
        });
        try {
            const bodyFields = {
                bbox_left: bbox.x,
                bbox_top: bbox.y,
                bbox_width: bbox.width,
                bbox_height: bbox.height,
                uuid: bbox.uuid,
                sam_variant: samVariant,
            };
            let resp = await postSamEndpoint(`${API_ROOT}/sam_bbox`, bodyFields);
            if (!resp.ok) {
                throw new Error("Response not OK: " + resp.statusText);
            }
            const result = await resp.json();
            if (!isSamJobActive(jobHandle)) {
                return;
            }
            if (result.image_token && currentImage) {
                rememberSamToken(currentImage.name, samVariant, result.image_token);
            }
            const returnedUUID = result.uuid;
            const targetBbox = pendingApiBboxes[returnedUUID];
            if (!targetBbox) {
                console.warn("No pending bbox found for uuid:", returnedUUID);
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                return;
            }
            if (datasetType === "seg") {
                const applied = applySamResultToSegDataset(result, targetBbox, targetBbox?.class);
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                delete pendingApiBboxes[returnedUUID];
                if (!applied) {
                    setSamStatus("SAM returned no mask/bbox to apply.", { variant: "warn", duration: 3000 });
                }
                return;
            }
            if (datasetType === "seg") {
                const applied = applySamResultToSegDataset(result, targetBbox, targetBbox?.class);
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                delete pendingApiBboxes[returnedUUID];
                if (!applied) {
                    setSamStatus("SAM returned no mask/bbox to apply.", { variant: "warn", duration: 3000 });
                }
                return;
            }
            currentBbox = {
                bbox: targetBbox,
                index: -1,
                originalX: targetBbox.x,
                originalY: targetBbox.y,
                originalWidth: targetBbox.width,
                originalHeight: targetBbox.height,
                moving: false,
                resizing: null
            };

            if (result.bbox) {
                const [cx, cy, ww, hh] = result.bbox;
                const absW = ww * currentImage.width;
                const absH = hh * currentImage.height;
                const absX = cx * currentImage.width - absW / 2;
                const absY = cy * currentImage.height - absH / 2;
                targetBbox.x = absX;
                targetBbox.y = absY;
                targetBbox.width = absW;
                targetBbox.height = absH;
                updateBboxAfterTransform();
                console.log("Updated SAM bounding box:", absX, absY, absW, absH);
            } else {
                console.warn("No 'bbox' field returned from sam_bbox. Full response:", result);
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                return;
            }
            delete pendingApiBboxes[returnedUUID];
        } catch (err) {
            console.error("sam_bbox error:", err);
            alert("sam_bbox call failed: " + err);
            if (placeholderContext) {
                removePendingBbox(placeholderContext);
            }
        } finally {
            completeSamJob(jobHandle.id);
            endSamActionStatus(statusToken);
        }
    }

    async function samPointPrompt(px, py) {
        const statusToken = beginSamActionStatus("Running SAM point prompt…");
        const imageName = currentImage ? currentImage.name : null;
        const placeholderContext = currentBbox && currentBbox.bbox ? { uuid: currentBbox.bbox.uuid, imageName } : null;
        const jobHandle = registerSamJob({
            type: "sam-point",
            imageName,
            cleanup: () => {
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
            },
        });
        try {
            const bodyFields = {
                point_x: px,
                point_y: py,
                uuid: currentBbox ? currentBbox.bbox.uuid : null,
                sam_variant: samVariant,
            };
            let resp = await postSamEndpoint(`${API_ROOT}/sam_point`, bodyFields);
            if (!resp.ok) {
                throw new Error("sam_point failed: " + resp.statusText);
            }
            const result = await resp.json();
            if (!isSamJobActive(jobHandle)) {
                return;
            }
            if (result.image_token && currentImage) {
                rememberSamToken(currentImage.name, samVariant, result.image_token);
            }
            const returnedUUID = result.uuid;
            const targetBbox = pendingApiBboxes[returnedUUID];
            if (!targetBbox) {
                console.warn("No pending bbox found for uuid:", returnedUUID);
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                return;
            }
            if (datasetType === "seg") {
                const applied = applySamResultToSegDataset(result, targetBbox, targetBbox?.class);
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                delete pendingApiBboxes[returnedUUID];
                if (!applied) {
                    setSamStatus("SAM auto bbox returned no mask/bbox to apply.", { variant: "warn", duration: 3000 });
                }
                return;
            }
            currentBbox = {
                bbox: targetBbox,
                index: -1,
                originalX: targetBbox.x,
                originalY: targetBbox.y,
                originalWidth: targetBbox.width,
                originalHeight: targetBbox.height,
                moving: false,
                resizing: null
            };

            if (!result.bbox) {
                console.warn("No 'bbox' field in sam_point response:", result);
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                return;
            }
            const [cx, cy, wNorm, hNorm] = result.bbox;
            const absW = wNorm * currentImage.width;
            const absH = hNorm * currentImage.height;
            const absX = cx * currentImage.width - absW / 2;
            const absY = cy * currentImage.height - absH / 2;
            targetBbox.x = absX;
            targetBbox.y = absY;
            targetBbox.width = absW;
            targetBbox.height = absH;
            updateBboxAfterTransform();
            console.log("Updated existing bbox from point mode:", absX, absY, absW, absH);
            delete pendingApiBboxes[returnedUUID];
        } catch (err) {
            console.error("samPointPrompt error:", err);
            alert("samPointPrompt call failed: " + err);
            if (placeholderContext) {
                removePendingBbox(placeholderContext);
            }
        } finally {
            completeSamJob(jobHandle.id);
            endSamActionStatus(statusToken);
        }
    }

    function resolveClipAutoPrediction(result) {
        const prediction = String(result?.prediction || "").trim();
        const err = String(result?.error || "");
        const proba = typeof result?.proba === "number" ? result.proba : parseFloat(result?.proba);
        const secondLabel = String(result?.second_label || result?.secondLabel || "").trim();
        const secondProba = typeof result?.second_proba === "number"
            ? result.second_proba
            : parseFloat(result?.second_proba || result?.secondProba);
        if (err === "clip_background") {
            enqueueTaskNotice("CLIP auto class negative (background).");
            return null;
        }
        if (!prediction || prediction === "unknown") {
            return null;
        }
        const guard = getClipAutoGuardConfig();
        if (guard.enabled && Number.isFinite(proba) && Number.isFinite(secondProba) && secondLabel) {
            const margin = proba - secondProba;
            if (margin < guard.minMargin) {
                if (guard.warnAmbiguous) {
                    enqueueTaskNotice(`CLIP class unclear between "${prediction}" and "${secondLabel}".`);
                }
                return null;
            }
        }
        return prediction;
    }

    async function autoPredictNewCrop(bbox) {
        const progressToken = beginClipProgress();
        const clipTaskId = enqueueTask({ kind: "clip-auto", imageName: currentImage ? currentImage.name : null, detail: bbox?.class || currentClass || null });
        try {
            const offCanvas = document.createElement("canvas");
            offCanvas.width = bbox.width;
            offCanvas.height = bbox.height;
            const ctx = offCanvas.getContext("2d");
            ctx.drawImage(
                currentImage.object,
                bbox.x,
                bbox.y,
                bbox.width,
                bbox.height,
                0,
                0,
                bbox.width,
                bbox.height
            );
        const base64String = offCanvas.toDataURL("image/jpeg");
        const base64Data = base64String.split(",")[1];
        const resp = await fetch(`${API_ROOT}/predict_base64`, {
            method: "POST",
            headers: { "Content-Type": "application/json" },
            body: JSON.stringify({
                image_base64: base64Data,
                uuid: bbox.uuid
                })
            });
            const data = await resp.json();
            console.log("autoPredictNewCrop =>", data);
            if (!data.uuid) {
                alert("Auto mode error: you probably don't have a trained .pkl file for CLIP!");
                removeBbox(bbox);
                return;
            }
            const predictedClass = resolveClipAutoPrediction(data);
            const returnedUUID = data.uuid;
            const targetBbox = pendingApiBboxes[returnedUUID];
            if (!targetBbox) {
            console.warn("No pending bbox found for uuid:", returnedUUID);
            return;
        }
            currentBbox = {
                bbox: targetBbox,
                index: -1,
                originalX: targetBbox.x,
                originalY: targetBbox.y,
                originalWidth: targetBbox.width,
                originalHeight: targetBbox.height,
                moving: false,
                resizing: null
            };
            const oldClass = targetBbox.class;
            const oldArr = bboxes[currentImage.name][oldClass];
            const idx = oldArr.indexOf(targetBbox);
            if (idx !== -1) oldArr.splice(idx, 1);
            if (!predictedClass || typeof classes[predictedClass] === "undefined") {
                console.warn("AutoPredict returned unknown class:", predictedClass);
                if (!bboxes[currentImage.name][oldClass]) {
                    bboxes[currentImage.name][oldClass] = [];
                }
                targetBbox.class = oldClass;
                bboxes[currentImage.name][oldClass].push(targetBbox);
            } else {
                if (!bboxes[currentImage.name][predictedClass]) {
                    bboxes[currentImage.name][predictedClass] = [];
                }
                targetBbox.class = predictedClass;
                bboxes[currentImage.name][predictedClass].push(targetBbox);
            }
            delete pendingApiBboxes[returnedUUID];
        } finally {
            completeTask(clipTaskId);
            endClipProgress(progressToken);
        }
    }

    async function samBboxAutoPrompt(bbox) {
        if (datasetType === "seg") {
            setSamStatus("Auto bbox prompt is disabled in polygon mode.", { variant: "warn", duration: 4000 });
            return;
        }
        const statusToken = beginSamActionStatus("Running SAM auto box…");
        const imageName = currentImage ? currentImage.name : null;
        const placeholderContext = bbox ? { uuid: bbox.uuid, imageName } : null;
        const jobHandle = registerSamJob({
            type: "sam-bbox-auto",
            imageName,
            cleanup: () => {
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
            },
        });
        try {
            const useFallback = document.getElementById("useFallbackDilate")?.checked;
            const minProbaEl = document.getElementById("minProba");
            const dilateRatioEl = document.getElementById("dilateRatio");
            const bodyData = {
                bbox_left: bbox.x,
                bbox_top: bbox.y,
                bbox_width: bbox.width,
                bbox_height: bbox.height,
                uuid: bbox.uuid,
                sam_variant: samVariant,
            };
            if (useFallback) {
                bodyData.clip_crop_policy = "dilate_on_low_conf";
                if (minProbaEl && !isNaN(parseFloat(minProbaEl.value))) bodyData.fallback_min_proba = parseFloat(minProbaEl.value);
                if (dilateRatioEl && !isNaN(parseFloat(dilateRatioEl.value))) bodyData.fallback_dilate_ratio = parseFloat(dilateRatioEl.value);
            }
            let resp = await postSamEndpoint(`${API_ROOT}/sam_bbox_auto`, bodyData);
            if (!resp.ok) {
                throw new Error("sam_bbox_auto failed: " + resp.statusText);
            }
            const result = await resp.json();
            console.log("sam_bbox_auto =>", result);
            if (!isSamJobActive(jobHandle)) {
                return;
            }
            if (result.image_token && currentImage) {
                rememberSamToken(currentImage.name, samVariant, result.image_token);
            }
            if (!result.uuid || !result.bbox || result.bbox.length < 4) {
                alert("Auto mode error: missing 'uuid' or invalid 'bbox' in /sam_bbox_auto response.");
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                return;
            }
            const returnedUUID = result.uuid;
            const targetBbox = pendingApiBboxes[returnedUUID];
            if (!targetBbox) {
                console.warn("No pending bbox found for uuid:", returnedUUID);
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                return;
            }
            currentBbox = {
                bbox: targetBbox,
                index: -1,
                originalX: targetBbox.x,
                originalY: targetBbox.y,
                originalWidth: targetBbox.width,
                originalHeight: targetBbox.height,
                moving: false,
                resizing: null
            };
        const [cx, cy, wNorm, hNorm] = result.bbox;
        const absW = wNorm * currentImage.width;
        const absH = hNorm * currentImage.height;
        const absX = cx * currentImage.width - absW / 2;
        const absY = cy * currentImage.height - absH / 2;
        const oldClass = targetBbox.class;
        const oldArr = bboxes[currentImage.name][oldClass];
        const idx = oldArr.indexOf(targetBbox);
        if (idx !== -1) oldArr.splice(idx, 1);
        // If prediction present, move bbox to predicted class; else keep current class
        const resolvedPrediction = resolveClipAutoPrediction(result);
        if (resolvedPrediction) {
            const newClass = resolvedPrediction;
            if (typeof classes[newClass] === "undefined") {
                console.warn("SAM bbox auto predicted unknown class:", newClass);
                if (!bboxes[currentImage.name][oldClass]) {
                    bboxes[currentImage.name][oldClass] = [];
                }
                targetBbox.class = oldClass;
                bboxes[currentImage.name][oldClass].push(targetBbox);
            } else {
                if (!bboxes[currentImage.name][newClass]) {
                    bboxes[currentImage.name][newClass] = [];
                }
                targetBbox.class = newClass;
                bboxes[currentImage.name][newClass].push(targetBbox);
            }
        } else {
            // Keep original class
            if (!bboxes[currentImage.name][oldClass]) {
                bboxes[currentImage.name][oldClass] = [];
            }
            bboxes[currentImage.name][oldClass].push(targetBbox);
        }
        targetBbox.x = absX;
        targetBbox.y = absY;
        targetBbox.width = absW;
        targetBbox.height = absH;
        updateBboxAfterTransform();
        delete pendingApiBboxes[returnedUUID];
        } catch (err) {
            console.error("sam_bbox_auto error:", err);
            alert("sam_bbox_auto call failed: " + err);
            if (placeholderContext) {
                removePendingBbox(placeholderContext);
            }
        } finally {
            completeSamJob(jobHandle.id);
            endSamActionStatus(statusToken);
        }
    }

    async function samPointAutoPrompt(px, py) {
        const statusToken = beginSamActionStatus("Running SAM point+CLIP…");
        const imageName = currentImage ? currentImage.name : null;
        const placeholderContext = currentBbox && currentBbox.bbox ? { uuid: currentBbox.bbox.uuid, imageName } : null;
        const jobHandle = registerSamJob({
            type: "sam-point-auto",
            imageName,
            cleanup: () => {
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
            },
        });
        try {
            const useFallback = document.getElementById("useFallbackDilate")?.checked;
            const minProbaEl = document.getElementById("minProba");
            const dilateRatioEl = document.getElementById("dilateRatio");
            const bodyData = {
                point_x: px,
                point_y: py,
                uuid: currentBbox ? currentBbox.bbox.uuid : null,
                sam_variant: samVariant,
            };
            if (useFallback) {
                bodyData.clip_crop_policy = "dilate_on_low_conf";
                if (minProbaEl && !isNaN(parseFloat(minProbaEl.value))) bodyData.fallback_min_proba = parseFloat(minProbaEl.value);
                if (dilateRatioEl && !isNaN(parseFloat(dilateRatioEl.value))) bodyData.fallback_dilate_ratio = parseFloat(dilateRatioEl.value);
            }
            let resp = await postSamEndpoint(`${API_ROOT}/sam_point_auto`, bodyData);
            if (!resp.ok) {
                throw new Error("sam_point_auto failed: " + resp.statusText);
            }
            const result = await resp.json();
            console.log("sam_point_auto =>", result);
            if (!isSamJobActive(jobHandle)) {
                return;
            }
            if (result.image_token && currentImage) {
                rememberSamToken(currentImage.name, samVariant, result.image_token);
            }
            if (!result.uuid || !result.bbox || result.bbox.length < 4) {
                alert("Auto mode error: missing 'uuid' or invalid 'bbox' in /sam_point_auto response.");
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                return;
            }
            const returnedUUID = result.uuid;
            const targetBbox = pendingApiBboxes[returnedUUID];
            if (!targetBbox) {
                console.warn("No pending bbox found for uuid:", returnedUUID);
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                return;
            }
            currentBbox = {
                bbox: targetBbox,
                index: -1,
                originalX: targetBbox.x,
                originalY: targetBbox.y,
                originalWidth: targetBbox.width,
                originalHeight: targetBbox.height,
                moving: false,
                resizing: null
            };
        const [cx, cy, wNorm, hNorm] = result.bbox;
        const absW = wNorm * currentImage.width;
        const absH = hNorm * currentImage.height;
        const absX = cx * currentImage.width - absW / 2;
        const absY = cy * currentImage.height - absH / 2;
        const oldClass = targetBbox.class;
        const oldArr = bboxes[currentImage.name][oldClass];
        const idx = oldArr.indexOf(targetBbox);
        if (idx !== -1) oldArr.splice(idx, 1);
        const resolvedPrediction = resolveClipAutoPrediction(result);
        if (resolvedPrediction) {
            const newClass = resolvedPrediction;
            if (typeof classes[newClass] === "undefined") {
                console.warn("SAM point auto predicted unknown class:", newClass);
                if (!bboxes[currentImage.name][oldClass]) {
                    bboxes[currentImage.name][oldClass] = [];
                }
                targetBbox.class = oldClass;
                bboxes[currentImage.name][oldClass].push(targetBbox);
            } else {
                if (!bboxes[currentImage.name][newClass]) {
                    bboxes[currentImage.name][newClass] = [];
                }
                targetBbox.class = newClass;
                bboxes[currentImage.name][newClass].push(targetBbox);
            }
        } else {
            if (!bboxes[currentImage.name][oldClass]) {
                bboxes[currentImage.name][oldClass] = [];
            }
            bboxes[currentImage.name][oldClass].push(targetBbox);
        }
        targetBbox.x = absX;
        targetBbox.y = absY;
        targetBbox.width = absW;
        targetBbox.height = absH;
        updateBboxAfterTransform();
        delete pendingApiBboxes[returnedUUID];
        } catch (err) {
            console.error("sam_point_auto error:", err);
            alert("sam_point_auto call failed: " + err);
            if (placeholderContext) {
                removePendingBbox(placeholderContext);
            }
        } finally {
            completeSamJob(jobHandle.id);
            endSamActionStatus(statusToken);
        }
    }

    async function samPointMultiPrompt(job, jobHandle) {
        const { positivePoints, negativePoints, requestToken, placeholderContext } = job;
        const statusToken = beginSamActionStatus("Running SAM multi-point…");
        let success = false;
        try {
            const bodyData = {
                positive_points: positivePoints,
                negative_points: negativePoints,
                uuid: placeholderContext ? placeholderContext.uuid : null,
                sam_variant: samVariant,
            };
            const resp = await postSamEndpoint(`${API_ROOT}/sam_point_multi`, bodyData);
            if (!resp.ok) {
                throw new Error("sam_point_multi failed: " + resp.statusText);
            }
            const result = await resp.json();
            if (!isSamJobActive(jobHandle)) {
                return;
            }
            if (requestToken && multiPointPendingToken !== requestToken) {
                return;
            }
            if (result.image_token && currentImage) {
                rememberSamToken(currentImage.name, samVariant, result.image_token);
            }
            const returnedUUID = result.uuid;
            const targetBbox = pendingApiBboxes[returnedUUID];
            if (!targetBbox) {
                console.warn("No pending bbox found for uuid:", returnedUUID);
                removePendingBbox(placeholderContext);
                return;
            }
            if (datasetType === "seg") {
                const applied = applySamResultToSegDataset(result, targetBbox, targetBbox?.class);
                if (placeholderContext) {
                    removePendingBbox(placeholderContext);
                }
                delete pendingApiBboxes[returnedUUID];
                if (!applied) {
                    setSamStatus("SAM multi-point returned no mask/bbox to apply.", { variant: "warn", duration: 3000 });
                }
                return;
            }
            currentBbox = {
                bbox: targetBbox,
                index: -1,
                originalX: targetBbox.x,
                originalY: targetBbox.y,
                originalWidth: targetBbox.width,
                originalHeight: targetBbox.height,
                moving: false,
                resizing: null,
            };
            if (!result.bbox || result.bbox.length < 4) {
                console.warn("No 'bbox' field in sam_point_multi response:", result);
                removePendingBbox(placeholderContext);
                return;
            }
            const [cx, cy, wNorm, hNorm] = result.bbox;
            const absW = wNorm * currentImage.width;
            const absH = hNorm * currentImage.height;
            const absX = cx * currentImage.width - absW / 2;
            const absY = cy * currentImage.height - absH / 2;
            targetBbox.x = absX;
            targetBbox.y = absY;
            targetBbox.width = absW;
            targetBbox.height = absH;
            updateBboxAfterTransform();
            delete pendingApiBboxes[returnedUUID];
            success = true;
            if (multiPointPendingBboxInfo && returnedUUID === multiPointPendingBboxInfo.uuid) {
                multiPointPendingBboxInfo = null;
            }
        } catch (err) {
            console.error("sam_point_multi error:", err);
            alert("sam_point_multi call failed: " + err);
            removePendingBbox(placeholderContext);
        } finally {
            endSamActionStatus(statusToken);
            if (!success && placeholderContext) {
                if (multiPointPendingBboxInfo && multiPointPendingBboxInfo.uuid === placeholderContext.uuid && multiPointPendingBboxInfo.imageName === placeholderContext.imageName) {
                    multiPointPendingBboxInfo = null;
                }
            }
        }
    }

    async function samPointMultiAutoPrompt(job, jobHandle) {
        const { positivePoints, negativePoints, requestToken, placeholderContext } = job;
        const statusToken = beginSamActionStatus("Running SAM multi-point auto…");
        let success = false;
        try {
            const useFallback = document.getElementById("useFallbackDilate")?.checked;
            const minProbaEl = document.getElementById("minProba");
            const dilateRatioEl = document.getElementById("dilateRatio");
            const bodyData = {
                positive_points: positivePoints,
                negative_points: negativePoints,
                uuid: placeholderContext ? placeholderContext.uuid : null,
                sam_variant: samVariant,
            };
            if (useFallback) {
                bodyData.clip_crop_policy = "dilate_on_low_conf";
                if (minProbaEl && !isNaN(parseFloat(minProbaEl.value))) {
                    bodyData.fallback_min_proba = parseFloat(minProbaEl.value);
                }
                if (dilateRatioEl && !isNaN(parseFloat(dilateRatioEl.value))) {
                    bodyData.fallback_dilate_ratio = parseFloat(dilateRatioEl.value);
                }
            }
            const resp = await postSamEndpoint(`${API_ROOT}/sam_point_multi_auto`, bodyData);
            if (!resp.ok) {
                throw new Error("sam_point_multi_auto failed: " + resp.statusText);
            }
            const result = await resp.json();
            console.log("sam_point_multi_auto =>", result);
            if (!isSamJobActive(jobHandle)) {
                return;
            }
            if (requestToken && multiPointPendingToken !== requestToken) {
                return;
            }
            if (result.image_token && currentImage) {
                rememberSamToken(currentImage.name, samVariant, result.image_token);
            }
            if (!result.uuid || !result.bbox || result.bbox.length < 4) {
                alert("Auto mode error: missing 'uuid' or invalid 'bbox' in /sam_point_multi_auto response.");
                removePendingBbox(placeholderContext);
                return;
            }
            const returnedUUID = result.uuid;
            const targetBbox = pendingApiBboxes[returnedUUID];
            if (!targetBbox) {
                console.warn("No pending bbox found for uuid:", returnedUUID);
                removePendingBbox(placeholderContext);
                return;
            }
            currentBbox = {
                bbox: targetBbox,
                index: -1,
                originalX: targetBbox.x,
                originalY: targetBbox.y,
                originalWidth: targetBbox.width,
                originalHeight: targetBbox.height,
                moving: false,
                resizing: null,
            };
            const [cx, cy, wNorm, hNorm] = result.bbox;
            const absW = wNorm * currentImage.width;
            const absH = hNorm * currentImage.height;
            const absX = cx * currentImage.width - absW / 2;
            const absY = cy * currentImage.height - absH / 2;
            const oldClass = targetBbox.class;
            const oldArr = bboxes[currentImage.name][oldClass];
            const idx = oldArr.indexOf(targetBbox);
            if (idx !== -1) oldArr.splice(idx, 1);
            const resolvedPrediction = resolveClipAutoPrediction(result);
            if (resolvedPrediction) {
                const newClass = resolvedPrediction;
                if (typeof classes[newClass] === "undefined") {
                    console.warn("SAM multi-point auto predicted unknown class:", newClass);
                    if (!bboxes[currentImage.name][oldClass]) {
                        bboxes[currentImage.name][oldClass] = [];
                    }
                    targetBbox.class = oldClass;
                    bboxes[currentImage.name][oldClass].push(targetBbox);
                } else {
                    if (!bboxes[currentImage.name][newClass]) {
                        bboxes[currentImage.name][newClass] = [];
                    }
                    targetBbox.class = newClass;
                    bboxes[currentImage.name][newClass].push(targetBbox);
                }
            } else {
                if (!bboxes[currentImage.name][oldClass]) {
                    bboxes[currentImage.name][oldClass] = [];
                }
                bboxes[currentImage.name][oldClass].push(targetBbox);
            }
            targetBbox.x = absX;
            targetBbox.y = absY;
            targetBbox.width = absW;
            targetBbox.height = absH;
            updateBboxAfterTransform();
            delete pendingApiBboxes[returnedUUID];
            success = true;
            if (multiPointPendingBboxInfo && returnedUUID === multiPointPendingBboxInfo.uuid) {
                multiPointPendingBboxInfo = null;
            }
        } catch (err) {
            console.error("sam_point_multi_auto error:", err);
            alert("sam_point_multi_auto call failed: " + err);
            removePendingBbox(placeholderContext);
        } finally {
            endSamActionStatus(statusToken);
            if (!success && placeholderContext) {
                if (multiPointPendingBboxInfo && multiPointPendingBboxInfo.uuid === placeholderContext.uuid && multiPointPendingBboxInfo.imageName === placeholderContext.imageName) {
                    multiPointPendingBboxInfo = null;
                }
            }
        }
    }

    function addMultiPointAnnotation(label) {
        if (!multiPointMode || !currentImage || currentClass === null) {
            return;
        }
        const clampedX = Math.max(0, Math.min(currentImage.width, mouse.realX));
        const clampedY = Math.max(0, Math.min(currentImage.height, mouse.realY));
        multiPointPoints.push({ x: clampedX, y: clampedY, label });
    }

    function drawMultiPointMarkers(context) {
        if (multiPointPoints.length === 0) {
            return;
        }
        const prevLineWidth = context.lineWidth;
        const prevFont = context.font;
        const prevAlign = context.textAlign;
        const prevBaseline = context.textBaseline;
        multiPointPoints.forEach((pt) => {
            const palette = pt.label === 1 ? multiPointColors.positive : multiPointColors.negative;
            const radius = Math.max(3.5, 5 * scale);
            context.beginPath();
            context.strokeStyle = palette.stroke;
            context.fillStyle = palette.fill;
            context.lineWidth = Math.max(1.2, 1.2 * scale);
            context.arc(zoomX(pt.x), zoomY(pt.y), radius, 0, Math.PI * 2);
            context.fill();
            context.stroke();
            context.fillStyle = palette.stroke;
            context.font = context.font.replace(/\d+px/, `${Math.max(9, zoom(12))}px`);
            context.textAlign = "center";
            context.textBaseline = "middle";
            context.fillText(pt.label === 1 ? "+" : "-", zoomX(pt.x), zoomY(pt.y));
        });
        context.lineWidth = prevLineWidth;
        context.font = prevFont;
        context.textAlign = prevAlign;
        context.textBaseline = prevBaseline;
    }

    async function submitMultiPointSelection() {
        if (!multiPointMode) {
            return;
        }
        if (!currentImage || currentClass === null) {
            alert("Select an image and class before using multi-point mode.");
            return;
        }
        const positivePoints = multiPointPoints.filter((pt) => pt.label === 1);
        if (positivePoints.length === 0) {
            alert("Add at least one positive point before submitting.");
            return;
        }
        const negativePoints = multiPointPoints.filter((pt) => pt.label === 0);
        const positivePayload = positivePoints.map((pt) => [pt.x, pt.y]);
        const negativePayload = negativePoints.map((pt) => [pt.x, pt.y]);
        const requestToken = generateUUID();
        const primary = positivePoints[0];
        const dotSize = 10;
        const half = dotSize / 2;
        const originalMouse = {
            startRealX: mouse.startRealX,
            startRealY: mouse.startRealY,
            realX: mouse.realX,
            realY: mouse.realY,
        };
        mouse.startRealX = primary.x - half;
        mouse.startRealY = primary.y - half;
        mouse.realX = primary.x + half;
        mouse.realY = primary.y + half;
        storeNewBbox(dotSize, dotSize);
        updateBboxAfterTransform();
        const placeholderContext = currentBbox && currentBbox.bbox && currentImage
            ? { uuid: currentBbox.bbox.uuid, imageName: currentImage.name }
            : null;
        mouse.startRealX = originalMouse.startRealX;
        mouse.startRealY = originalMouse.startRealY;
        mouse.realX = originalMouse.realX;
        mouse.realY = originalMouse.realY;
        multiPointPoints = [];
        enqueueMultiPointJob({
            requestToken,
            positivePoints: positivePayload,
            negativePoints: negativePayload,
            placeholderContext,
            imageName: currentImage.name,
            auto: samMultiPointAutoMode,
        });
    }

    // Standard parameters
    const fontBaseSize = 6;
    const fontColor = "#001f3f";
    const borderColor = "#001f3f";
    const backgroundColor = "rgba(0, 116, 217, 0.2)";
    const markedFontColor = "#FF4136";
    const markedBorderColor = "#FF4136";
    const markedBackgroundColor = "rgba(255, 133, 27, 0.2)";
    const minBBoxWidth = 5;
    const minBBoxHeight = 5;
    const scrollSpeed = 1.03;
    const minZoom = 0.1;
    const maxZoom = 5;
    const edgeSize = 5;
    const resetCanvasOnChange = true;
    const defaultScale = 0.5;
    const drawCenterX = true;
    const drawGuidelines = true;
    const fittedZoom = true;
    let canvas = null;
    let images = {};
    let classes = {};
    let bboxes = {};
    let datasetType = "bbox"; // "bbox" or "seg"
    let datasetTypeBadge = null;
    let polygonSimplifyInput = null;
    let polygonSimplifyField = null;
    let bboxCreationCounter = 0;
    let polygonDraft = null; // {points: [{x,y}], className}
    let polygonDrag = null; // {bbox, className, index, vertexIndex}
    let polygonDrawEnabled = true;
    let polygonDrawToggle = null;

    const stampBboxCreation = (bbox) => {
        if (!bbox || typeof bbox !== "object") {
            return bbox;
        }
        if (typeof bbox.uuid === "undefined" || !bbox.uuid) {
            bbox.uuid = generateUUID();
        }
        if (typeof bbox.createdAt !== "number") {
            bbox.createdAt = ++bboxCreationCounter;
        }
        return bbox;
    };

    const setPolygonDrawEnabled = (nextEnabled, { silent = false } = {}) => {
        const normalized = Boolean(nextEnabled) && datasetType === "seg";
        polygonDrawEnabled = normalized;
        if (polygonDrawToggle) {
            const label = normalized ? "Polygon draw: On (P)" : "Polygon draw: Off (P)";
            polygonDrawToggle.textContent = label;
            polygonDrawToggle.ariaPressed = normalized ? "true" : "false";
            polygonDrawToggle.disabled = datasetType !== "seg";
        }
        if (!normalized) {
            polygonDraft = null;
            polygonDrag = null;
        }
        if (!silent && datasetType === "seg") {
            const msg = normalized ? "Polygon drawing enabled (click to add points, double-click to close, Esc to cancel)." : "Polygon drawing paused; click existing polygons to select/move. Press P to toggle back on.";
            setSamStatus(msg, { variant: "info", duration: 3000 });
        }
    };

    function refreshPolygonDetailVisibility() {
        if (!polygonSimplifyField) return;
        const show = datasetType === "seg" && samMode;
        polygonSimplifyField.style.display = show ? "" : "none";
    }

    const setDatasetType = (nextType) => {
        const normalized = nextType === "seg" ? "seg" : "bbox";
        datasetType = normalized;
        // Clear polygon draft when switching to bbox
        if (datasetType === "bbox") {
            polygonDraft = null;
            polygonDrag = null;
            setPolygonDrawEnabled(false, { silent: true });
        } else if (datasetType === "seg") {
            setPolygonDrawEnabled(true, { silent: true });
        }
        applyDatasetModeConstraints();
        if (!datasetTypeBadge) {
            datasetTypeBadge = document.getElementById("datasetTypeBadge");
        }
        if (datasetTypeBadge) {
            const label = normalized === "seg" ? "Polygon / YOLO-seg mode" : "BBox mode";
            datasetTypeBadge.textContent = `Dataset mode: ${label}`;
            datasetTypeBadge.title =
                normalized === "seg"
                    ? "Polygon mode: click to add points, double-click to close, drag vertices to edit."
                    : "BBox mode";
        }
        refreshPolygonDetailVisibility();
    };

    function applyDatasetModeConstraints() {
        const isSeg = datasetType === "seg";
        // Keep auto class available in both modes; segmentation users may still want predicted classes for bboxes.
        if (samModeCheckbox) {
            samModeCheckbox.disabled = false; // still allow SAM text prompts in seg mode
        }
        if (pointModeCheckbox) {
            pointModeCheckbox.disabled = !samMode;
            if (!samMode) {
                pointModeCheckbox.checked = false;
                updatePointModeState(false);
            }
        }
        if (multiPointModeCheckbox) {
            multiPointModeCheckbox.disabled = !samMode;
            if (!samMode) {
                multiPointModeCheckbox.checked = false;
                updateMultiPointModeState(false);
            }
        }
        if (polygonDrawToggle) {
            polygonDrawToggle.disabled = !isSeg;
            if (!isSeg) {
                setPolygonDrawEnabled(false, { silent: true });
            }
        }
        if (samStatusEl) {
            const modeNote = isSeg
                ? "Polygon mode: click to add vertices, double-click to close. Bbox-only tools are disabled."
                : "BBox mode: drag to create boxes; enable SAM/Auto for tweaks.";
            samStatusEl.dataset.modeNote = modeNote;
        }
    }

    const findLatestCreatedBbox = (imageName) => {
        const classBuckets = bboxes[imageName];
        if (!classBuckets) {
            return null;
        }
        let latest = null;
        for (const className of Object.keys(classBuckets)) {
            const bucket = classBuckets[className];
            if (!Array.isArray(bucket) || bucket.length === 0) {
                continue;
            }
            for (let i = bucket.length - 1; i >= 0; i--) {
                const candidate = bucket[i];
                if (!candidate) {
                    continue;
                }
                const createdAt = typeof candidate.createdAt === "number" ? candidate.createdAt : -Infinity;
                if (!latest || createdAt > latest.createdAt || (createdAt === latest.createdAt && i > latest.index)) {
                    latest = {
                        className,
                        index: i,
                        bbox: candidate,
                        createdAt
                    };
                }
            }
        }
        return latest;
    };
    const extensions = ["jpg", "jpeg", "png", "JPG", "JPEG", "PNG"];
    let currentImage = null;
    let currentClass = null;
    let currentBbox = null;
    const selectedBboxes = new Set();
    const negativeBboxes = new Set();
    let imageListIndex = 0;
    let classListIndex = 0;
    let scale = defaultScale;
    let canvasX = 0;
    let canvasY = 0;
    let screenX = 0;
    let screenY = 0;
    const mouse = {
        x: 0,
        y: 0,
        realX: 0,
        realY: 0,
        buttonL: false,
        buttonR: false,
        startRealX: 0,
        startRealY: 0,
        shiftSelectHit: false,
        shiftKeyActive: false,
        shiftSelectDrag: false,
        shiftSelectKind: "pos",
        shiftSelectStartRealX: 0,
        shiftSelectStartRealY: 0,
        shiftSelectEndRealX: 0,
        shiftSelectEndRealY: 0,
        yoloKeyActive: false,
        yoloDragActive: false,
        yoloDragStartRealX: 0,
        yoloDragStartRealY: 0,
        yoloDragEndRealX: 0,
        yoloDragEndRealY: 0
    };

    document.addEventListener("contextmenu", function (e) {
        e.preventDefault();
    }, false);

    document.onreadystatechange = () => {
        if (document.readyState === "complete") {
            listenCanvas();
            listenCanvasMouse();
            listenImageLoad();
            listenImageSelect();
            listenClassLoad();
            listenClassSelect();
            listenBboxLoad();
            listenBboxSave();
            listenKeyboard();
            listenImageSearch();
            listenImageCrop();
            ensureBatchTweakElements();
            datasetTypeBadge = document.getElementById("datasetTypeBadge");
            setDatasetType(datasetType);
        }
    };

    function ensureCanvasDimensions() {
        if (!canvas || !canvas.element) {
            return;
        }
        const parent = canvas.element.parentElement;
        const fallbackWidth = parent ? parent.clientWidth : 0;
        const fallbackHeight = parent ? parent.clientHeight : 0;
        const measuredWidth = canvas.element.clientWidth || fallbackWidth || document.getElementById("right")?.clientWidth || window.innerWidth;
        const measuredHeight = canvas.element.clientHeight || fallbackHeight || window.innerHeight - 20;
        const targetWidth = Math.max(1, measuredWidth);
        const targetHeight = Math.max(1, measuredHeight);
        if (canvas.width !== targetWidth) {
            canvas.width = targetWidth;
            canvas.element.width = targetWidth;
        }
        if (canvas.height !== targetHeight) {
            canvas.height = targetHeight;
            canvas.element.height = targetHeight;
        }
    }

    const listenCanvas = () => {
        const rightPanel = document.getElementById("right");
        const initialWidth = rightPanel ? rightPanel.clientWidth : window.innerWidth;
        const initialHeight = Math.max(1, window.innerHeight - 20);
        canvas = new Canvas("canvas", initialWidth, initialHeight);
        ensureCanvasDimensions();
        canvas.on("draw", (context) => {
            if (currentImage !== null) {
                drawImage(context);
                drawNewBbox(context);
                drawExistingBboxes(context);
                drawSelectionRect(context);
                drawYoloSelectionRect(context);
                drawMultiPointMarkers(context);
                drawCross(context);
            } else {
                drawIntro(context);
            }
        }).start();
        window.addEventListener("resize", () => {
            ensureCanvasDimensions();
            if (currentImage) {
                fitZoom(currentImage, { preservePan: true });
            }
        });
    };

    const drawImage = (context) => {
        context.drawImage(
            currentImage.object,
            zoomX(0),
            zoomY(0),
            zoom(currentImage.width),
            zoom(currentImage.height)
        );
    };

    const drawIntro = (context) => {
        setFontStyles(context, false);
        context.fillText("USAGE:", zoomX(20), zoomY(50));
        context.fillText("1. Load your images (jpg, png).", zoomX(20), zoomY(100));
        context.fillText("2. Load your classes (yolo *.names).", zoomX(20), zoomY(150));
        context.fillText("3. Create bboxes or restore from zipped YOLO annotations.", zoomX(20), zoomY(200));
        context.fillText("NOTES:", zoomX(20), zoomY(300));
        context.fillText("1: Reloading images resets bboxes.", zoomX(20), zoomY(350));
        context.fillText("2: Check out README.md for more info.", zoomX(20), zoomY(400));
    };

    const drawNewBbox = (context) => {
        const isSegDataset = datasetType === "seg";
        const segBboxMode = isSegDataset && !polygonDrawEnabled;
        if (mouse.shiftKeyActive || mouse.shiftSelectDrag || mouse.yoloKeyActive || mouse.yoloDragActive) {
            return;
        }
        if (isSegDataset && polygonDrawEnabled && !samMode) {
            drawNewPolygon(context);
            return;
        }
        const canPreview =
            mouse.buttonL === true &&
            currentClass !== null &&
            (currentBbox === null || isSegDataset) &&
            (segBboxMode || datasetType !== "seg" || samMode);
        if (canPreview) {
            const width = (mouse.realX - mouse.startRealX);
            const height = (mouse.realY - mouse.startRealY);
            const strokeColor = getColorFromClass(currentClass);
            const fillColor = withAlpha(strokeColor, 0.2);
            context.setLineDash([]);
            context.strokeStyle = strokeColor;
            context.fillStyle = fillColor;
            context.strokeRect(
                zoomX(mouse.startRealX),
                zoomY(mouse.startRealY),
                zoom(width),
                zoom(height)
            );
            context.fillRect(
                zoomX(mouse.startRealX),
                zoomY(mouse.startRealY),
                zoom(width),
                zoom(height)
            );
            drawX(context, mouse.startRealX, mouse.startRealY, width, height);
            setBboxCoordinates(mouse.startRealX, mouse.startRealY, width, height);
        }
    };

    const drawNewPolygon = (context) => {
        if (!polygonDraft || !Array.isArray(polygonDraft.points) || polygonDraft.points.length === 0) {
            return;
        }
        const strokeColor = getColorFromClass(polygonDraft.className || currentClass || "");
        const fillColor = withAlpha(strokeColor, 0.2);
        context.save();
        context.strokeStyle = strokeColor;
        context.fillStyle = fillColor;
        context.lineWidth = Math.max(1, 1.2 * scale);
        context.beginPath();
        polygonDraft.points.forEach((pt, idx) => {
            const x = zoomX(pt.x);
            const y = zoomY(pt.y);
            if (idx === 0) {
                context.moveTo(x, y);
            } else {
                context.lineTo(x, y);
            }
        });
        context.stroke();
        polygonDraft.points.forEach((pt) => {
            const x = zoomX(pt.x);
            const y = zoomY(pt.y);
            context.beginPath();
            context.arc(x, y, Math.max(3, 4 * scale), 0, Math.PI * 2);
            context.fill();
        });
        context.restore();
    };

    const drawExistingBboxes = (context) => {
        const currentBboxes = bboxes[currentImage.name];
        if (!currentBboxes) {
            return;
        }
        for (let className in currentBboxes) {
            currentBboxes[className].forEach((bbox) => {
                context.save();
                const strokeColor = getColorFromClass(className);
                const fillColor = withAlpha(strokeColor, 0.2);
                const isCurrent = currentBbox && currentBbox.bbox === bbox;
                const isSelected = !!bbox.uuid && selectedBboxes.has(bbox.uuid);
                const isNegativeSelected = !!bbox.uuid && negativeBboxes.has(bbox.uuid);
                const lineWidth = isCurrent ? Math.max(1.5, 1.5 * scale) : 1;
                const pulseNow = performance.now();
                const pulseAlpha = 0.35 + 0.25 * Math.sin(pulseNow / 200);
                const highlightColor = `rgba(34, 197, 94, ${Math.min(0.9, 0.55 + pulseAlpha)})`;
                const highlightDash = [6 * scale, 4 * scale];

                context.font = context.font.replace(/\d+px/, `${Math.max(8, zoom(fontBaseSize))}px`);
                context.fillStyle = strokeColor;
                context.fillText(className, zoomX(bbox.x), zoomY(bbox.y - 2));

                context.setLineDash([]);
                context.lineWidth = lineWidth;
                context.strokeStyle = strokeColor;
                context.fillStyle = fillColor;
                const isPolygon = bbox.type === "polygon" || (Array.isArray(bbox.points) && bbox.points.length >= 3);
                if (isPolygon) {
                    context.beginPath();
                    bbox.points.forEach((pt, idx) => {
                        const x = zoomX(pt.x);
                        const y = zoomY(pt.y);
                        if (idx === 0) {
                            context.moveTo(x, y);
                        } else {
                            context.lineTo(x, y);
                        }
                    });
                    context.closePath();
                    context.fill();
                    context.stroke();
                    if (isSelected || isNegativeSelected) {
                        context.save();
                        context.strokeStyle = isNegativeSelected ? "#ef4444" : "#22c55e";
                        context.lineWidth = Math.max(2, 2 * scale);
                        context.setLineDash([4 * scale, 4 * scale]);
                        context.stroke();
                        context.restore();
                    }
                    if (isCurrent) {
                        bbox.points.forEach((pt, idx) => {
                            const x = pt.x;
                            const y = pt.y;
                            drawCornerHandle(context, x, y, strokeColor);
                            if (idx === 0) {
                                context.beginPath();
                                context.arc(zoomX(x), zoomY(y), Math.max(4, 5 * scale), 0, Math.PI * 2);
                                context.stroke();
                            }
                        });
                        context.save();
                        context.strokeStyle = highlightColor;
                        context.lineWidth = Math.max(2.5, 2.5 * scale);
                        context.setLineDash(highlightDash);
                        context.lineDashOffset = (pulseNow / 20) % (10 * scale);
                        context.beginPath();
                        bbox.points.forEach((pt, idx) => {
                            const x = zoomX(pt.x);
                            const y = zoomY(pt.y);
                            if (idx === 0) {
                                context.moveTo(x, y);
                            } else {
                                context.lineTo(x, y);
                            }
                        });
                        context.closePath();
                        context.stroke();
                        context.restore();
                    }
                } else {
                    context.fillRect(
                        zoomX(bbox.x),
                        zoomY(bbox.y),
                        zoom(bbox.width),
                        zoom(bbox.height)
                    );
                    context.strokeRect(
                        zoomX(bbox.x),
                        zoomY(bbox.y),
                        zoom(bbox.width),
                        zoom(bbox.height)
                    );
                    drawX(context, bbox.x, bbox.y, bbox.width, bbox.height);
                    if (isCurrent && currentBbox.resizing) {
                        const handlePoint = getCornerCoordinates(bbox, currentBbox.resizing);
                        if (handlePoint) {
                            drawCornerHandle(context, handlePoint.x, handlePoint.y, strokeColor);
                        }
                    }
                    if (isSelected || isNegativeSelected) {
                        context.save();
                        context.strokeStyle = isNegativeSelected ? "#ef4444" : "#22c55e";
                        context.lineWidth = Math.max(2, 2 * scale);
                        context.setLineDash([4 * scale, 4 * scale]);
                        context.strokeRect(
                            zoomX(bbox.x) - 2,
                            zoomY(bbox.y) - 2,
                            zoom(bbox.width) + 4,
                            zoom(bbox.height) + 4
                        );
                        context.restore();
                    }
                    if (isCurrent) {
                        context.save();
                        context.strokeStyle = highlightColor;
                        context.lineWidth = Math.max(2.5, 2.5 * scale);
                        context.setLineDash(highlightDash);
                        context.lineDashOffset = (pulseNow / 20) % (10 * scale);
                        context.strokeRect(
                            zoomX(bbox.x),
                            zoomY(bbox.y),
                            zoom(bbox.width),
                            zoom(bbox.height)
                        );
                        context.restore();
                    }
                    if (bbox.marked === true) {
                        setBboxCoordinates(bbox.x, bbox.y, bbox.width, bbox.height);
                    }
                }
                context.restore();
            });
        }
    };

    const drawSelectionRect = (context) => {
        if (!mouse.shiftSelectDrag) {
            return;
        }
        const startX = mouse.shiftSelectStartRealX;
        const startY = mouse.shiftSelectStartRealY;
        const endX = mouse.shiftSelectEndRealX;
        const endY = mouse.shiftSelectEndRealY;
        const left = Math.min(startX, endX);
        const top = Math.min(startY, endY);
        const width = Math.abs(endX - startX);
        const height = Math.abs(endY - startY);
        if (width < 1 || height < 1) {
            return;
        }
        const isNegative = mouse.shiftSelectKind === "neg";
        context.save();
        context.setLineDash([6 * scale, 4 * scale]);
        context.lineWidth = Math.max(1.5, 1.5 * scale);
        context.strokeStyle = isNegative ? "#ef4444" : "#22c55e";
        context.fillStyle = isNegative ? "rgba(239, 68, 68, 0.08)" : "rgba(34, 197, 94, 0.08)";
        context.strokeRect(zoomX(left), zoomY(top), zoom(width), zoom(height));
        context.fillRect(zoomX(left), zoomY(top), zoom(width), zoom(height));
        context.restore();
    };

    const drawYoloSelectionRect = (context) => {
        if (!mouse.yoloDragActive) {
            return;
        }
        const startX = mouse.yoloDragStartRealX;
        const startY = mouse.yoloDragStartRealY;
        const endX = mouse.yoloDragEndRealX;
        const endY = mouse.yoloDragEndRealY;
        const left = Math.min(startX, endX);
        const top = Math.min(startY, endY);
        const width = Math.abs(endX - startX);
        const height = Math.abs(endY - startY);
        if (width < 1 || height < 1) {
            return;
        }
        context.save();
        context.setLineDash([6 * scale, 4 * scale]);
        context.lineWidth = Math.max(1.5, 1.5 * scale);
        context.strokeStyle = "#3b82f6";
        context.fillStyle = "rgba(59, 130, 246, 0.10)";
        context.strokeRect(zoomX(left), zoomY(top), zoom(width), zoom(height));
        context.fillRect(zoomX(left), zoomY(top), zoom(width), zoom(height));
        context.restore();
    };

    function getCornerCoordinates(bbox, corner) {
        const x1 = bbox.x;
        const y1 = bbox.y;
        const x2 = bbox.x + bbox.width;
        const y2 = bbox.y + bbox.height;
        switch (corner) {
            case "topLeft":
                return { x: x1, y: y1 };
            case "topRight":
                return { x: x2, y: y1 };
            case "bottomLeft":
                return { x: x1, y: y2 };
            case "bottomRight":
                return { x: x2, y: y2 };
            default:
                return null;
        }
    }

    function isPointInsideBbox(bbox, x, y) {
        if (!bbox) return false;
        const x1 = bbox.x;
        const y1 = bbox.y;
        const x2 = bbox.x + bbox.width;
        const y2 = bbox.y + bbox.height;
        return x >= x1 && x <= x2 && y >= y1 && y <= y2;
    }

    function drawCornerHandle(context, x, y, strokeColor) {
        context.save();
        const radius = Math.max(3, 5 * scale);
        context.beginPath();
        context.strokeStyle = strokeColor;
        context.fillStyle = withAlpha(strokeColor, 0.35);
        context.lineWidth = Math.max(1.2, 1.2 * scale);
        context.arc(zoomX(x), zoomY(y), radius, 0, Math.PI * 2);
        context.fill();
        context.stroke();
        context.restore();
    }

    const drawX = (context, x, y, width, height) => {
        if (drawCenterX === true) {
            const centerX = x + width / 2;
            const centerY = y + height / 2;
            context.beginPath();
            context.moveTo(zoomX(centerX), zoomY(centerY - 10));
            context.lineTo(zoomX(centerX), zoomY(centerY + 10));
            context.stroke();
            context.beginPath();
            context.moveTo(zoomX(centerX - 10), zoomY(centerY));
            context.lineTo(zoomX(centerX + 10), zoomY(centerY));
            context.stroke();
        }
    };

    const drawCross = (context) => {
        if (drawGuidelines === true) {
            context.setLineDash([5]);
            context.beginPath();
            context.moveTo(zoomX(mouse.realX), zoomY(0));
            context.lineTo(zoomX(mouse.realX), zoomY(currentImage.height));
            context.stroke();
            context.beginPath();
            context.moveTo(zoomX(0), zoomY(mouse.realY));
            context.lineTo(zoomX(currentImage.width), zoomY(mouse.realY));
            context.stroke();
        }
    };

    const setBBoxStyles = (context, marked) => {
        context.setLineDash([]);
        if (marked === false) {
            context.strokeStyle = borderColor;
            context.fillStyle = backgroundColor;
        } else {
            context.strokeStyle = markedBorderColor;
            context.fillStyle = markedBackgroundColor;
        }
    };

    const setBboxCoordinates = (x, y, width, height) => {
        const x2 = x + width;
        const y2 = y + height;
        document.getElementById("bboxInformation").innerHTML =
            `${width}x${height} (${x}, ${y}) (${x2}, ${y2})`;
    };

    const setFontStyles = (context, marked) => {
        if (marked === false) {
            context.fillStyle = fontColor;
        } else {
            context.fillStyle = markedFontColor;
        }
        context.font = context.font.replace(/\d+px/, `${zoom(fontBaseSize)}px`);
    };

    const listenCanvasMouse = () => {
        canvas.element.addEventListener("wheel", trackWheel, { passive: false });
        canvas.element.addEventListener("mousemove", trackPointer);
        canvas.element.addEventListener("mousedown", trackPointer);
        canvas.element.addEventListener("mouseup", trackPointer);
        canvas.element.addEventListener("mouseout", trackPointer);
        document.addEventListener("mouseup", () => {
            if (!mouse.yoloDragActive || !currentImage) {
                return;
            }
            const left = Math.min(mouse.yoloDragStartRealX, mouse.yoloDragEndRealX);
            const top = Math.min(mouse.yoloDragStartRealY, mouse.yoloDragEndRealY);
            const width = Math.abs(mouse.yoloDragEndRealX - mouse.yoloDragStartRealX);
            const height = Math.abs(mouse.yoloDragEndRealY - mouse.yoloDragStartRealY);
            mouse.buttonL = false;
            mouse.buttonR = false;
            mouse.yoloDragActive = false;
            runRegionDetect({ x: left, y: top, width, height });
        });
        window.addEventListener("blur", () => {
            mouse.yoloKeyActive = false;
            mouse.yoloDragActive = false;
        });
    };

    const trackWheel = (event) => {
        if (event.shiftKey) {
            const panSpeed = -1.5;
            canvasX -= event.deltaX * panSpeed;
            canvasY -= event.deltaY * panSpeed;
            mouse.realX = zoomXInv(mouse.x);
            mouse.realY = zoomYInv(mouse.y);
            event.preventDefault();
            return;
        }
        if (event.deltaY < 0) {
            scale = Math.min(maxZoom, scale * scrollSpeed);
        } else {
            scale = Math.max(minZoom, scale * (1 / scrollSpeed));
        }
        canvasX = mouse.realX;
        canvasY = mouse.realY;
        screenX = mouse.x;
        screenY = mouse.y;
        mouse.realX = zoomXInv(mouse.x);
        mouse.realY = zoomYInv(mouse.y);
        event.preventDefault();
    };

    async function trackPointer(event) {
        mouse.bounds = canvas.element.getBoundingClientRect();
        mouse.x = event.clientX - mouse.bounds.left;
        mouse.y = event.clientY - mouse.bounds.top;
        const oldRealX = mouse.realX;
        const oldRealY = mouse.realY;
        mouse.realX = zoomXInv(mouse.x);
        mouse.realY = zoomYInv(mouse.y);
        mouse.shiftKeyActive = !!event.shiftKey;
    
        if (event.type === "mousedown") {
            mouse.startRealX = mouse.realX;
            mouse.startRealY = mouse.realY;
            mouse.shiftSelectHit = false;
            mouse.shiftSelectDrag = false;
            if (event.which === 3) {
                mouse.buttonR = true;
            } else if (event.which === 1) {
                mouse.buttonL = true;
                if (mouse.yoloKeyActive && currentImage) {
                    mouse.yoloDragActive = true;
                    mouse.yoloDragStartRealX = mouse.realX;
                    mouse.yoloDragStartRealY = mouse.realY;
                    mouse.yoloDragEndRealX = mouse.realX;
                    mouse.yoloDragEndRealY = mouse.realY;
                    return;
                }
                if (event.shiftKey && currentImage) {
                    mouse.shiftSelectKind = event.altKey ? "neg" : "pos";
                    const shiftHit = findBboxAtPoint(mouse.realX, mouse.realY);
                    if (shiftHit && shiftHit.bbox) {
                        mouse.shiftSelectHit = true;
                    } else {
                        mouse.shiftSelectDrag = true;
                        mouse.shiftSelectStartRealX = mouse.realX;
                        mouse.shiftSelectStartRealY = mouse.realY;
                        mouse.shiftSelectEndRealX = mouse.realX;
                        mouse.shiftSelectEndRealY = mouse.realY;
                    }
                }
                const segBboxMode = datasetType === "seg" && !polygonDrawEnabled;
                if (datasetType !== "seg" || segBboxMode) {
                    const insideExisting = currentBbox && isPointInsideBbox(currentBbox.bbox, mouse.realX, mouse.realY);
                    if (!insideExisting) {
                        currentBbox = null;
                    }
                }
            }
        }
        if (event.type === "mousemove" && mouse.shiftSelectDrag) {
            mouse.shiftSelectEndRealX = mouse.realX;
            mouse.shiftSelectEndRealY = mouse.realY;
        }
        if (event.type === "mousemove" && mouse.yoloDragActive) {
            mouse.yoloDragEndRealX = mouse.realX;
            mouse.yoloDragEndRealY = mouse.realY;
            return;
        }
        const isSegDataset = datasetType === "seg";
        if (isSegDataset) {
            const handled = await handlePolygonPointer(event, oldRealX, oldRealY);
            if (handled) {
                if (event.type === "mouseup" || event.type === "mouseout") {
                    mouse.buttonR = false;
                    mouse.buttonL = false;
                }
                return;
            }
            // If polygon drawing is off, allow bbox flows to continue in seg mode.
            if (!samMode && polygonDrawEnabled) {
                if (event.type === "mouseup" || event.type === "mouseout") {
                    mouse.buttonR = false;
                    mouse.buttonL = false;
                }
                return;
            }
        }
        if (event.type === "mouseup" || event.type === "mouseout") {
            if (mouse.buttonL && currentImage !== null) {
                if (mouse.yoloDragActive) {
                    const left = Math.min(mouse.yoloDragStartRealX, mouse.yoloDragEndRealX);
                    const top = Math.min(mouse.yoloDragStartRealY, mouse.yoloDragEndRealY);
                    const width = Math.abs(mouse.yoloDragEndRealX - mouse.yoloDragStartRealX);
                    const height = Math.abs(mouse.yoloDragEndRealY - mouse.yoloDragStartRealY);
                    mouse.buttonL = false;
                    mouse.buttonR = false;
                    mouse.yoloDragActive = false;
                    await runRegionDetect({ x: left, y: top, width, height });
                    return;
                }
                if (mouse.shiftSelectHit) {
                    setBboxMarkedState({ additive: true, negative: mouse.shiftSelectKind === "neg" });
                    mouse.buttonL = false;
                    mouse.buttonR = false;
                    mouse.shiftSelectHit = false;
                    return;
                }
                if (mouse.shiftSelectDrag) {
                    const left = Math.min(mouse.shiftSelectStartRealX, mouse.shiftSelectEndRealX);
                    const top = Math.min(mouse.shiftSelectStartRealY, mouse.shiftSelectEndRealY);
                    const width = Math.abs(mouse.shiftSelectEndRealX - mouse.shiftSelectStartRealX);
                    const height = Math.abs(mouse.shiftSelectEndRealY - mouse.shiftSelectStartRealY);
                    if (width > 1 && height > 1) {
                        selectBboxesInRect(
                            { x: left, y: top, width, height },
                            { additive: true, negative: mouse.shiftSelectKind === "neg" }
                        );
                    }
                    mouse.buttonL = false;
                    mouse.buttonR = false;
                    mouse.shiftSelectDrag = false;
                    mouse.shiftSelectHit = false;
                    return;
                }
                if (currentClass === null) {
                    mouse.buttonL = false;
                    mouse.buttonR = false;
                    mouse.shiftSelectHit = false;
                    mouse.shiftSelectDrag = false;
                    return;
                }
                if (multiPointMode) {
                    mouse.buttonL = false;
                    mouse.buttonR = false;
                    return;
                }
                if (pointMode) {
                    currentBbox = null;
                    const dotSize = 10;
                    const half = dotSize / 2;
                    mouse.startRealX = mouse.realX - half;
                    mouse.startRealY = mouse.realY - half;
                    storeNewBbox(dotSize, dotSize);
                    mouse.buttonL = false;
                    mouse.buttonR = false;
                    if (samPointAutoMode) {
                        await samPointAutoPrompt(mouse.realX, mouse.realY);
                    } else {
                        await samPointPrompt(mouse.realX, mouse.realY);
                    }
                    setBboxMarkedState();
                    if (currentBbox) {
                        updateBboxAfterTransform();
                    }
                }
                else {
                    const movedWidth  = Math.abs(mouse.realX - mouse.startRealX);
                    const movedHeight = Math.abs(mouse.realY - mouse.startRealY);
                    if (movedWidth > minBBoxWidth && movedHeight > minBBoxHeight) {
                        if (currentBbox === null) {
                            storeNewBbox(movedWidth, movedHeight);
                            mouse.buttonL = false;
                            mouse.buttonR = false;
                            if (samMode && autoMode) {
                                await samBboxAutoPrompt(currentBbox.bbox);
                            }
                            else if (autoMode) {
                                await autoPredictNewCrop(currentBbox.bbox);
                            }
                            else if (samMode) {
                                await samBboxPrompt(currentBbox.bbox);
                            }
                            else {
                                setBboxMarkedState();
                                if (currentBbox) {
                                    updateBboxAfterTransform();
                                }
                            }
                            setBboxMarkedState();
                            if (currentBbox) {
                                updateBboxAfterTransform();
                            }
                        }
                        else {
                            updateBboxAfterTransform();
                        }
                    }
                    else {
                        setBboxMarkedState();
                        if (currentBbox !== null) {
                            updateBboxAfterTransform();
                        }
                    }
                }
            }
            mouse.buttonR = false;
            mouse.buttonL = false;
            mouse.shiftSelectHit = false;
            mouse.shiftSelectDrag = false;
        }

        // In seg+SAM mode, allow bbox flows (preview, pan) to run; in plain seg mode we already returned above.
        if (datasetType === "seg" && samMode) {
            const polygonSelected = currentBbox && (currentBbox.bbox?.type === "polygon" || (Array.isArray(currentBbox.bbox?.points) && currentBbox.bbox.points.length >= 3));
            if (!polygonSelected) {
                moveBbox();
                resizeBbox();
            }
            changeCursorByLocation();
            panImage(oldRealX, oldRealY);
            return;
        } else if (datasetType === "seg" && polygonDrawEnabled) {
            return;
        }
        moveBbox();
        resizeBbox();
        changeCursorByLocation();
        panImage(oldRealX, oldRealY);
    }

    function pointInPolygon(x, y, points) {
        if (!Array.isArray(points) || points.length < 3) return false;
        let inside = false;
        for (let i = 0, j = points.length - 1; i < points.length; j = i++) {
            const xi = points[i].x, yi = points[i].y;
            const xj = points[j].x, yj = points[j].y;
            const intersect = ((yi > y) !== (yj > y)) && (x < ((xj - xi) * (y - yi)) / (yj - yi + 1e-9) + xi);
            if (intersect) inside = !inside;
        }
        return inside;
    }

    function findPolygonAt(x, y) {
        if (!currentImage || !bboxes[currentImage.name]) return null;
        const imgBxs = bboxes[currentImage.name];
        let found = null;
        Object.keys(imgBxs).forEach((className) => {
            imgBxs[className].forEach((ann, idx) => {
                if (found || ann.type !== "polygon" || !Array.isArray(ann.points)) return;
                const distThreshold = Math.max(6, 10 / scale);
                // Prefer vertex hit
                ann.points.forEach((pt, vIdx) => {
                    const dx = pt.x - x;
                    const dy = pt.y - y;
                    const dist = Math.sqrt(dx * dx + dy * dy);
                    if (dist <= distThreshold && !found) {
                        found = { bbox: ann, className, index: idx, vertexIndex: vIdx };
                    }
                });
                if (!found && pointInPolygon(x, y, ann.points)) {
                    found = { bbox: ann, className, index: idx, vertexIndex: null };
                }
            });
        });
        return found;
    }

    function clampPointToImage(pt) {
        if (!currentImage) return pt;
        const w = currentImage.width || currentImage.object?.naturalWidth || 0;
        const h = currentImage.height || currentImage.object?.naturalHeight || 0;
        return {
            x: Math.max(0, Math.min(w, pt.x)),
            y: Math.max(0, Math.min(h, pt.y)),
        };
    }

    function finalizePolygonDraft() {
        if (!polygonDraft || !currentImage || !currentClass) {
            polygonDraft = null;
            return;
        }
        const pts = (polygonDraft.points || []).map(clampPointToImage);
        if (pts.length < 3) {
            polygonDraft = null;
            return;
        }
        const xs = pts.map((p) => p.x);
        const ys = pts.map((p) => p.y);
        const minX = Math.max(0, Math.min(...xs));
        const maxX = Math.min(currentImage.width, Math.max(...xs));
        const minY = Math.max(0, Math.min(...ys));
        const maxY = Math.min(currentImage.height, Math.max(...ys));
        const bboxRecord = {
            type: "polygon",
            points: pts,
            x: minX,
            y: minY,
            width: Math.max(0, maxX - minX),
            height: Math.max(0, maxY - minY),
            marked: false,
            class: polygonDraft.className || currentClass,
        };
        stampBboxCreation(bboxRecord);
        if (!bboxes[currentImage.name]) {
            bboxes[currentImage.name] = {};
        }
        const targetClass = polygonDraft.className || currentClass;
        if (!bboxes[currentImage.name][targetClass]) {
            bboxes[currentImage.name][targetClass] = [];
        }
        // Deduplicate exact same polygon for the same class
        const existing = bboxes[currentImage.name][targetClass].some((ann) => {
            if (ann.type !== "polygon" || !Array.isArray(ann.points) || ann.points.length !== pts.length) return false;
            return ann.points.every((pt, idx) => Math.abs(pt.x - pts[idx].x) < 1e-3 && Math.abs(pt.y - pts[idx].y) < 1e-3);
        });
        if (!existing) {
            bboxes[currentImage.name][targetClass].push(bboxRecord);
            currentBbox = {
                bbox: bboxRecord,
                index: bboxes[currentImage.name][targetClass].length - 1,
                originalX: bboxRecord.x,
                originalY: bboxRecord.y,
                originalWidth: bboxRecord.width,
                originalHeight: bboxRecord.height,
                moving: false,
                resizing: null,
            };
        } else {
            currentBbox = null;
        }
        setDatasetType("seg");
        polygonDraft = null;
    }

    async function handlePolygonPointer(event, prevX, prevY) {
        if (!currentClass || !currentImage) {
            return false;
        }
        const samActive = samMode === true;
        if (mouse.buttonR) {
            panImage(prevX, prevY);
        }
        if (event.type === "mousedown") {
            if (event.which === 3) {
                // Right click: cancel or finalize draft
                if (!samActive && polygonDraft && polygonDraft.points.length >= 3) {
                    finalizePolygonDraft();
                } else if (!samActive) {
                    polygonDraft = null;
                }
                polygonDrag = null;
                currentBbox = null;
                return true;
            }
            if (event.which === 1) {
                const hit = findPolygonAt(mouse.realX, mouse.realY);
                if (hit) {
                    currentClass = hit.className || currentClass;
                    currentBbox = {
                        bbox: hit.bbox,
                        index: hit.index,
                        originalX: hit.bbox.x,
                        originalY: hit.bbox.y,
                        originalWidth: hit.bbox.width,
                        originalHeight: hit.bbox.height,
                        moving: false,
                        resizing: null,
                    };
                    if (!samActive && hit.vertexIndex !== null && hit.vertexIndex !== undefined) {
                        polygonDrag = { ...hit, vertexIndex: hit.vertexIndex };
                    } else {
                        polygonDrag = { ...hit, vertexIndex: null };
                    }
                    return true;
                }
                if (samActive) {
                    // In SAM mode, do not start polygon drafting; allow bbox drawing.
                    currentBbox = null;
                    polygonDrag = null;
                    polygonDraft = null;
                    return false;
                }
                if (!polygonDrawEnabled) {
                    polygonDraft = null;
                    polygonDrag = null;
                    currentBbox = null;
                    return false;
                }
                // Double click closes polygon
                if (polygonDraft && event.detail > 1 && polygonDraft.points.length >= 3) {
                    finalizePolygonDraft();
                    return true;
                }
                if (!polygonDraft) {
                    polygonDraft = { className: currentClass, points: [] };
                }
                polygonDraft.points.push({ x: mouse.realX, y: mouse.realY });
            }
        } else if (event.type === "mousemove") {
            if (polygonDrag && polygonDrag.vertexIndex !== null && polygonDrag.vertexIndex !== undefined) {
                const pts = polygonDrag.bbox.points;
                pts[polygonDrag.vertexIndex] = clampPointToImage({ x: mouse.realX, y: mouse.realY });
                const xs = pts.map((p) => p.x);
                const ys = pts.map((p) => p.y);
                polygonDrag.bbox.x = Math.min(...xs);
                polygonDrag.bbox.y = Math.min(...ys);
                polygonDrag.bbox.width = Math.max(...xs) - polygonDrag.bbox.x;
                polygonDrag.bbox.height = Math.max(...ys) - polygonDrag.bbox.y;
            }
        } else if (event.type === "mouseup" || event.type === "mouseout") {
            polygonDrag = null;
        }
        return false;
    }

    const storeNewBbox = (movedWidth, movedHeight) => {
        const bbox = {
            type: "bbox",
            x: Math.min(mouse.startRealX, mouse.realX),
            y: Math.min(mouse.startRealY, mouse.realY),
            width: movedWidth,
            height: movedHeight,
            marked: true,
            class: currentClass,
            uuid: generateUUID()
        };
        stampBboxCreation(bbox);
        if (!bboxes[currentImage.name]) {
            bboxes[currentImage.name] = {};
        }
        if (!bboxes[currentImage.name][currentClass]) {
            bboxes[currentImage.name][currentClass] = [];
        }
        bboxes[currentImage.name][currentClass].push(bbox);
        currentBbox = {
            bbox: bbox,
            index: bboxes[currentImage.name][currentClass].length - 1,
            originalX: bbox.x,
            originalY: bbox.y,
            originalWidth: bbox.width,
            originalHeight: bbox.height,
            moving: false,
            resizing: null
        };
        pendingApiBboxes[bbox.uuid] = bbox;
    };

    const updateBboxAfterTransform = () => {
        if (currentBbox && currentBbox.resizing !== null) {
            if (currentBbox.bbox.width < 0) {
                currentBbox.bbox.width = Math.abs(currentBbox.bbox.width);
                currentBbox.bbox.x -= currentBbox.bbox.width;
            }
            if (currentBbox.bbox.height < 0) {
                currentBbox.bbox.height = Math.abs(currentBbox.bbox.height);
                currentBbox.bbox.y -= currentBbox.bbox.height;
            }
            currentBbox.resizing = null;
        }
        if (currentBbox) {
            currentBbox.bbox.marked = true;
            currentBbox.originalX = currentBbox.bbox.x;
            currentBbox.originalY = currentBbox.bbox.y;
            currentBbox.originalWidth = currentBbox.bbox.width;
            currentBbox.originalHeight = currentBbox.bbox.height;
            currentBbox.moving = false;
        }
    };

    function findBboxAtPoint(x, y) {
        if (!currentImage || !bboxes[currentImage.name]) return null;
        const currentBxs = bboxes[currentImage.name];
        let found = null;
        let smallestArea = Number.MAX_SAFE_INTEGER;
        for (let className in currentBxs) {
            currentBxs[className].forEach((bx, i) => {
                if (!bx) return;
                const isPoly = bx.type === "polygon" || (Array.isArray(bx.points) && bx.points.length >= 3);
                let inside = false;
                let area = Number.MAX_SAFE_INTEGER;
                if (isPoly) {
                    inside = pointInPolygon(x, y, bx.points);
                    if (inside) {
                        const xs = bx.points.map((p) => p.x);
                        const ys = bx.points.map((p) => p.y);
                        area = (Math.max(...xs) - Math.min(...xs)) * (Math.max(...ys) - Math.min(...ys));
                    }
                } else {
                    inside = isPointInsideBbox(bx, x, y);
                    area = Math.abs(bx.width * bx.height);
                }
                if (inside && area < smallestArea) {
                    smallestArea = area;
                    found = { bbox: bx, className, index: i };
                }
            });
        }
        return found;
    }

    const setBboxMarkedState = ({ additive = false, negative = false } = {}) => {
        if (datasetType === "seg" && polygonDrawEnabled) {
            if (currentBbox && currentBbox.bbox) {
                currentBbox.bbox.marked = true;
            }
            return;
        }
        if (!currentBbox || (!currentBbox.moving && !currentBbox.resizing)) {
            if (!currentImage || !bboxes[currentImage.name]) {
                currentBbox = null;
                if (!additive) {
                    clearSelectedBboxes();
                }
                return;
            }
            const currentBxs = bboxes[currentImage.name];
            for (let className in currentBxs) {
                currentBxs[className].forEach((bx) => {
                    bx.marked = false;
                });
            }
            const hit = findBboxAtPoint(mouse.startRealX, mouse.startRealY);
            if (!additive) {
                clearSelectedBboxes({ keepCurrent: true });
            }
            if (hit && hit.bbox) {
                if (!hit.bbox.uuid) {
                    hit.bbox.uuid = generateUUID();
                }
                const preserveCurrent = negative && currentBbox && currentBbox.bbox && currentBbox.bbox !== hit.bbox;
                if (!preserveCurrent) {
                    currentBbox = {
                        bbox: hit.bbox,
                        index: hit.index,
                        originalX: hit.bbox.x,
                        originalY: hit.bbox.y,
                        originalWidth: hit.bbox.width,
                        originalHeight: hit.bbox.height,
                        moving: false,
                        resizing: null
                    };
                    currentBbox.bbox.marked = true;
                } else if (currentBbox && currentBbox.bbox) {
                    currentBbox.bbox.marked = true;
                }
                selectBboxRecord(hit.bbox, { additive, negative });
            } else {
                if (!additive) {
                    clearSelectedBboxes();
                }
                currentBbox = null;
            }
        }
    };

    async function runMagicTweakForBbox(targetBbox, { updateSelection = false } = {}) {
        if (datasetType === "seg") {
            setSamStatus("Tweak is only available in bbox mode.", { variant: "warn", duration: 3000 });
            return false;
        }
        if (!targetBbox) {
            return false;
        }
        if (!samMode && !autoMode) {
            setSamStatus("Enable SAM or Auto Class to tweak bboxes", { variant: "warn", duration: 3000 });
            return false;
        }
        if (!currentImage || !currentImage.name) {
            return false;
        }
        if (samMode && samSlotsEnabled && samPreloadEnabled) {
            let token = getSamToken(currentImage.name, samVariant);
            if (!token) {
                const alreadyQueued = isSamPreloadActiveFor(currentImage.name, samVariant);
                setSamStatus("Waiting for SAM to load this image…", { variant: "info", duration: 0 });
                showSamPreloadProgress();
                if (!alreadyQueued) {
                    prepareSamForCurrentImage({ messagePrefix: "Preparing SAM" }).catch((err) => {
                        console.debug("prepareSamForCurrentImage (tweak) failed", err);
                    });
                }
                token = await waitForSamPreloadIfActive(currentImage.name, samVariant);
                if (!token) {
                    setSamStatus("Using fresh SAM load for this image", { variant: "info", duration: 2500 });
                } else {
                    setSamStatus(`SAM ready for ${currentImage.name}`, { variant: "success", duration: 1200 });
                }
            }
        }
        if (!targetBbox.uuid) {
            stampBboxCreation(targetBbox);
        }
        pendingApiBboxes[targetBbox.uuid] = targetBbox;
        tweakPreserveSet.add(targetBbox.uuid);
        try {
            if (samMode && autoMode) {
                await samBboxAutoPrompt(targetBbox);
            } else if (samMode) {
                await samBboxPrompt(targetBbox);
            } else if (autoMode) {
                await autoPredictNewCrop(targetBbox);
            }
            if (updateSelection) {
                setBboxMarkedState();
                if (currentBbox) {
                    updateBboxAfterTransform();
                }
            }
            return true;
        } catch (error) {
            console.warn("One-click tweak failed", error);
            setSamStatus(`Tweak failed: ${error.message || error}`, { variant: "error", duration: 4000 });
            return false;
        } finally {
            tweakPreserveSet.delete(targetBbox.uuid);
        }
    }

    async function runMagicTweakForCurrentBbox() {
        if (!currentBbox || !currentBbox.bbox) {
            setSamStatus("Select a bbox before pressing X", { variant: "warn", duration: 3000 });
            return false;
        }
        return runMagicTweakForBbox(currentBbox.bbox, { updateSelection: true });
    }

    async function runBatchTweakForCurrentCategory() {
        if (batchTweakRunning) {
            setSamStatus("Batch tweak already running", { variant: "info", duration: 2500 });
            return;
        }
        if (datasetType === "seg") {
            setSamStatus("Batch tweak is only available in bbox mode.", { variant: "warn", duration: 3000 });
            return;
        }
        if (!currentImage || !currentImage.name) {
            setSamStatus("Load an image before batch tweaking", { variant: "warn", duration: 3000 });
            return;
        }
        if (!currentClass) {
            setSamStatus("Select a class before batch tweaking", { variant: "warn", duration: 3000 });
            return;
        }
        if (!samMode) {
            setSamStatus("Enable SAM mode to batch tweak", { variant: "warn", duration: 3000 });
            return;
        }
        const bucket = (bboxes[currentImage.name] && bboxes[currentImage.name][currentClass]) || [];
        if (!bucket.length) {
            setSamStatus("No bboxes available for this class", { variant: "warn", duration: 3000 });
            return;
        }
        batchTweakRunning = true;
        if (batchTweakElements.confirm) {
            batchTweakElements.confirm.disabled = true;
        }
        setSamStatus(`Tweaking ${bucket.length} ${currentClass} bbox${bucket.length === 1 ? "" : "es"}…`, { variant: "info", duration: 0 });
        let successCount = 0;
        try {
            for (const bbox of bucket) {
                const ok = await runMagicTweakForBbox(bbox, { updateSelection: false });
                if (ok) {
                    successCount += 1;
                }
            }
            setSamStatus(`Tweaked ${successCount}/${bucket.length} ${currentClass} bbox${bucket.length === 1 ? "" : "es"}.`, { variant: "success", duration: 3500 });
            setBboxMarkedState();
            if (currentBbox) {
                updateBboxAfterTransform();
            }
        } catch (error) {
            console.error("Batch tweak failed", error);
            setSamStatus(`Batch tweak failed: ${error.message || error}`, { variant: "error", duration: 5000 });
        } finally {
            batchTweakRunning = false;
            if (batchTweakElements.confirm) {
                batchTweakElements.confirm.disabled = false;
            }
        }
    }

    const moveBbox = () => {
        if (mouse.shiftKeyActive || mouse.shiftSelectHit || mouse.shiftSelectDrag) {
            return;
        }
        if (mouse.buttonL && currentBbox) {
            const bx = currentBbox.bbox;
            const endX = bx.x + bx.width;
            const endY = bx.y + bx.height;
            if (
                mouse.startRealX >= bx.x + edgeSize && mouse.startRealX <= endX - edgeSize &&
                mouse.startRealY >= bx.y + edgeSize && mouse.startRealY <= endY - edgeSize
            ) {
                currentBbox.moving = true;
            }
            if (currentBbox.moving) {
                bx.x = currentBbox.originalX + (mouse.realX - mouse.startRealX);
                bx.y = currentBbox.originalY + (mouse.realY - mouse.startRealY);
            }
        }
    };

    const resizeBbox = () => {
        if (mouse.shiftKeyActive || mouse.shiftSelectHit || mouse.shiftSelectDrag) {
            return;
        }
        if (mouse.buttonL && currentBbox) {
            const bx = currentBbox.bbox;
            const tlx = bx.x;
            const tly = bx.y;
            const brx = bx.x + bx.width;
            const bry = bx.y + bx.height;

            if (nearCorner(mouse.startRealX, mouse.startRealY, tlx, tly)) {
                currentBbox.resizing = "topLeft";
            } else if (nearCorner(mouse.startRealX, mouse.startRealY, tlx, bry)) {
                currentBbox.resizing = "bottomLeft";
            } else if (nearCorner(mouse.startRealX, mouse.startRealY, brx, tly)) {
                currentBbox.resizing = "topRight";
            } else if (nearCorner(mouse.startRealX, mouse.startRealY, brx, bry)) {
                currentBbox.resizing = "bottomRight";
            }

            if (currentBbox.resizing === "topLeft") {
                bx.x = mouse.realX;
                bx.y = mouse.realY;
                bx.width = currentBbox.originalX + currentBbox.originalWidth - mouse.realX;
                bx.height = currentBbox.originalY + currentBbox.originalHeight - mouse.realY;
            }
            else if (currentBbox.resizing === "bottomLeft") {
                bx.x = mouse.realX;
                bx.y = mouse.realY - (mouse.realY - currentBbox.originalY);
                bx.width = currentBbox.originalX + currentBbox.originalWidth - mouse.realX;
                bx.height = mouse.realY - currentBbox.originalY;
            }
            else if (currentBbox.resizing === "topRight") {
                bx.x = mouse.realX - (mouse.realX - currentBbox.originalX);
                bx.y = mouse.realY;
                bx.width = mouse.realX - currentBbox.originalX;
                bx.height = currentBbox.originalY + currentBbox.originalHeight - mouse.realY;
            }
            else if (currentBbox.resizing === "bottomRight") {
                bx.x = mouse.realX - (mouse.realX - currentBbox.originalX);
                bx.y = mouse.realY - (mouse.realY - currentBbox.originalY);
                bx.width = mouse.realX - currentBbox.originalX;
                bx.height = mouse.realY - currentBbox.originalY;
            }
        }
    };

    function nearCorner(px, py, cx, cy) {
        return (px >= (cx - edgeSize) && px <= (cx + edgeSize) &&
                py >= (cy - edgeSize) && py <= (cy + edgeSize));
    }

    const changeCursorByLocation = () => {
        if (!currentImage) return;
        document.body.style.cursor = "default";
        const currentBxs = bboxes[currentImage.name];
        for (let className in currentBxs) {
            for (let bx of currentBxs[className]) {
                const endX = bx.x + bx.width;
                const endY = bx.y + bx.height;
                if (mouse.realX >= (bx.x + edgeSize) && mouse.realX <= (endX - edgeSize) &&
                    mouse.realY >= (bx.y + edgeSize) && mouse.realY <= (endY - edgeSize)) {
                    document.body.style.cursor = "pointer";
                    break;
                }
            }
        }
        if (currentBbox) {
            const bx = currentBbox.bbox;
            const brx = bx.x + bx.width;
            const bry = bx.y + bx.height;
            if (mouse.realX >= bx.x + edgeSize && mouse.realX <= brx - edgeSize &&
                mouse.realY >= bx.y + edgeSize && mouse.realY <= bry - edgeSize) {
                document.body.style.cursor = "move";
            }
        }
    };

    const panImage = (xx, yy) => {
        if (mouse.buttonR) {
            canvasX -= mouse.realX - xx;
            canvasY -= mouse.realY - yy;
            mouse.realX = zoomXInv(mouse.x);
            mouse.realY = zoomYInv(mouse.y);
        }
    };

    function zoom(n) { return Math.floor(n * scale); }
    function zoomX(n) { return Math.floor((n - canvasX) * scale + screenX); }
    function zoomY(n) { return Math.floor((n - canvasY) * scale + screenY); }
    function zoomXInv(n) { return Math.floor((n - screenX) / scale + canvasX); }
    function zoomYInv(n) { return Math.floor((n - screenY) / scale + canvasY); }

    /******************************************************
     * listenImageLoad
     * We still do one pass for each file to get .width, .height
     * But do NOT store big .object for each file (to save memory).
     ******************************************************/
    const readImageDimensions = async (file) => {
        if (window.createImageBitmap) {
            try {
                const bitmap = await createImageBitmap(file);
                const width = bitmap.width;
                const height = bitmap.height;
                if (typeof bitmap.close === "function") {
                    bitmap.close();
                }
                return { width, height };
            } catch (err) {
                console.warn("createImageBitmap failed", err);
            }
        }
        return new Promise((resolve) => {
            const url = URL.createObjectURL(file);
            const tempImg = new Image();
            tempImg.onload = () => {
                const width = tempImg.width;
                const height = tempImg.height;
                URL.revokeObjectURL(url);
                resolve({ width, height });
            };
            tempImg.onerror = () => {
                URL.revokeObjectURL(url);
                resolve({ width: 0, height: 0 });
            };
            tempImg.src = url;
        });
    };

    const listenImageLoad = () => {
        const imagesInput = document.getElementById("images");
        if (!imagesInput) {
            return;
        }
        imagesInput.addEventListener("change", async (event) => {
            const imageList = document.getElementById("imageList");
            if (!imageList) {
                setSamStatus("Image list element is missing.", { variant: "error", duration: 5000 });
                imagesInput.value = "";
                return;
            }

            const files = event.target.files;
            if (!files || files.length === 0) {
                imagesInput.value = "";
                return;
            }

            if (imageLoadInProgress && imageLoadPromise) {
                await waitForImageLoadCompletion();
            }

            imageLoadInProgress = true;
            const loadPromise = ingestImageFiles(files, imageList, imagesInput);
            imageLoadPromise = loadPromise;
            try {
                await loadPromise;
            } finally {
                if (imageLoadPromise === loadPromise) {
                    imageLoadPromise = null;
                }
                imageLoadInProgress = false;
            }
        });
    };

    async function waitForImageLoadCompletion() {
        if (imageLoadInProgress && imageLoadPromise) {
            try {
                await imageLoadPromise;
            } catch (error) {
                console.debug("Image load completion wait failed", error);
            }
        }
    }

    async function ingestImageFiles(files, imageList, imagesInput) {
        resetImageList();
        const selectedFiles = Array.from(files || []);
        const supportedFiles = selectedFiles.filter((file) => {
            const parts = file.name.split(".");
            const ext = parts[parts.length - 1];
            return extensions.indexOf(ext) !== -1;
        });
        const total = selectedFiles.length;
        document.body.style.cursor = "wait";
        const loadingLabel = `Loading ${total} image${total === 1 ? "" : "s"}… please wait`;
        setSamStatus(loadingLabel, { variant: "info", duration: 0 });
        let fileCount = 0;
        const YIELD_EVERY = 75;

        if (supportedFiles.length > 0) {
            startIngestProgress({ phase: "images", total: supportedFiles.length });
            showBackgroundLoadModal("Images are still loading in the background. You can continue once the counter finishes.");
        }

        try {
            for (let i = 0; i < supportedFiles.length; i++) {
                const file = supportedFiles[i];
                images[file.name] = {
                    meta: file,
                    index: fileCount,
                    width: 0,
                    height: 0,
                    object: undefined,
                };
                fileCount++;
                const option = document.createElement("option");
                option.value = file.name;
                option.text = file.name;
                if (fileCount === 1) {
                    option.selected = true;
                }
                imageList.appendChild(option);

                try {
                    const dim = await readImageDimensions(file);
                    images[file.name].width = dim.width;
                    images[file.name].height = dim.height;
                } catch (error) {
                    console.debug("Failed to read image dimensions", file.name, error);
                }

                incrementIngestProgress();

                if (fileCount % YIELD_EVERY === 0) {
                    await yieldToDom(0);
                }
            }
        } finally {
            document.body.style.cursor = "default";
            if (supportedFiles.length > 0) {
                stopIngestProgress();
                hideBackgroundLoadModal();
            }
        }

        if (fileCount === 0) {
            setSamStatus("No supported image files were selected.", { variant: "warn", duration: 5000 });
            imagesInput.value = "";
            return;
        }

        const firstName = getOptionImageName(imageList.options[0]);
        if (!images[firstName]) {
            setSamStatus(`Failed to stage image data for ${firstName}.`, { variant: "error", duration: 6000 });
            imagesInput.value = "";
            return;
        }
        setCurrentImage(images[firstName]);

        if (Object.keys(classes).length > 0) {
            setBboxImportEnabled(true);
        }

        setSamStatus(`Loaded ${fileCount} image${fileCount === 1 ? "" : "s"}.`, { variant: "success", duration: 3000 });
        imagesInput.value = "";
    }

    const resetImageList = () => {
        document.getElementById("imageList").innerHTML = "";
        images = {};
        bboxes = {};
        textLabels = {};
        textLabelRecords = [];
        qwenCaptionBatchActive = false;
        qwenCaptionBatchCancel = false;
        currentImage = null;
        if (typeof refreshSam3CascadeControls === "function") {
            refreshSam3CascadeControls();
        }
        samPreloadLastKey = null;
        cancelSamPreload();
        samTokenCache.clear();
        slotLoadingIndicators.clear();
        slotPreloadPromises.clear();
        latestSlotStatuses = [];
        applySlotStatusClasses();
        updateSlotHighlights([]);
        setBboxImportEnabled(false);
        cancelAllSamJobs({ reason: "image reset", announce: false });
        cancelPendingMultiPoint({ clearMarkers: true, removePendingBbox: true });
    };

    function setCurrentImage(image) {
        if (!image) return;
        const previousImageName = currentImage ? currentImage.name : null;
        const cancellation = cancelAllSamJobs({ reason: "image switch", imageName: previousImageName, announce: false });
        cancelPendingMultiPoint({ clearMarkers: true, removePendingBbox: true });
        clearSelectedBboxes();
        const pendingImageName = image?.meta?.name || image?.name || null;
        if (previousImageName) {
            const preserveImages = pendingImageName ? [pendingImageName] : null;
            cancelSamPreload({ preserveImages });
        }
        const hasActivePreload = pendingImageName
            ? (slotPreloadPromises.has(pendingImageName) || isImageCurrentlyLoading(pendingImageName))
            : false;
        if (samPreloadEnabled && pendingImageName) {
            const statusLabel = hasActivePreload ? "Continuing SAM preload" : "Preparing SAM preload";
            setSamStatus(`${statusLabel}: ${pendingImageName}`, { variant: "info", duration: 0 });
            showSamPreloadProgress();
        }
        const loadVersion = (image._loadVersion = (image._loadVersion || 0) + 1);
        if (resetCanvasOnChange) {
            resetCanvasPlacement();
        }
        const messagePrefix = cancellation.message;
        if (!image.object) {
            const reader = new FileReader();
            document.body.style.cursor = "wait";
            reader.onload = () => {
                if (image._loadVersion !== loadVersion) {
                    return;
                }
                const dataUrl = typeof reader.result === "string" ? reader.result : "";
                const imageObject = new Image();
                imageObject.onload = () => {
                    if (image._loadVersion !== loadVersion) {
                        return;
                    }
                    image.object = imageObject;
                    image.dataUrl = dataUrl;
                    const naturalWidth = imageObject.naturalWidth || imageObject.width || image.width || 0;
                    const naturalHeight = imageObject.naturalHeight || imageObject.height || image.height || 0;
                    image.width = naturalWidth;
                    image.height = naturalHeight;
                    currentImage = {
                        name: image.meta.name,
                        object: imageObject,
                        width: naturalWidth,
                        height: naturalHeight,
                        dataUrl,
                    };
                    document.body.style.cursor = "default";
                    if (fittedZoom) {
                        fitZoom(currentImage);
                    }
                    document.getElementById("imageInformation").innerHTML =
                        `${naturalWidth}x${naturalHeight}, ${formatBytes(image.meta.size)}`;
                    if (!bboxes[currentImage.name]) {
                        bboxes[currentImage.name] = {};
                    }
                    prepareSamForCurrentImage({ messagePrefix }).catch((err) => {
                        console.debug("prepareSamForCurrentImage failed", err);
                    });
                    if (typeof refreshSam3CascadeControls === "function") {
                        refreshSam3CascadeControls();
                    }
                };
                imageObject.src = dataUrl;
            };
            reader.readAsDataURL(image.meta);
        }
        else {
            if (image._loadVersion !== loadVersion) {
                return;
            }
            const naturalWidth = image.width || image.object?.naturalWidth || image.object?.width || 0;
            const naturalHeight = image.height || image.object?.naturalHeight || image.object?.height || 0;
            image.width = naturalWidth;
            image.height = naturalHeight;
            currentImage = {
                name: image.meta.name,
                object: image.object,
                width: naturalWidth,
                height: naturalHeight,
                dataUrl: image.dataUrl || null,
            };
            if (fittedZoom) {
                fitZoom(currentImage);
            }
            document.getElementById("imageInformation").innerHTML =
                `${naturalWidth}x${naturalHeight}, ${formatBytes(image.meta.size)}`;
            if (!bboxes[currentImage.name]) {
                bboxes[currentImage.name] = {};
            }
            prepareSamForCurrentImage({ messagePrefix, immediate: true }).catch((err) => {
                console.debug("prepareSamForCurrentImage failed", err);
            });
            if (typeof refreshSam3CascadeControls === "function") {
                refreshSam3CascadeControls();
            }
        }
        if (currentBbox !== null) {
            currentBbox.bbox.marked = false;
            currentBbox = null;
        }
        if (currentImage?.name) {
            syncImageSelectionToName(currentImage.name, { ensureVisible: true });
        }
        if (!samPreloadEnabled && messagePrefix) {
            setSamStatus(messagePrefix, { variant: "warn", duration: 5000 });
        }
    }

    const fitZoom = (image, options = {}) => {
        if (!image) {
            return;
        }
        ensureCanvasDimensions();
        const { preservePan = false } = options;
        const imgWidth = Math.max(1, image.width || image.object?.naturalWidth || image.object?.width || 1);
        const imgHeight = Math.max(1, image.height || image.object?.naturalHeight || image.object?.height || 1);
        const canvasWidth = Math.max(1, canvas?.width || canvas?.element?.width || canvas?.element?.clientWidth || window.innerWidth);
        const canvasHeight = Math.max(1, canvas?.height || canvas?.element?.height || canvas?.element?.clientHeight || (window.innerHeight - 20));
        const nextScale = Math.min(canvasWidth / imgWidth, canvasHeight / imgHeight);
        scale = Math.min(Math.max(nextScale, minZoom), maxZoom);
        if (!preservePan) {
            canvasX = 0;
            canvasY = 0;
            screenX = 0;
            screenY = 0;
        }
    };

    const listenImageSelect = () => {
        const imageList = document.getElementById("imageList");
        imageList.addEventListener("change", () => {
            imageListIndex = imageList.selectedIndex;
            const name = getOptionImageName(imageList.options[imageListIndex]);
            setCurrentImage(images[name]);
        });
    };

    const listenClassLoad = () => {
        const classesElement = document.getElementById("classes");
        if (!classesElement) {
            return;
        }
        const classesButton = document.getElementById("classesSelect");
        classesElement.addEventListener("click", () => {
            classesElement.value = null;
        });
        classesElement.addEventListener("change", (event) => {
            const files = event.target.files;
            if (files.length > 0) {
                resetClassList();
                const nameParts = files[0].name.split(".");
                if (nameParts[nameParts.length - 1] === "txt") {
                    const reader = new FileReader();
                    reader.addEventListener("load", () => {
                        const lines = reader.result;
                        const rows = lines.split(/[\r\n]+/);
                        if (rows.length > 0) {
                            const classList = document.getElementById("classList");
                            loadedClassList = [];
                            for (let i = 0; i < rows.length; i++) {
                                rows[i] = rows[i].trim();
                                if (rows[i] !== "") {
                                    classes[rows[i]] = i;
                                    loadedClassList.push(rows[i]);
                                    const option = document.createElement("option");
                                    option.value = i;
                                    option.innerHTML = rows[i];
                                    if (i === 0) {
                                        option.selected = true;
                                        currentClass = rows[i];
                                    }
                                    classList.appendChild(option);
                                }
                            }
                            setCurrentClass();
                            updateQwenClassOptions({ resetOverride: true });
                            updateSam3ClassOptions({ resetOverride: true });
                            if (Object.keys(images).length > 0) {
                                setBboxImportEnabled(true);
                                document.getElementById("restoreBboxes").disabled = false;
                            }
                        }
                    });
                    reader.readAsText(files[0]);
                }
            }
            classesElement.value = "";
        });
    };

    const resetClassList = () => {
        document.getElementById("classList").innerHTML = "";
        classes = {};
        currentClass = null;
        loadedClassList = [];
        clearMultiPointAnnotations();
        updateQwenClassOptions({ resetOverride: true });
        updateSam3ClassOptions({ resetOverride: true });
    };

    const setCurrentClass = () => {
        const classList = document.getElementById("classList");
        currentClass = classList.options[classList.selectedIndex].text;
        if (currentBbox !== null) {
            currentBbox.bbox.marked = false;
            currentBbox = null;
        }
        clearMultiPointAnnotations();
        syncQwenClassToCurrent();
        updateSam3ClassOptions({ preserveSelection: true });
    };

    const listenClassSelect = () => {
        const classList = document.getElementById("classList");
        classList.addEventListener("change", () => {
            classListIndex = classList.selectedIndex;
            setCurrentClass();
        });
    };

    function readFileAsTextPromise(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error || new Error("Failed to read file"));
            reader.readAsText(file);
        });
    }

    function readFileAsArrayBufferPromise(file) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => resolve(reader.result);
            reader.onerror = () => reject(reader.error || new Error("Failed to read file"));
            reader.readAsArrayBuffer(file);
        });
    }

    async function processBboxFile(file) {
        const rawExtension = file.name.split(".").pop() || "";
        const extension = rawExtension.toLowerCase();
        if (extension === "txt" || extension === "xml" || extension === "json") {
            const text = await readFileAsTextPromise(file);
            storeBbox(file.name, text);
            incrementIngestProgress();
            return;
        }
        const buffer = await readFileAsArrayBufferPromise(file);
        const zip = await (typeof JSZip.loadAsync === "function"
            ? JSZip.loadAsync(buffer)
            : new JSZip().loadAsync(buffer));
        const entries = Object.values(zip.files || {}).filter((entry) => entry && !entry.dir);
        if (entries.length === 0) {
            incrementIngestProgress();
            return;
        }
        if (entries.length > 1) {
            adjustIngestTotal(entries.length - 1);
        }
        for (const entry of entries) {
            const text = await entry.async("string");
            storeBbox(entry.name, text);
            incrementIngestProgress();
        }
    }

    const listenBboxLoad = () => {
        const fileInput = document.getElementById("bboxes");
        const folderInput = document.getElementById("bboxesFolder");
        const fileButton = document.getElementById("bboxesSelect");
        const folderButton = document.getElementById("bboxesSelectFolder");
        registerFileLabel(fileButton, fileInput);
        registerFileLabel(folderButton, folderInput);
        setupBboxInputListeners(fileInput);
        setupBboxInputListeners(folderInput);
    };

    function setupBboxInputListeners(input) {
        if (!input) {
            return;
        }
        input.addEventListener("click", () => {
            input.value = "";
        });
        input.addEventListener("change", async (event) => {
            if (imageLoadInProgress) {
                setSamStatus("Still loading images — please wait before importing bboxes.", { variant: "info", duration: 3000 });
                await waitForImageLoadCompletion();
            }
            const files = event.target.files;
            if (files && files.length > 0) {
                resetBboxes();
                bboxImportCounterActive = true;
                startIngestProgress({ phase: "bboxes", total: files.length, extraLabel: "UUIDs" });
                try {
                    const tasks = [];
                    for (let i = 0; i < files.length; i++) {
                        tasks.push(
                            processBboxFile(files[i]).catch((err) => {
                                console.error("Failed to import bbox file", files[i]?.name, err);
                                setSamStatus(`Failed to import ${files[i]?.name}: ${err.message || err}`, { variant: "error", duration: 5000 });
                            })
                        );
                    }
                    await Promise.all(tasks);
                } finally {
                    bboxImportCounterActive = false;
                    stopIngestProgress();
                }
            }
            input.value = "";
        });
    }

    const resetBboxes = () => {
        bboxes = {};
        textLabels = {};
        textLabelRecords = [];
        setDatasetType("bbox");
    };

    const storeBbox = (filename, text) => {
        // same storeBbox logic you had before
        let image = null;
        let bbox = null;
        const rawExtension = filename.split(".").pop() || "";
        const extension = rawExtension.toLowerCase();
        const baseName = rawExtension ? filename.slice(0, -(rawExtension.length + 1)) : filename;
        if (extension === "txt" || extension === "xml") {
            for (let i = 0; i < extensions.length; i++) {
                const imageName = `${baseName}.${extensions[i]}`;
                if (typeof images[imageName] !== "undefined") {
                    image = images[imageName];
                    if (typeof bboxes[imageName] === "undefined") {
                        bboxes[imageName] = {};
                    }
                    bbox = bboxes[imageName];
                    if (extension === "txt") {
                        const rows = text.split(/[\r\n]+/);
                        for (let i = 0; i < rows.length; i++) {
                            const cols = rows[i].trim().split(/\s+/).filter(Boolean);
                            if (cols.length < 5) continue;
                            const clsIdx = parseInt(cols[0], 10);
                            let className = null;
                            for (const name in classes) {
                                if (classes[name] === clsIdx) {
                                    className = name;
                                    break;
                                }
                            }
                            if (!className) continue;
                            if (typeof bbox[className] === "undefined") {
                                bbox[className] = [];
                            }
                            // YOLO-seg: class + polygon coords (x y ...), YOLO-bbox: class cx cy w h
                            if (cols.length >= 7) {
                                const pts = [];
                                for (let j = 1; j + 1 < cols.length; j += 2) {
                                    const px = parseFloat(cols[j]) * image.width;
                                    const py = parseFloat(cols[j + 1]) * image.height;
                                    if (Number.isFinite(px) && Number.isFinite(py)) {
                                        pts.push({ x: px, y: py });
                                    }
                                }
                                if (pts.length >= 3) {
                                    const xs = pts.map((p) => p.x);
                                    const ys = pts.map((p) => p.y);
                                    const minX = Math.max(0, Math.min(...xs));
                                    const maxX = Math.min(image.width, Math.max(...xs));
                                    const minY = Math.max(0, Math.min(...ys));
                                    const maxY = Math.min(image.height, Math.max(...ys));
                                    const bboxRecord = {
                                        type: "polygon",
                                        points: pts,
                                        x: minX,
                                        y: minY,
                                        width: Math.max(0, maxX - minX),
                                        height: Math.max(0, maxY - minY),
                                        marked: false,
                                        class: className
                                    };
                                    stampBboxCreation(bboxRecord);
                                    bbox[className].push(bboxRecord);
                                    setDatasetType("seg");
                                    noteImportedBbox();
                                    continue;
                                }
                            }
                            // Fallback to bbox
                            const cx = parseFloat(cols[1]);
                            const cy = parseFloat(cols[2]);
                            const wNorm = parseFloat(cols[3]);
                            const hNorm = parseFloat(cols[4]);
                            const width = wNorm * image.width;
                            const x = cx * image.width - width * 0.5;
                            const height = hNorm * image.height;
                            const y = cy * image.height - height * 0.5;
                            const bboxRecord = {
                                type: "bbox",
                                x: Math.floor(x),
                                y: Math.floor(y),
                                width: Math.floor(width),
                                height: Math.floor(height),
                                marked: false,
                                class: className
                            };
                            stampBboxCreation(bboxRecord);
                            bbox[className].push(bboxRecord);
                            noteImportedBbox();
                        }
                    } else if (extension === "xml") {
                        const parser = new DOMParser();
                        const xmlDoc = parser.parseFromString(text, "text/xml");
                        const objects = xmlDoc.getElementsByTagName("object");
                        for (let i = 0; i < objects.length; i++) {
                            const objectName = objects[i].getElementsByTagName("name")[0].childNodes[0].nodeValue;
                            for (let className in classes) {
                                if (className === objectName) {
                                    if (typeof bbox[className] === "undefined") {
                                        bbox[className] = [];
                                    }
                                    const bndBox = objects[i].getElementsByTagName("bndbox")[0];
                                    const bndBoxX = bndBox.getElementsByTagName("xmin")[0].childNodes[0].nodeValue;
                                    const bndBoxY = bndBox.getElementsByTagName("ymin")[0].childNodes[0].nodeValue;
                                    const bndBoxMaxX = bndBox.getElementsByTagName("xmax")[0].childNodes[0].nodeValue;
                                    const bndBoxMaxY = bndBox.getElementsByTagName("ymax")[0].childNodes[0].nodeValue;
                                    const bboxRecord = {
                                        type: "bbox",
                                        x: parseInt(bndBoxX),
                                        y: parseInt(bndBoxY),
                                        width: parseInt(bndBoxMaxX) - parseInt(bndBoxX),
                                        height: parseInt(bndBoxMaxY) - parseInt(bndBoxY),
                                        marked: false,
                                        class: className
                                    };
                                    stampBboxCreation(bboxRecord);
                                    bbox[className].push(bboxRecord);
                                    noteImportedBbox();
                                    break;
                                }
                            }
                        }
                    }
                }
            }
        } else {
            const json = JSON.parse(text);
            for (let i = 0; i < json.annotations.length; i++) {
                let imageName = null;
                let categoryName = null;
                for (let j = 0; j < json.images.length; j++) {
                    if (json.annotations[i].image_id === json.images[j].id) {
                        imageName = json.images[j].file_name;
                        if (typeof images[imageName] !== "undefined") {
                            image = images[imageName];
                            if (typeof bboxes[imageName] === "undefined") {
                                bboxes[imageName] = {};
                            }
                            bbox = bboxes[imageName];
                            break;
                        }
                    }
                }
                for (let j = 0; j < json.categories.length; j++) {
                    if (json.annotations[i].category_id === json.categories[j].id) {
                        categoryName = json.categories[j].name;
                        break;
                    }
                }
                for (let className in classes) {
                    if (className === categoryName) {
                        if (typeof bbox[className] === "undefined") {
                            bbox[className] = [];
                        }
                        const bboxX = json.annotations[i].bbox[0];
                        const bboxY = json.annotations[i].bbox[1];
                        const bboxWidth = json.annotations[i].bbox[2];
                        const bboxHeight = json.annotations[i].bbox[3];
                        const bboxRecord = {
                            type: "bbox",
                            x: bboxX,
                            y: bboxY,
                            width: bboxWidth,
                            height: bboxHeight,
                            marked: false,
                            class: className
                        };
                        stampBboxCreation(bboxRecord);
                        bbox[className].push(bboxRecord);
                        noteImportedBbox();
                        break;
                    }
                }
            }
        }
    };

    function summarizeGeometry() {
        let polygonCount = 0;
        let bboxCount = 0;
        Object.values(bboxes).forEach((classBuckets) => {
            Object.values(classBuckets || {}).forEach((items) => {
                (items || []).forEach((ann) => {
                    if (ann && ann.type === "polygon") {
                        polygonCount += 1;
                    } else {
                        bboxCount += 1;
                    }
                });
            });
        });
        return { polygonCount, bboxCount };
    }

    function validateGeometryForSave() {
        const { polygonCount, bboxCount } = summarizeGeometry();
        if (datasetType === "seg" && bboxCount > 0) {
            return { ok: false, message: "This dataset is in polygon mode but contains bboxes. Remove or convert them before saving." };
        }
        if (datasetType === "bbox" && polygonCount > 0) {
            return { ok: false, message: "This dataset is in bbox mode but contains polygons. Switch to seg mode or remove polygons before saving." };
        }
        return { ok: true, polygonCount, bboxCount };
    }

    const listenBboxSave = () => {
        document.getElementById("saveBboxes").addEventListener("click", () => {
            const validation = validateGeometryForSave();
            if (!validation.ok) {
                alert(validation.message);
                return;
            }
            const zip = new JSZip();
            const textFolder = zip.folder("text_labels");
            for (let imageName in bboxes) {
                const image = images[imageName];
                if (!image) continue;
                const name = imageName.split(".");
                name[name.length - 1] = "txt";
                const result = [];
                for (let className in bboxes[imageName]) {
                    for (let i = 0; i < bboxes[imageName][className].length; i++) {
                        const bbox = bboxes[imageName][className][i];
                        const classIdx = classes[className];
                        if (datasetType === "seg" && Array.isArray(bbox.points) && bbox.points.length >= 3) {
                            const coords = bbox.points
                                .map((pt) => {
                                    const nx = pt.x / image.width;
                                    const ny = pt.y / image.height;
                                    return `${nx} ${ny}`;
                                })
                                .join(" ");
                            result.push(`${classIdx} ${coords}`);
                        } else {
                            const x = (bbox.x + bbox.width / 2) / image.width;
                            const y = (bbox.y + bbox.height / 2) / image.height;
                            const w = bbox.width / image.width;
                            const h = bbox.height / image.height;
                            result.push(`${classIdx} ${x} ${y} ${w} ${h}`);
                        }
                    }
                }
                zip.file(name.join("."), result.join("\n"));
                const textLabel = textLabels?.[imageName];
                if (textFolder && textLabel) {
                    textFolder.file(name.join("."), String(textLabel).trim());
                }
            }
            if (textFolder && textLabels) {
                Object.keys(textLabels).forEach((imageName) => {
                    if (bboxes[imageName]) {
                        return;
                    }
                    const name = imageName.split(".");
                    name[name.length - 1] = "txt";
                    textFolder.file(name.join("."), String(textLabels[imageName]).trim());
                });
            }
            if (textFolder && Array.isArray(textLabelRecords) && textLabelRecords.length > 0) {
                const jsonl = textLabelRecords.map((record) => JSON.stringify(record)).join("\n");
                textFolder.file("captions.jsonl", jsonl);
            }
            zip.generateAsync({ type: "blob" })
                .then((blob) => {
                    saveAs(blob, "bboxes_yolo.zip");
                });
        });
    };

    const listenKeyboard = () => {
        const imageList = document.getElementById("imageList");
        const classList = document.getElementById("classList");
        let modeSnapshot = null;

        document.addEventListener("keydown", (event) => {
            if (activeTab !== TAB_LABELING) {
                return;
            }
            const targetTag = (event.target?.tagName || "").toLowerCase();
            const inputType = (event.target?.getAttribute && event.target.getAttribute("type")) ? event.target.getAttribute("type").toLowerCase() : "";
            const isTextualInput = targetTag === "textarea"
                || (targetTag === "input" && !["checkbox", "radio", "button", "range", "color"].includes(inputType));
            if (isTextualInput || event.target?.isContentEditable) {
                return;
            }
            const key = event.keyCode || event.charCode;

            if (datasetType === "seg" && (key === 27 || event.key === "Escape")) {
                polygonDraft = null;
                polygonDrag = null;
                currentBbox = null;
                event.preventDefault();
                return;
            }

            if (!event.repeat && !event.ctrlKey && !event.metaKey && !event.altKey && (key === 80 || event.key === "p" || event.key === "P")) {
                if (datasetType !== "seg") {
                    setDatasetType("seg");
                    setPolygonDrawEnabled(true);
                    showShortcutToast("polygon_toggle", "Polygon draw: ON (seg mode).");
                    event.preventDefault();
                    return;
                }
                setPolygonDrawEnabled(!polygonDrawEnabled);
                showShortcutToast(
                    "polygon_toggle",
                    `Polygon draw: ${polygonDrawEnabled ? "ON" : "OFF"}.`
                );
                event.preventDefault();
                return;
            }

            if (!event.repeat && !event.ctrlKey && !event.metaKey && !event.altKey && (key === 90 || event.key === "z" || event.key === "Z")) {
                if (!modeSnapshot) {
                    modeSnapshot = {
                        auto: autoMode,
                        sam: samMode,
                        point: pointMode,
                        multi: multiPointMode,
                    };
                    updateSamModeState(false, { preservePoints: true });
                    updateAutoModeState(false);
                    showShortcutToast("hold_z", "Hold Z: SAM/Auto paused.");
                }
                event.preventDefault();
                return;
            }

            if (!event.repeat && !event.ctrlKey && !event.metaKey && !event.altKey && (key === 82 || event.key === "r" || event.key === "R")) {
                mouse.yoloKeyActive = true;
                const regionModeLabel = getRegionDetectorMode() === "rfdetr" ? "RF-DETR" : "YOLO";
                showShortcutToast(
                    "yolo_region",
                    `${regionModeLabel} region mode: drag a box to scan (zoom in for more detail).`,
                    { durationMs: 4000, cooldownMs: 2000 }
                );
                event.preventDefault();
                return;
            }

            if (!event.repeat && !event.ctrlKey && !event.metaKey && !event.altKey && (key === 88 || event.key === "x" || event.key === "X")) {
                event.preventDefault();
                handleXHotkeyPress();
                showShortcutToast("magic_tweak", "Magic tweak requested.");
                return;
            }

            const plainDeleteHotkey = !event.repeat && !event.ctrlKey && !event.metaKey && !event.altKey
                && (key === 87 || event.key === "w" || event.key === "W");
            if (key === 8 || (key === 46 && event.metaKey === true) || plainDeleteHotkey) {
                if (selectedBboxes.size) {
                    const removed = deleteSelectedBboxes();
                    if (removed > 0) {
                        showShortcutToast("delete_bbox", `Deleted ${removed} selection${removed === 1 ? "" : "s"}.`);
                        event.preventDefault();
                        return;
                    }
                }
                if (currentBbox !== null) {
                    bboxes[currentImage.name][currentBbox.bbox.class].splice(currentBbox.index, 1);
                    currentBbox = null;
                    document.body.style.cursor = "default";
                    showShortcutToast("delete_bbox", "Deleted 1 bbox.");
                }
                event.preventDefault();
            }
            if (!event.repeat && !event.ctrlKey && !event.metaKey && !event.altKey && (key === 81 || event.key === "q" || event.key === "Q")) {
                let removed = false;
                if (currentImage && bboxes[currentImage.name]) {
                    const latest = findLatestCreatedBbox(currentImage.name);
                    if (latest) {
                        const bucket = bboxes[currentImage.name][latest.className];
                        if (bucket) {
                            const spliceResult = bucket.splice(latest.index, 1);
                            if (bucket.length === 0) {
                                delete bboxes[currentImage.name][latest.className];
                            }
                            if (spliceResult.length > 0) {
                                removed = true;
                                if (currentBbox && currentBbox.bbox === spliceResult[0]) {
                                    currentBbox = null;
                                    document.body.style.cursor = "default";
                                }
                            }
                        }
                    }
                }
                if (removed) {
                    showShortcutToast("delete_latest", "Deleted latest bbox.");
                    event.preventDefault();
                }
            }
            // 'a' => toggle auto class
            if (key === 65 && !modeSnapshot) {
                updateAutoModeState(!autoMode);
                showShortcutToast("auto_toggle", `Auto-class: ${autoMode ? "ON" : "OFF"}.`);
                event.preventDefault();
            }
            // 's' => toggle SAM
            if (key === 83 && !modeSnapshot) {
                updateSamModeState(!samMode);
                showShortcutToast("sam_toggle", `SAM mode: ${samMode ? "ON" : "OFF"}.`);
                event.preventDefault();
            }
            // 'd' => toggle SAM point mode
            if (key === 68 && !modeSnapshot) {
                if (!pointMode) {
                    if (!samMode) {
                        updateSamModeState(true);
                    }
                    updatePointModeState(true);
                } else {
                    updatePointModeState(false);
                }
                showShortcutToast("sam_point_toggle", `SAM point: ${pointMode ? "ON" : "OFF"}.`);
                event.preventDefault();
            }
            // 'm' => toggle SAM multi-point mode
            if (key === 77 && !modeSnapshot) {
                if (!multiPointMode) {
                    if (!samMode) {
                        updateSamModeState(true);
                    }
                    updateMultiPointState(true);
                } else {
                    updateMultiPointState(false);
                }
                showShortcutToast("sam_multi_toggle", `SAM multi-point: ${multiPointMode ? "ON" : "OFF"}.`);
                event.preventDefault();
            }
            // '1' => SAM3 similarity (requires SAM3 predictor loaded for current image)
            if (!event.repeat && (key === 49 || event.key === "1") && !modeSnapshot) {
                triggerSam3SimilarityHotkey();
                showShortcutToast("sam3_similarity", "SAM3 similarity requested.");
                event.preventDefault();
                return;
            }
            // 'f' => add positive point
            if (!event.repeat && key === 70 && multiPointMode && !modeSnapshot) {
                addMultiPointAnnotation(1);
                showShortcutToast("multi_point_pos", "Multi-point: +positive.", { cooldownMs: 600 });
                event.preventDefault();
            }
            // 'g' => add negative point
            if (!event.repeat && key === 71 && multiPointMode && !modeSnapshot) {
                addMultiPointAnnotation(0);
                showShortcutToast("multi_point_neg", "Multi-point: +negative.", { cooldownMs: 600 });
                event.preventDefault();
            }
            // Enter => submit multi-point selection
            if (!event.repeat && key === 13 && multiPointMode && !modeSnapshot) {
                submitMultiPointSelection();
                showShortcutToast("multi_point_submit", "Multi-point submitted.");
                event.preventDefault();
                return;
            }
            if (key === 37) {
                if (imageList.length > 1) {
                    imageList.options[imageListIndex].selected = false;
                    if (imageListIndex === 0) {
                        imageListIndex = imageList.length - 1;
                    } else {
                        imageListIndex--;
                    }
                    imageList.options[imageListIndex].selected = true;
                    imageList.selectedIndex = imageListIndex;
                    const imageName = getOptionImageName(imageList.options[imageListIndex]);
                    if (imageName && images[imageName]) {
                        setCurrentImage(images[imageName]);
                    }
                    document.body.style.cursor = "default";
                }
                event.preventDefault();
            }
            if (key === 39) {
                if (imageList.length > 1) {
                    imageList.options[imageListIndex].selected = false;
                    if (imageListIndex === imageList.length - 1) {
                        imageListIndex = 0;
                    } else {
                        imageListIndex++;
                    }
                    imageList.options[imageListIndex].selected = true;
                    imageList.selectedIndex = imageListIndex;
                    const imageName = getOptionImageName(imageList.options[imageListIndex]);
                    if (imageName && images[imageName]) {
                        setCurrentImage(images[imageName]);
                    }
                    document.body.style.cursor = "default";
                }
                event.preventDefault();
            }
            if (key === 38) {
                if (classList.length > 1) {
                    classList.options[classListIndex].selected = false;
                    if (classListIndex === 0) {
                        classListIndex = classList.length - 1;
                    } else {
                        classListIndex--;
                    }
                    classList.options[classListIndex].selected = true;
                    classList.selectedIndex = classListIndex;
                    setCurrentClass();
                    showClassScrollIndicatorForList(classList, classListIndex);
                }
                event.preventDefault();
            }
            if (key === 40) {
                if (classList.length > 1) {
                    classList.options[classListIndex].selected = false;
                    if (classListIndex === classList.length - 1) {
                        classListIndex = 0;
                    } else {
                        classListIndex++;
                    }
                    classList.options[classListIndex].selected = true;
                    classList.selectedIndex = classListIndex;
                    setCurrentClass();
                    showClassScrollIndicatorForList(classList, classListIndex);
                }
                event.preventDefault();
            }
        });

        document.addEventListener("keyup", (event) => {
            const key = event.keyCode || event.charCode;
            if (key === 82 || event.key === "r" || event.key === "R") {
                mouse.yoloKeyActive = false;
            }
            if (activeTab !== TAB_LABELING) {
                return;
            }
            if (modeSnapshot && (key === 90 || event.key === "z" || event.key === "Z")) {
                const snapshot = modeSnapshot;
                modeSnapshot = null;
                updateSamModeState(snapshot.sam);
                updateAutoModeState(snapshot.auto);
                updatePointModeState(snapshot.point);
                updateMultiPointState(snapshot.multi);
                showShortcutToast("hold_z", "Z released: modes restored.", { cooldownMs: 800 });
                event.preventDefault();
            }
        });
    };

    async function handleMagicTweakHotkey() {
        if (magicTweakRunning) {
            return;
        }
        magicTweakRunning = true;
        try {
            await runMagicTweakForCurrentBbox();
        } finally {
            magicTweakRunning = false;
        }
    }

    const resetCanvasPlacement = () => {
        scale = defaultScale;
        canvasX = 0;
        canvasY = 0;
        screenX = 0;
        screenY = 0;
        mouse.x = 0;
        mouse.y = 0;
        mouse.realX = 0;
        mouse.realY = 0;
        mouse.buttonL = 0;
        mouse.buttonR = 0;
        mouse.startRealX = 0;
        mouse.startRealY = 0;
    };

    const listenImageSearch = () => {
        document.getElementById("imageSearch").addEventListener("input", (event) => {
            const value = event.target.value;
            for (let imageName in images) {
                if (imageName.indexOf(value) !== -1) {
                    document.getElementById("imageList").selectedIndex = images[imageName].index;
                    setCurrentImage(images[imageName]);
                    break;
                }
            }
        });
    };

    function yieldToDom(delayMs = 50) {
        return new Promise((resolve) => {
            requestAnimationFrame(() => {
                setTimeout(resolve, delayMs);
            });
        });
    }

    async function extractBase64ForImage(imgObj) {
        const offCanvas = document.createElement("canvas");
        offCanvas.width = imgObj.width;
        offCanvas.height = imgObj.height;
        const ctx = offCanvas.getContext("2d");
        ctx.drawImage(imgObj.object, 0, 0, imgObj.width, imgObj.height);
        const dataUrl = offCanvas.toDataURL("image/jpeg");
        return dataUrl.split(",")[1];
    }

        /****************************************************
     * listenImageCrop - single-image-at-a-time approach
     ****************************************************/
    async function listenImageCrop() {
      setupTabNavigation();
      const btn = document.getElementById("cropImages");
      btn.addEventListener("click", async () => {
        if (datasetType === "seg") {
          alert("Crop & Save is only available for bbox datasets.");
          return;
        }
        const imageNames = Object.keys(bboxes);
        if (!imageNames.length) {
          alert("No bounding boxes to crop.");
          return;
        }

        const progressModal = showProgressModal("Initializing crop job...");
        document.body.style.cursor = "wait";

        try {
          // 1) Start the server-side job
          let resp = await fetch(`${API_ROOT}/crop_zip_init`, { method: "POST" });
          if (!resp.ok) {
            throw new Error("crop_zip_init failed: " + resp.status);
          }
          const { jobId } = await resp.json();
          console.log("Got jobId:", jobId);

          // 2) Single-image loop
          let count = 0;
          for (const imgName of imageNames) {
            count++;
            progressModal.update(`Processing ${count} / ${imageNames.length}: ${imgName}`);

            const imgData = images[imgName];
            if (!imgData) continue;

            // Load image if not loaded
            if (!imgData.object) {
              await loadImageObject(imgData);
            }

            // Gather bounding boxes
            const rawBoxes = bboxes[imgName];
            if (!rawBoxes) {
              // No bboxes at all for this image
              imgData.object = null;
              await yieldToDom(10);
              continue;
            }

            // Flatten bounding boxes & clamp
            const allBbs = [];
            for (const className in rawBoxes) {
              rawBoxes[className].forEach(bbox => {
                const copy = { ...bbox };
                const valid = clampBbox(copy, imgData.width, imgData.height);
                if (valid) {
                  allBbs.push({
                    className, 
                    x: copy.x,
                    y: copy.y,
                    width: copy.width,
                    height: copy.height
                  });
                }
              });
            }
            if (!allBbs.length) {
              // no valid bounding boxes => skip
              console.log("No valid bounding boxes for", imgName, " => skipping");
              imgData.object = null;
              await yieldToDom(10);
              continue;
            }

            // Convert to base64
            const base64Img = await extractBase64ForImage(imgData);

            // 3) Send just this one image
            // If your server wants different keys, rename them here
            const body = {
              images: [
                {
                  image_base64: base64Img,
                  originalName: imgName,
                  bboxes: allBbs
                }
              ]
            };
            // Debug log
            console.log("Sending:", JSON.stringify(body, null, 2));

            resp = await fetch(`${API_ROOT}/crop_zip_chunk?jobId=${jobId}`, {
              method: "POST",
              headers: { "Content-Type": "application/json" },
              body: JSON.stringify(body)
            });
            if (!resp.ok) {
              throw new Error(`crop_zip_chunk failed: ${resp.status}`);
            }

            // free memory
            imgData.object = null;
            await yieldToDom(10);
          }

          // 4) Finalize
          progressModal.update("Finalizing crop_zip_finalize...");
          resp = await fetch(`${API_ROOT}/crop_zip_finalize?jobId=${jobId}`);
          if (!resp.ok) {
            throw new Error("crop_zip_finalize failed: " + resp.status);
          }
          const blob = await resp.blob();
          saveAs(blob, "crops.zip");
          alert("Done! crops.zip downloaded.");
        } catch (err) {
          console.error(err);
          alert("Crop & Save failed: " + err);
        } finally {
          progressModal.close();
          document.body.style.cursor = "default";
        }
      });
    }

    // Example clamp function
    function clampBbox(bbox, imgW, imgH) {
      // ensure x, y >= 0
      bbox.x = Math.max(0, bbox.x);
      bbox.y = Math.max(0, bbox.y);

      // ensure x + w <= imgW
      if (bbox.x > imgW) return false;
      if (bbox.y > imgH) return false;

      const maxW = imgW - bbox.x;
      const maxH = imgH - bbox.y;
      bbox.width = Math.min(bbox.width, maxW);
      bbox.height = Math.min(bbox.height, maxH);

      if (bbox.width <= 0 || bbox.height <= 0) return false;
      return true;
    }

    /**
     * Helper function to load an image from its File object (imgData.meta)
     * and store the resulting <img> in imgData.object.
     */
    function loadImageObject(imgData) {
        return new Promise((resolve, reject) => {
            const reader = new FileReader();
            reader.onload = () => {
                const im = new Image();
                im.onload = () => {
                    imgData.object = im;
                    resolve();
                };
                im.onerror = reject;
                im.src = reader.result;
            };
            reader.onerror = reject;
            reader.readAsDataURL(imgData.meta);
        });
    }

    function chunkArray(array, size) {
        const result = [];
        for (let i = 0; i < array.length; i += size) {
            result.push(array.slice(i, i + size));
        }
        return result;
    }

    // Enhanced showProgressModal that can update text
    function showProgressModal(initialText = "") {
        const overlay = document.createElement("div");
        overlay.style.position = "fixed";
        overlay.style.top = "0";
        overlay.style.left = "0";
        overlay.style.width = "100%";
        overlay.style.height = "100%";
        overlay.style.backgroundColor = "rgba(0, 0, 0, 0.75)";
        overlay.style.zIndex = "9999";
        overlay.style.display = "flex";
        overlay.style.alignItems = "center";
        overlay.style.justifyContent = "center";
        overlay.style.flexDirection = "column";

        const textDiv = document.createElement("div");
        textDiv.style.color = "#fff";
        textDiv.style.fontSize = "20px";
        textDiv.style.marginBottom = "10px";
        textDiv.textContent = initialText;

        overlay.appendChild(textDiv);
        document.body.appendChild(overlay);

        return {
            update(msg) {
                textDiv.textContent = msg;
            },
            close() {
                document.body.removeChild(overlay);
            }
        };
    }

    async function loadSam3RecipePresets() {
        try {
            const resp = await fetch(`${API_ROOT}/agent_mining/recipes`);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            const normalized = (Array.isArray(data) ? data : [])
                .map((entry) => normalizeAgentRecipePayload(entry))
                .filter((entry) => entry && entry.id);
            sam3CascadeState.recipePresets = normalized;
            if (Array.isArray(sam3CascadeState.steps) && sam3CascadeState.steps.length && normalized.length) {
                sam3CascadeState.steps.forEach((step) => {
                    if (!step.recipe_id) {
                        step.recipe_id = normalized[0].id;
                    }
                });
            }
            refreshSam3CascadeClipHeadSourceOptions({ preserveSelection: true });
            renderSam3CascadeSteps();
            refreshSam3CascadeControls();
        } catch (err) {
            console.error("Load recipe presets failed", err);
            setSam3RecipeStatus("Failed to load recipe presets.", "warn");
        }
    }

    async function loadSam3ClipClassifiers() {
        try {
            const resp = await fetch(`${API_ROOT}/clip/classifiers`);
            if (!resp.ok) throw new Error(`HTTP ${resp.status}`);
            const data = await resp.json();
            sam3CascadeState.clipClassifiers = Array.isArray(data) ? data : [];
            renderSam3CascadeSteps();
            refreshSam3CascadeControls();
        } catch (err) {
            console.warn("Load CLIP classifiers failed", err);
            sam3CascadeState.clipClassifiers = [];
        }
    }

    async function saveSam3RecipePreset() {
        const recipe = sam3RecipeState.recipe;
        const hasContent =
            recipe &&
            ((Array.isArray(recipe.steps) && recipe.steps.length > 0) ||
                (Array.isArray(recipe.text_prompts) && recipe.text_prompts.length > 0) ||
                (Array.isArray(recipe.positives) && recipe.positives.length > 0));
        if (!hasContent) {
            setSam3RecipeStatus("Load a recipe first, then save.", "warn");
            return;
        }
        const datasetId = recipe.dataset_id;
        if (!datasetId) {
            setSam3RecipeStatus("This recipe is missing a dataset id, so it cannot be saved as a backend preset yet.", "warn");
            return;
        }
        try {
            const recipePayload =
                recipe.raw && typeof recipe.raw === "object"
                    ? recipe.raw
                    : {
                          params: recipe.params || {},
                          recipe: {
                              mode: recipe.mode || null,
                              text_prompts: recipe.text_prompts || [],
                              positives: recipe.positives || [],
                              steps: recipe.steps || [],
                              negatives: recipe.negatives || [],
                              summary: recipe.summary,
                          },
                      };
            const payload = {
                label: sam3RecipeElements.presetNameInput?.value || recipe.label || "",
                class_name: recipe.class_name,
                class_id: recipe.class_id,
                recipe: recipePayload,
                dataset_id: datasetId,
            };
            const resp = await fetch(`${API_ROOT}/agent_mining/recipes`, {
                method: "POST",
                headers: { "Content-Type": "application/json" },
                body: JSON.stringify(payload),
            });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            await loadSam3RecipePresets();
            setSam3RecipeStatus("Saved recipe preset.", "success");
        } catch (err) {
            console.error("Save recipe preset failed", err);
            setSam3RecipeStatus(err.message || "Save failed.", "error");
        }
    }

    async function loadSam3RecipePreset() {
        const presetId = sam3RecipeElements.presetSelect?.value;
        if (!presetId) {
            setSam3RecipeStatus("Choose a recipe preset to load.", "warn");
            return;
        }
        try {
            const resp = await fetch(`${API_ROOT}/agent_mining/recipes/${encodeURIComponent(presetId)}`);
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            const data = await resp.json();
            const parsed = normalizeAgentRecipePayload(data);
            const hasContent =
                parsed &&
                ((Array.isArray(parsed.steps) && parsed.steps.length > 0) ||
                    (Array.isArray(parsed.text_prompts) && parsed.text_prompts.length > 0) ||
                    (Array.isArray(parsed.positives) && parsed.positives.length > 0));
            if (!hasContent) {
                throw new Error("Preset has no content.");
            }
            const classNames = orderedClassNames();
            const lowerToName = new Map(classNames.map((n) => [n.toLowerCase(), n]));
            const targetName = (parsed.class_name || "").trim();
            if (targetName) {
                const found = lowerToName.get(targetName.toLowerCase());
                if (found) {
                    parsed.class_name = found;
                } else {
                    setSam3RecipeStatus(
                        `Loaded recipe ${parsed.label}. Note: class ${targetName} not in label map; use output class override to apply.`,
                        "warn"
                    );
                }
            }
            sam3RecipeState.recipe = parsed;
            if (sam3RecipeElements.applyButton) sam3RecipeElements.applyButton.disabled = false;
            if (sam3RecipeElements.presetNameInput) sam3RecipeElements.presetNameInput.value = parsed.label || parsed.class_name;
            if (!sam3RecipeElements.status?.textContent) {
                const parts = [];
                if (parsed.mode) parts.push(parsed.mode);
                const promptCount = Array.isArray(parsed.text_prompts) ? parsed.text_prompts.length : 0;
                const posCount = Array.isArray(parsed.positives) ? parsed.positives.length : 0;
                const stepCount = Array.isArray(parsed.steps) ? parsed.steps.length : 0;
                parts.push(`${promptCount} prompts`);
                parts.push(`${posCount} crops`);
                if (stepCount) parts.push(`${stepCount} steps`);
                setSam3RecipeStatus(`Loaded recipe ${parsed.label} (${parts.join(", ")}).`, "success");
            }
        } catch (err) {
            console.error("Load recipe preset failed", err);
            setSam3RecipeStatus(err.message || "Load failed.", "error");
            sam3RecipeState.recipe = null;
            if (sam3RecipeElements.applyButton) sam3RecipeElements.applyButton.disabled = true;
        }
    }

    async function deleteSam3RecipePreset() {
        const presetId = sam3RecipeElements.presetSelect?.value;
        if (!presetId) {
            setSam3RecipeStatus("Choose a recipe preset to delete.", "warn");
            return;
        }
        const confirmed = window.confirm("Delete this recipe? This cannot be undone.");
        if (!confirmed) return;
        try {
            const resp = await fetch(`${API_ROOT}/agent_mining/recipes/${encodeURIComponent(presetId)}`, {
                method: "DELETE",
            });
            if (!resp.ok) {
                const detail = await resp.text();
                throw new Error(detail || `HTTP ${resp.status}`);
            }
            sam3RecipeState.recipe = null;
            if (sam3RecipeElements.applyButton) sam3RecipeElements.applyButton.disabled = true;
            if (sam3RecipeElements.presetNameInput) sam3RecipeElements.presetNameInput.value = "";
            await loadSam3RecipePresets();
            setSam3RecipeStatus("Deleted recipe preset.", "success");
        } catch (err) {
            console.error("Delete recipe preset failed", err);
            setSam3RecipeStatus(err.message || "Delete failed.", "error");
        }
    }

})();
